import {
  __commonJS
} from "./chunk-4YJ6HKSX.js";

// ../../node_modules/json-cyclic/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/json-cyclic/dist/index.js"(exports, module) {
    var isArray = (e) => Array.isArray(e);
    var isObject = (e) => "Object" === Object.prototype.toString.call(e).slice(8, -1);
    var validate = (e) => {
      if (void 0 === e) throw new Error("This method requires one parameter");
      if (!isArray(e) && !isObject(e)) throw new TypeError("This method only accepts arrays and objects");
    };
    var isRef = (e) => isObject(e) && e.hasOwnProperty("$ref") && 1 === Object.keys(e).length && !!e.$ref && "$" === e.$ref.charAt(0);
    var encycle = (arg) => {
      validate(arg);
      const recurs = (value) => isArray(value) || isObject(value) ? isArray(value) ? value.map((elem, i) => isRef(elem) ? (value[i] = eval("arg" + elem.$ref.slice(1)), value) : recurs(elem)) : Object.keys(value).reduce((accum, key) => (accum[key] = isRef(value[key]) ? eval("arg" + value[key].$ref.slice(1)) : recurs(value[key]), accum), value) : value;
      return recurs(arg);
    };
    var findRef = (e, r) => Object.keys(r).find((a) => r[a] === e);
    var decycle = (e) => {
      validate(e);
      let r = {};
      const a = (e2, c = "$") => {
        const s = findRef(e2, r);
        return s ? { $ref: s } : isArray(e2) || isObject(e2) ? (r[c] = e2, isArray(e2) ? e2.map((e3, r2) => a(e3, `${c}[${r2}]`)) : Object.keys(e2).reduce((r2, s2) => (r2[s2] = a(e2[s2], `${c}.${s2}`), r2), {})) : e2;
      };
      return a(e);
    };
    exports.decycle = decycle, exports.encycle = encycle;
  }
});
export default require_dist();
//# sourceMappingURL=json-cyclic.js.map
