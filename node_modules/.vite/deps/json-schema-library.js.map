{
  "version": 3,
  "sources": ["../../../../../node_modules/@sagold/json-pointer/dist/jsonPointer.js", "../../../../../node_modules/valid-url/index.js", "../../../../../node_modules/nearley/lib/nearley.js", "../../../../../node_modules/smtp-address-parser/lib/grammar.ts", "../../../../../node_modules/smtp-address-parser/lib/index.ts", "../../../../../node_modules/deepmerge/dist/cjs.js", "../../../../../node_modules/fast-deep-equal/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/config/strings.js", "../../../../../node_modules/json-schema-library/dist/module/lib/getTypeOf.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/render.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/__.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js", "../../../../../node_modules/json-schema-library/dist/module/lib/config/settings.js", "../../../../../node_modules/json-schema-library/dist/module/lib/types.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/filter.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/isObject.js", "../../../../../node_modules/json-schema-library/dist/module/lib/features/oneOf.js", "../../../../../node_modules/json-schema-library/dist/module/lib/mergeSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/omit.js", "../../../../../node_modules/json-schema-library/dist/module/lib/features/if.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/shallowCloneSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/features/allOf.js", "../../../../../node_modules/json-schema-library/dist/module/lib/schemaNode.js", "../../../../../node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js", "../../../../../node_modules/json-schema-library/dist/module/lib/resolveRef.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validateAsync.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js", "../../../../../node_modules/json-schema-library/dist/module/lib/features/dependencies.js", "../../../../../node_modules/json-schema-library/dist/module/lib/features/anyOf.js", "../../../../../node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/reduceSchema.js", "../../../../../src/utils.ts", "../../../../../src/copier.ts", "../../../../../src/index.ts", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/copy.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft04/addRemoteSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/eachSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/compile/joinScope.js", "../../../../../node_modules/json-schema-library/dist/module/lib/compile/getRef.js", "../../../../../node_modules/json-schema-library/dist/module/lib/compile/splitRef.js", "../../../../../node_modules/json-schema-library/dist/module/lib/compile/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/createSchemaOf.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validation/errors.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validation/format.js", "../../../../../node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js", "../../../../../node_modules/json-schema-library/dist/module/lib/getSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/merge.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js", "../../../../../node_modules/json-schema-library/dist/module/lib/getTemplate.js", "../../../../../node_modules/json-schema-library/dist/module/lib/isValid.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js", "../../../../../node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validation/keyword.js", "../../../../../node_modules/json-schema-library/dist/module/lib/step.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validation/type.js", "../../../../../node_modules/json-schema-library/dist/module/lib/validate.js", "../../../../../node_modules/json-schema-library/dist/module/lib/each.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft04/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft06/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft07/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft2019/validation/keyword.js", "../../../../../node_modules/json-schema-library/dist/module/lib/draft2019/index.js", "../../../../../node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js", "../../../../../node_modules/json-schema-library/dist/module/index.js"],
  "sourcesContent": ["!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"jsonPointer\",[],t):\"object\"==typeof exports?exports.jsonPointer=t():e.jsonPointer=t()}(\"undefined\"!=typeof self?self:this,(()=>(()=>{\"use strict\";var e={d:(t,n)=>{for(var r in n)e.o(n,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:n[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})}},t={};function n(e){return\"#\"===e||\"\"===e||Array.isArray(e)&&0===e.length||!1}e.r(t),e.d(t,{default:()=>_,get:()=>s,isRoot:()=>n,join:()=>P,remove:()=>v,removeUndefinedItems:()=>m,set:()=>g,split:()=>f,splitLast:()=>O});const r=/~1/g,o=/~0/g,i=/(^#?\\/?)/g;function l(e){return e.replace(r,\"/\").replace(o,\"~\")}function u(e){return l(decodeURIComponent(e))}function f(e){if(null==e||\"string\"!=typeof e||n(e))return Array.isArray(e)?e:[];const t=e.indexOf(\"#\")>=0?u:l,r=(e=e.replace(i,\"\")).split(\"/\");for(let e=0,n=r.length;e<n;e+=1)r[e]=t(r[e]);return r}function s(e,t,r=void 0){if(null==t||null==e)return r;if(n(t))return e;const o=c(e,f(t));return void 0===o?r:o}function c(e,t){const n=t.shift();if(void 0!==e)return void 0!==n?c(e[n],t):e}const p=/^\\[.*\\]$/,d=/^\\[(.+)\\]$/;function a(e,t){return\"__proto__\"===e||\"constructor\"==e&&t.length>0&&\"prototype\"==t[0]}function g(e,t,n){if(null==t)return e;const r=f(t);if(0===r.length)return e;null==e&&(e=p.test(r[0])?[]:{});let o,i,l=e;for(;r.length>1;)o=r.shift(),i=p.test(r[0]),a(o,r)||(l=h(l,o,i));return o=r.pop(),y(l,o,n),e}function y(e,t,n){let r;const o=t.match(d);\"[]\"===t&&Array.isArray(e)?e.push(n):o?(r=o.pop(),e[r]=n):e[t]=n}function h(e,t,n){if(null!=e[t])return e[t];const r=n?[]:{};return y(e,t,r),r}function m(e){let t=0,n=0;for(;t+n<e.length;)void 0===e[t+n]&&(n+=1),e[t]=e[t+n],t+=1;return e.length=e.length-n,e}function v(e,t,n){const r=f(t),o=r.pop(),i=s(e,r);return i&&delete i[o],Array.isArray(i)&&!0!==n&&m(i),e}const j=/~/g,b=/\\//g;function A(e,t){if(0===e.length)return t?\"#\":\"\";for(let n=0,r=e.length;n<r;n+=1)e[n]=e[n].replace(j,\"~0\").replace(b,\"~1\"),t&&(e[n]=encodeURIComponent(e[n]));return(t?\"#/\":\"/\")+e.join(\"/\")}function P(e,...t){const n=[];if(Array.isArray(e))return A(e,!0===arguments[1]);const r=arguments[arguments.length-1],o=\"boolean\"==typeof r?r:e&&\"#\"===e[0];for(let e=0,t=arguments.length;e<t;e+=1)n.push.apply(n,f(arguments[e]));const i=[];for(let e=0,t=n.length;e<t;e+=1)if(\"..\"===n[e]){if(0===i.length)return o?\"#\":\"\";i.pop()}else i.push(n[e]);return A(i,o)}function O(e){const t=f(e);if(0===t.length)return\"string\"==typeof e&&\"#\"===e[0]?[\"#\",t[0]]:[\"\",void 0];if(1===t.length)return\"#\"===e[0]?[\"#\",t[0]]:[\"\",t[0]];const n=t.pop();return[P(t,\"#\"===e[0]),n]}const _={get:s,set:g,remove:v,join:P,split:f,splitLast:O,isRoot:n,removeUndefinedItems:m};return t})()));", "(function(module) {\n    'use strict';\n\n    module.exports.is_uri = is_iri;\n    module.exports.is_http_uri = is_http_iri;\n    module.exports.is_https_uri = is_https_iri;\n    module.exports.is_web_uri = is_web_iri;\n    // Create aliases\n    module.exports.isUri = is_iri;\n    module.exports.isHttpUri = is_http_iri;\n    module.exports.isHttpsUri = is_https_iri;\n    module.exports.isWebUri = is_web_iri;\n\n\n    // private function\n    // internal URI spitter method - direct from RFC 3986\n    var splitUri = function(uri) {\n        var splitted = uri.match(/(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/);\n        return splitted;\n    };\n\n    function is_iri(value) {\n        if (!value) {\n            return;\n        }\n\n        // check for illegal characters\n        if (/[^a-z0-9\\:\\/\\?\\#\\[\\]\\@\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=\\.\\-\\_\\~\\%]/i.test(value)) return;\n\n        // check for hex escapes that aren't complete\n        if (/%[^0-9a-f]/i.test(value)) return;\n        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        // scheme and path are required, though the path can be empty\n        if (!(scheme && scheme.length && path.length >= 0)) return;\n\n        // if authority is present, the path must be empty or begin with a /\n        if (authority && authority.length) {\n            if (!(path.length === 0 || /^\\//.test(path))) return;\n        } else {\n            // if authority is not present, the path must not start with //\n            if (/^\\/\\//.test(path)) return;\n        }\n\n        // scheme must begin with a letter, then consist of letters, digits, +, ., or -\n        if (!/^[a-z][a-z0-9\\+\\-\\.]*$/.test(scheme.toLowerCase()))  return;\n\n        // re-assemble the URL per section 5.3 in RFC 3986\n        out += scheme + ':';\n        if (authority && authority.length) {\n            out += '//' + authority;\n        }\n\n        out += path;\n\n        if (query && query.length) {\n            out += '?' + query;\n        }\n\n        if (fragment && fragment.length) {\n            out += '#' + fragment;\n        }\n\n        return out;\n    }\n\n    function is_http_iri(value, allowHttps) {\n        if (!is_iri(value)) {\n            return;\n        }\n\n        var splitted = [];\n        var scheme = '';\n        var authority = '';\n        var path = '';\n        var port = '';\n        var query = '';\n        var fragment = '';\n        var out = '';\n\n        // from RFC 3986\n        splitted = splitUri(value);\n        scheme = splitted[1]; \n        authority = splitted[2];\n        path = splitted[3];\n        query = splitted[4];\n        fragment = splitted[5];\n\n        if (!scheme)  return;\n\n        if(allowHttps) {\n            if (scheme.toLowerCase() != 'https') return;\n        } else {\n            if (scheme.toLowerCase() != 'http') return;\n        }\n\n        // fully-qualified URIs must have an authority section that is\n        // a valid host\n        if (!authority) {\n            return;\n        }\n\n        // enable port component\n        if (/:(\\d+)$/.test(authority)) {\n            port = authority.match(/:(\\d+)$/)[0];\n            authority = authority.replace(/:\\d+$/, '');\n        }\n\n        out += scheme + ':';\n        out += '//' + authority;\n        \n        if (port) {\n            out += port;\n        }\n        \n        out += path;\n        \n        if(query && query.length){\n            out += '?' + query;\n        }\n\n        if(fragment && fragment.length){\n            out += '#' + fragment;\n        }\n        \n        return out;\n    }\n\n    function is_https_iri(value) {\n        return is_http_iri(value, true);\n    }\n\n    function is_web_iri(value) {\n        return (is_http_iri(value) || is_https_iri(value));\n    }\n\n})(module);\n", "(function(root, factory) {\n    if (typeof module === 'object' && module.exports) {\n        module.exports = factory();\n    } else {\n        root.nearley = factory();\n    }\n}(this, function() {\n\n    function Rule(name, symbols, postprocess) {\n        this.id = ++Rule.highestId;\n        this.name = name;\n        this.symbols = symbols;        // a list of literal | regex class | nonterminal\n        this.postprocess = postprocess;\n        return this;\n    }\n    Rule.highestId = 0;\n\n    Rule.prototype.toString = function(withCursorAt) {\n        var symbolSequence = (typeof withCursorAt === \"undefined\")\n                             ? this.symbols.map(getSymbolShortDisplay).join(' ')\n                             : (   this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(' ')\n                                 + \" ● \"\n                                 + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(' ')     );\n        return this.name + \" → \" + symbolSequence;\n    }\n\n\n    // a State is a rule at a position from a given starting point in the input stream (reference)\n    function State(rule, dot, reference, wantedBy) {\n        this.rule = rule;\n        this.dot = dot;\n        this.reference = reference;\n        this.data = [];\n        this.wantedBy = wantedBy;\n        this.isComplete = this.dot === rule.symbols.length;\n    }\n\n    State.prototype.toString = function() {\n        return \"{\" + this.rule.toString(this.dot) + \"}, from: \" + (this.reference || 0);\n    };\n\n    State.prototype.nextState = function(child) {\n        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);\n        state.left = this;\n        state.right = child;\n        if (state.isComplete) {\n            state.data = state.build();\n            // Having right set here will prevent the right state and its children\n            // form being garbage collected\n            state.right = undefined;\n        }\n        return state;\n    };\n\n    State.prototype.build = function() {\n        var children = [];\n        var node = this;\n        do {\n            children.push(node.right.data);\n            node = node.left;\n        } while (node.left);\n        children.reverse();\n        return children;\n    };\n\n    State.prototype.finish = function() {\n        if (this.rule.postprocess) {\n            this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);\n        }\n    };\n\n\n    function Column(grammar, index) {\n        this.grammar = grammar;\n        this.index = index;\n        this.states = [];\n        this.wants = {}; // states indexed by the non-terminal they expect\n        this.scannable = []; // list of states that expect a token\n        this.completed = {}; // states that are nullable\n    }\n\n\n    Column.prototype.process = function(nextColumn) {\n        var states = this.states;\n        var wants = this.wants;\n        var completed = this.completed;\n\n        for (var w = 0; w < states.length; w++) { // nb. we push() during iteration\n            var state = states[w];\n\n            if (state.isComplete) {\n                state.finish();\n                if (state.data !== Parser.fail) {\n                    // complete\n                    var wantedBy = state.wantedBy;\n                    for (var i = wantedBy.length; i--; ) { // this line is hot\n                        var left = wantedBy[i];\n                        this.complete(left, state);\n                    }\n\n                    // special-case nullables\n                    if (state.reference === this.index) {\n                        // make sure future predictors of this rule get completed.\n                        var exp = state.rule.name;\n                        (this.completed[exp] = this.completed[exp] || []).push(state);\n                    }\n                }\n\n            } else {\n                // queue scannable states\n                var exp = state.rule.symbols[state.dot];\n                if (typeof exp !== 'string') {\n                    this.scannable.push(state);\n                    continue;\n                }\n\n                // predict\n                if (wants[exp]) {\n                    wants[exp].push(state);\n\n                    if (completed.hasOwnProperty(exp)) {\n                        var nulls = completed[exp];\n                        for (var i = 0; i < nulls.length; i++) {\n                            var right = nulls[i];\n                            this.complete(state, right);\n                        }\n                    }\n                } else {\n                    wants[exp] = [state];\n                    this.predict(exp);\n                }\n            }\n        }\n    }\n\n    Column.prototype.predict = function(exp) {\n        var rules = this.grammar.byName[exp] || [];\n\n        for (var i = 0; i < rules.length; i++) {\n            var r = rules[i];\n            var wantedBy = this.wants[exp];\n            var s = new State(r, 0, this.index, wantedBy);\n            this.states.push(s);\n        }\n    }\n\n    Column.prototype.complete = function(left, right) {\n        var copy = left.nextState(right);\n        this.states.push(copy);\n    }\n\n\n    function Grammar(rules, start) {\n        this.rules = rules;\n        this.start = start || this.rules[0].name;\n        var byName = this.byName = {};\n        this.rules.forEach(function(rule) {\n            if (!byName.hasOwnProperty(rule.name)) {\n                byName[rule.name] = [];\n            }\n            byName[rule.name].push(rule);\n        });\n    }\n\n    // So we can allow passing (rules, start) directly to Parser for backwards compatibility\n    Grammar.fromCompiled = function(rules, start) {\n        var lexer = rules.Lexer;\n        if (rules.ParserStart) {\n          start = rules.ParserStart;\n          rules = rules.ParserRules;\n        }\n        var rules = rules.map(function (r) { return (new Rule(r.name, r.symbols, r.postprocess)); });\n        var g = new Grammar(rules, start);\n        g.lexer = lexer; // nb. storing lexer on Grammar is iffy, but unavoidable\n        return g;\n    }\n\n\n    function StreamLexer() {\n      this.reset(\"\");\n    }\n\n    StreamLexer.prototype.reset = function(data, state) {\n        this.buffer = data;\n        this.index = 0;\n        this.line = state ? state.line : 1;\n        this.lastLineBreak = state ? -state.col : 0;\n    }\n\n    StreamLexer.prototype.next = function() {\n        if (this.index < this.buffer.length) {\n            var ch = this.buffer[this.index++];\n            if (ch === '\\n') {\n              this.line += 1;\n              this.lastLineBreak = this.index;\n            }\n            return {value: ch};\n        }\n    }\n\n    StreamLexer.prototype.save = function() {\n      return {\n        line: this.line,\n        col: this.index - this.lastLineBreak,\n      }\n    }\n\n    StreamLexer.prototype.formatError = function(token, message) {\n        // nb. this gets called after consuming the offending token,\n        // so the culprit is index-1\n        var buffer = this.buffer;\n        if (typeof buffer === 'string') {\n            var lines = buffer\n                .split(\"\\n\")\n                .slice(\n                    Math.max(0, this.line - 5), \n                    this.line\n                );\n\n            var nextLineBreak = buffer.indexOf('\\n', this.index);\n            if (nextLineBreak === -1) nextLineBreak = buffer.length;\n            var col = this.index - this.lastLineBreak;\n            var lastLineDigits = String(this.line).length;\n            message += \" at line \" + this.line + \" col \" + col + \":\\n\\n\";\n            message += lines\n                .map(function(line, i) {\n                    return pad(this.line - lines.length + i + 1, lastLineDigits) + \" \" + line;\n                }, this)\n                .join(\"\\n\");\n            message += \"\\n\" + pad(\"\", lastLineDigits + col) + \"^\\n\";\n            return message;\n        } else {\n            return message + \" at index \" + (this.index - 1);\n        }\n\n        function pad(n, length) {\n            var s = String(n);\n            return Array(length - s.length + 1).join(\" \") + s;\n        }\n    }\n\n    function Parser(rules, start, options) {\n        if (rules instanceof Grammar) {\n            var grammar = rules;\n            var options = start;\n        } else {\n            var grammar = Grammar.fromCompiled(rules, start);\n        }\n        this.grammar = grammar;\n\n        // Read options\n        this.options = {\n            keepHistory: false,\n            lexer: grammar.lexer || new StreamLexer,\n        };\n        for (var key in (options || {})) {\n            this.options[key] = options[key];\n        }\n\n        // Setup lexer\n        this.lexer = this.options.lexer;\n        this.lexerState = undefined;\n\n        // Setup a table\n        var column = new Column(grammar, 0);\n        var table = this.table = [column];\n\n        // I could be expecting anything.\n        column.wants[grammar.start] = [];\n        column.predict(grammar.start);\n        // TODO what if start rule is nullable?\n        column.process();\n        this.current = 0; // token index\n    }\n\n    // create a reserved token for indicating a parse fail\n    Parser.fail = {};\n\n    Parser.prototype.feed = function(chunk) {\n        var lexer = this.lexer;\n        lexer.reset(chunk, this.lexerState);\n\n        var token;\n        while (true) {\n            try {\n                token = lexer.next();\n                if (!token) {\n                    break;\n                }\n            } catch (e) {\n                // Create the next column so that the error reporter\n                // can display the correctly predicted states.\n                var nextColumn = new Column(this.grammar, this.current + 1);\n                this.table.push(nextColumn);\n                var err = new Error(this.reportLexerError(e));\n                err.offset = this.current;\n                err.token = e.token;\n                throw err;\n            }\n            // We add new states to table[current+1]\n            var column = this.table[this.current];\n\n            // GC unused states\n            if (!this.options.keepHistory) {\n                delete this.table[this.current - 1];\n            }\n\n            var n = this.current + 1;\n            var nextColumn = new Column(this.grammar, n);\n            this.table.push(nextColumn);\n\n            // Advance all tokens that expect the symbol\n            var literal = token.text !== undefined ? token.text : token.value;\n            var value = lexer.constructor === StreamLexer ? token.value : token;\n            var scannable = column.scannable;\n            for (var w = scannable.length; w--; ) {\n                var state = scannable[w];\n                var expect = state.rule.symbols[state.dot];\n                // Try to consume the token\n                // either regex or literal\n                if (expect.test ? expect.test(value) :\n                    expect.type ? expect.type === token.type\n                                : expect.literal === literal) {\n                    // Add it\n                    var next = state.nextState({data: value, token: token, isToken: true, reference: n - 1});\n                    nextColumn.states.push(next);\n                }\n            }\n\n            // Next, for each of the rules, we either\n            // (a) complete it, and try to see if the reference row expected that\n            //     rule\n            // (b) predict the next nonterminal it expects by adding that\n            //     nonterminal's start state\n            // To prevent duplication, we also keep track of rules we have already\n            // added\n\n            nextColumn.process();\n\n            // If needed, throw an error:\n            if (nextColumn.states.length === 0) {\n                // No states at all! This is not good.\n                var err = new Error(this.reportError(token));\n                err.offset = this.current;\n                err.token = token;\n                throw err;\n            }\n\n            // maybe save lexer state\n            if (this.options.keepHistory) {\n              column.lexerState = lexer.save()\n            }\n\n            this.current++;\n        }\n        if (column) {\n          this.lexerState = lexer.save()\n        }\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n\n        // Allow chaining, for whatever it's worth\n        return this;\n    };\n\n    Parser.prototype.reportLexerError = function(lexerError) {\n        var tokenDisplay, lexerMessage;\n        // Planning to add a token property to moo's thrown error\n        // even on erroring tokens to be used in error display below\n        var token = lexerError.token;\n        if (token) {\n            tokenDisplay = \"input \" + JSON.stringify(token.text[0]) + \" (lexer error)\";\n            lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        } else {\n            tokenDisplay = \"input (lexer error)\";\n            lexerMessage = lexerError.message;\n        }\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportError = function(token) {\n        var tokenDisplay = (token.type ? token.type + \" token: \" : \"\") + JSON.stringify(token.value !== undefined ? token.value : token);\n        var lexerMessage = this.lexer.formatError(token, \"Syntax error\");\n        return this.reportErrorCommon(lexerMessage, tokenDisplay);\n    };\n\n    Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {\n        var lines = [];\n        lines.push(lexerMessage);\n        var lastColumnIndex = this.table.length - 2;\n        var lastColumn = this.table[lastColumnIndex];\n        var expectantStates = lastColumn.states\n            .filter(function(state) {\n                var nextSymbol = state.rule.symbols[state.dot];\n                return nextSymbol && typeof nextSymbol !== \"string\";\n            });\n\n        if (expectantStates.length === 0) {\n            lines.push('Unexpected ' + tokenDisplay + '. I did not expect any more input. Here is the state of my parse table:\\n');\n            this.displayStateStack(lastColumn.states, lines);\n        } else {\n            lines.push('Unexpected ' + tokenDisplay + '. Instead, I was expecting to see one of the following:\\n');\n            // Display a \"state stack\" for each expectant state\n            // - which shows you how this state came to be, step by step.\n            // If there is more than one derivation, we only display the first one.\n            var stateStacks = expectantStates\n                .map(function(state) {\n                    return this.buildFirstStateStack(state, []) || [state];\n                }, this);\n            // Display each state that is expecting a terminal symbol next.\n            stateStacks.forEach(function(stateStack) {\n                var state = stateStack[0];\n                var nextSymbol = state.rule.symbols[state.dot];\n                var symbolDisplay = this.getSymbolDisplay(nextSymbol);\n                lines.push('A ' + symbolDisplay + ' based on:');\n                this.displayStateStack(stateStack, lines);\n            }, this);\n        }\n        lines.push(\"\");\n        return lines.join(\"\\n\");\n    }\n    \n    Parser.prototype.displayStateStack = function(stateStack, lines) {\n        var lastDisplay;\n        var sameDisplayCount = 0;\n        for (var j = 0; j < stateStack.length; j++) {\n            var state = stateStack[j];\n            var display = state.rule.toString(state.dot);\n            if (display === lastDisplay) {\n                sameDisplayCount++;\n            } else {\n                if (sameDisplayCount > 0) {\n                    lines.push('    ^ ' + sameDisplayCount + ' more lines identical to this');\n                }\n                sameDisplayCount = 0;\n                lines.push('    ' + display);\n            }\n            lastDisplay = display;\n        }\n    };\n\n    Parser.prototype.getSymbolDisplay = function(symbol) {\n        return getSymbolLongDisplay(symbol);\n    };\n\n    /*\n    Builds a the first state stack. You can think of a state stack as the call stack\n    of the recursive-descent parser which the Nearley parse algorithm simulates.\n    A state stack is represented as an array of state objects. Within a\n    state stack, the first item of the array will be the starting\n    state, with each successive item in the array going further back into history.\n\n    This function needs to be given a starting state and an empty array representing\n    the visited states, and it returns an single state stack.\n\n    */\n    Parser.prototype.buildFirstStateStack = function(state, visited) {\n        if (visited.indexOf(state) !== -1) {\n            // Found cycle, return null\n            // to eliminate this path from the results, because\n            // we don't know how to display it meaningfully\n            return null;\n        }\n        if (state.wantedBy.length === 0) {\n            return [state];\n        }\n        var prevState = state.wantedBy[0];\n        var childVisited = [state].concat(visited);\n        var childResult = this.buildFirstStateStack(prevState, childVisited);\n        if (childResult === null) {\n            return null;\n        }\n        return [state].concat(childResult);\n    };\n\n    Parser.prototype.save = function() {\n        var column = this.table[this.current];\n        column.lexerState = this.lexerState;\n        return column;\n    };\n\n    Parser.prototype.restore = function(column) {\n        var index = column.index;\n        this.current = index;\n        this.table[index] = column;\n        this.table.splice(index + 1);\n        this.lexerState = column.lexerState;\n\n        // Incrementally keep track of results\n        this.results = this.finish();\n    };\n\n    // nb. deprecated: use save/restore instead!\n    Parser.prototype.rewind = function(index) {\n        if (!this.options.keepHistory) {\n            throw new Error('set option `keepHistory` to enable rewinding')\n        }\n        // nb. recall column (table) indicies fall between token indicies.\n        //        col 0   --   token 0   --   col 1\n        this.restore(this.table[index]);\n    };\n\n    Parser.prototype.finish = function() {\n        // Return the possible parsings\n        var considerations = [];\n        var start = this.grammar.start;\n        var column = this.table[this.table.length - 1]\n        column.states.forEach(function (t) {\n            if (t.rule.name === start\n                    && t.dot === t.rule.symbols.length\n                    && t.reference === 0\n                    && t.data !== Parser.fail) {\n                considerations.push(t);\n            }\n        });\n        return considerations.map(function(c) {return c.data; });\n    };\n\n    function getSymbolLongDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return 'character matching ' + symbol;\n            } else if (symbol.type) {\n                return symbol.type + ' token';\n            } else if (symbol.test) {\n                return 'token matching ' + String(symbol.test);\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    function getSymbolShortDisplay(symbol) {\n        var type = typeof symbol;\n        if (type === \"string\") {\n            return symbol;\n        } else if (type === \"object\") {\n            if (symbol.literal) {\n                return JSON.stringify(symbol.literal);\n            } else if (symbol instanceof RegExp) {\n                return symbol.toString();\n            } else if (symbol.type) {\n                return '%' + symbol.type;\n            } else if (symbol.test) {\n                return '<' + String(symbol.test) + '>';\n            } else {\n                throw new Error('Unknown symbol type: ' + symbol);\n            }\n        }\n    }\n\n    return {\n        Parser: Parser,\n        Grammar: Grammar,\n        Rule: Rule,\n    };\n\n}));\n", null, "\"use strict\";\n\n// const punycode = require('punycode');\nconst nearley = require(\"nearley\");\n\nimport { default as myGrammar } from \"./grammar\";\nmyGrammar.ParserStart = \"Mailbox\";\nconst grammar = nearley.Grammar.fromCompiled(myGrammar);\n\n// <https://tools.ietf.org/html/rfc5321#section-4.1.2>\n\nexport function parse(address: string) {\n    const parser = new nearley.Parser(grammar);\n    parser.feed(address);\n\n    if (parser.results.length !== 1) {\n        throw new Error(\"address parsing failed: ambiguous grammar\");\n    }\n\n    return parser.results[0];\n}\n\n/** Strip +something, strip '.'s, and map to lower case.\n */\nexport function normalize_dot_string(dot_string: string) {\n    const tagless = (function () {\n        const plus_loc = dot_string.indexOf(\"+\");\n        if (plus_loc === -1) {\n            return dot_string;\n        }\n        return dot_string.substr(0, plus_loc);\n    })();\n    const dotless = tagless.replace(/\\./g, \"\");\n    return dotless.toLowerCase();\n}\n\n/** The G style address normalization.\n */\nexport function normalize(address: string) {\n    const a = parse(address);\n    const domain = a.domainPart.AddressLiteral ?? a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString ?? normalize_dot_string(a.localPart.DotString);\n    return `${local}@${domain}`;\n}\n\nexport function canonicalize_quoted_string(quoted_string: string) {\n    const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);\n    const unescaped = unquoted.replace(/(?:\\\\(.))/g, \"$1\");\n    const reescaped = unescaped.replace(/(?:([\"\\\\]))/g, \"\\\\$1\");\n    return `\"${reescaped}\"`; // re-quote\n}\n\n/**\n * Apply a canonicalization consistent with standards to support\n * comparison as a string.\n */\nexport function canonicalize(address: string) {\n    const a = parse(address);\n    const domain = a.domainPart.AddressLiteral ?? a.domainPart.DomainName.toLowerCase();\n    const local = a.localPart.QuotedString\n        ? canonicalize_quoted_string(a.localPart.QuotedString)\n        : a.localPart.DotString;\n    return `${local}@${domain}`;\n}\n", "'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n", "'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/* eslint max-len: 0 */\nexport default {\n    // validation errors\n    AdditionalItemsError: \"Array at `{{pointer}}` may not have an additional item `{{key}}`\",\n    AdditionalPropertiesError: \"Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`\",\n    AllOfError: \"Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`\",\n    AnyOfError: \"Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`\",\n    ConstError: \"Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`\",\n    containsAnyError: \"The array at `{{pointer}}` must contain at least one item\",\n    ContainsArrayError: \"The property at `{{pointer}}` must not be an array\",\n    ContainsError: \"The array at `{{pointer}}` must contain an element that matches `{{schema}}`\",\n    ContainsMinError: \"The array at `{{pointer}}` contains {{delta}} too few items matching `{{schema}}`\",\n    ContainsMaxError: \"The array at `{{pointer}}` contains {{delta}} too many items matching `{{schema}}`\",\n    EnumError: \"Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`\",\n    ForbiddenPropertyError: \"Property name `{{property}}` at `{{pointer}}` is not allowed\",\n    FormatDateError: \"Value `{{value}}` at `{{pointer}}` is not a valid date\",\n    FormatDateTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid date-time\",\n    FormatDurationError: \"Value `{{value}}` at `{{pointer}}` is not a valid duration\",\n    FormatEmailError: \"Value `{{value}}` at `{{pointer}}` is not a valid email\",\n    FormatHostnameError: \"Value `{{value}}` at `{{pointer}}` is not a valid hostname\",\n    FormatIPV4Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address\",\n    FormatIPV4LeadingZeroError: \"IPv4 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatIPV6Error: \"Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address\",\n    FormatIPV6LeadingZeroError: \"IPv6 addresses starting with zero are invalid, since they are interpreted as octals\",\n    FormatJsonPointerError: \"Value `{{value}}` at `{{pointer}}` is not a valid json-pointer\",\n    FormatRegExError: \"Value `{{value}}` at `{{pointer}}` is not a valid regular expression\",\n    FormatTimeError: \"Value `{{value}}` at `{{pointer}}` is not a valid time\",\n    FormatURIError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri\",\n    FormatURIReferenceError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-reference\",\n    FormatURITemplateError: \"Value `{{value}}` at `{{pointer}}` is not a valid uri-template\",\n    FormatURLError: \"Value `{{value}}` at `{{pointer}}` is not a valid url\",\n    FormatUUIDError: \"Value `{{value}}` at `{{pointer}}` is not a valid uuid\",\n    InvalidDataError: \"No value may be specified in `{{pointer}}`\",\n    InvalidPropertyNameError: \"Invalid property name `{{property}}` at `{{pointer}}`\",\n    MaximumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum\",\n    MaxItemsError: \"Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MaxLengthError: \"Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.\",\n    MaxPropertiesError: \"Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`\",\n    MinimumError: \"Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum\",\n    MinItemsError: \"Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`\",\n    MinItemsOneError: \"At least one item is required in `{{pointer}}`\",\n    MinLengthError: \"Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.\",\n    MinLengthOneError: \"A value is required in `{{pointer}}`\",\n    MinPropertiesError: \"Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`\",\n    MissingDependencyError: \"The required propery '{{missingProperty}}' in `{{pointer}}` is missing\",\n    MissingOneOfPropertyError: \"Value at `{{pointer}}` property: `{{property}}`\",\n    MultipleOfError: \"Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`\",\n    MultipleOneOfError: \"Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`\",\n    NoAdditionalPropertiesError: \"Additional property `{{property}}` in `{{pointer}}` is not allowed\",\n    NotError: \"Value `{{value}}` at pointer should not match schema `{{not}}`\",\n    OneOfError: \"Value `{{value}}` in `{{pointer}}` does not match any given oneof schema\",\n    OneOfPropertyError: \"Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`\",\n    PatternError: \"Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`\",\n    PatternPropertiesError: \"Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}\",\n    RequiredPropertyError: \"The required property `{{key}}` is missing at `{{pointer}}`\",\n    SchemaWarning: \"Failed retrieving a schema from '{{pointer}}' to key '{{key}}'\",\n    TypeError: \"Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`\",\n    UndefinedValueError: \"Value must not be undefined in `{{pointer}}`\",\n    UnevaluatedPropertyError: \"Invalid unevaluated property `{{pointer}}`\",\n    UnevaluatedItemsError: \"Invalid unevaluated item `{{pointer}}`\",\n    UniqueItemsError: \"Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.\",\n    UnknownPropertyError: \"Could not find a valid schema for property `{{pointer}}` within object\",\n    ValueNotEmptyError: \"A value for `{{property}}` is required at `{{pointer}}`\"\n};\n", "const toString = Object.prototype.toString;\nexport default function getTypeOf(value) {\n    const type = toString\n        .call(value)\n        .match(/\\s([^\\]]+)\\]/)\n        .pop()\n        .toLowerCase();\n    if (type === \"file\") {\n        return \"object\";\n    }\n    return type;\n}\n", "import getTypeOf from \"../getTypeOf\";\nconst OBJECT_TYPE = \"object\";\nconst ARRAY_TYPE = \"array\";\n/**\n * Renders data into a string by {{variables}}.\n * Given a template string, removes all {{property}} substrings and replaces them with the property in the given data\n *\n * @param template - template string containing variables in handelbars/mustache style\n * @param data - flat object containing properties matching variables\n * @return rendered string\n */\nexport default function render(template, data = {}) {\n    return template.replace(/\\{\\{\\w+\\}\\}/g, (match) => {\n        const key = match.replace(/[{}]/g, \"\");\n        const variable = data[key];\n        const variableType = getTypeOf(variable);\n        if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {\n            return JSON.stringify(variable);\n        }\n        return variable;\n    });\n}\n", "import strings from \"../config/strings\";\nimport render from \"./render\";\n/**\n * Renders the given string as defined in __@see config/strings.js__\n * @param keyword\n * @param data - template data\n * @param fallback - fallback template\n * @return resulting string\n */\nexport default function __(keyword, data, fallback = keyword) {\n    var _a;\n    const template = (_a = strings[keyword]) !== null && _a !== void 0 ? _a : fallback;\n    return render(template, data);\n}\n", "import __ from \"./__\";\nfunction dashCase(text) {\n    return text.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nexport function createError(name, data) {\n    return {\n        type: \"error\",\n        name,\n        code: dashCase(name),\n        message: __(name, data),\n        data\n    };\n}\n/**\n * Creates a custom Error Creator. Its messages are defined by strings-object @see config/strings.ts\n *\n * @param name - id of error (camelcased)\n * @return error constructor function\n */\nexport function createCustomError(name) {\n    return createError.bind(null, name);\n}\n", "export default function flattenArray(list, result = []) {\n    for (let i = 0; i < list.length; i += 1) {\n        const item = list[i];\n        if (Array.isArray(item)) {\n            flattenArray(item, result);\n        }\n        else {\n            result.push(item);\n        }\n    }\n    return result;\n}\n", "export default {\n    DECLARATOR_ONEOF: \"oneOfProperty\",\n    GET_TEMPLATE_RECURSION_LIMIT: 1,\n    propertyBlacklist: [\"_id\"],\n    templateDefaultOptions: {\n        addOptionalProps: false,\n        removeInvalidData: false,\n        extendDefaults: true\n    }\n};\n", "/**\n * ts type guard for json error\n * @returns true if passed type is a JsonError\n */\nexport function isJsonError(error) {\n    return (error === null || error === void 0 ? void 0 : error.type) === \"error\";\n}\n", "import { isJsonError } from \"../types\";\nexport function isPromise(obj) {\n    return obj instanceof Promise;\n}\nexport function errorOrPromise(error) {\n    return isJsonError(error) || isPromise(error);\n}\nexport function errorsOnly(error) {\n    return isJsonError(error);\n}\n", "import getTypeOf from \"../getTypeOf\";\nexport function isObject(v) {\n    return getTypeOf(v) === \"object\";\n}\n", "/**\n * @draft-04\n */\nimport flattenArray from \"../utils/flattenArray\";\nimport settings from \"../config/settings\";\nimport { errorOrPromise } from \"../utils/filter\";\nimport { isJsonError } from \"../types\";\nimport { isObject } from \"../utils/isObject\";\nconst { DECLARATOR_ONEOF } = settings;\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft - validator\n * @param data\n * @param schema - current json schema containing property oneOf\n * @param pointer - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOf(node, data) {\n    const { schema, draft, pointer } = node;\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = node.next(schema.oneOf[i]).resolveRef();\n            const resultNode = draft.step(oneNode, oneOfProperty, data);\n            if (isJsonError(resultNode)) {\n                return resultNode;\n            }\n            let result = flattenArray(draft.validate(resultNode, oneOfValue));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return resultNode.next(oneNode.schema);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    const matches = [];\n    const errors = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n        let result = flattenArray(draft.validate(oneNode, data));\n        result = result.filter(errorOrPromise);\n        if (result.length > 0) {\n            errors.push(...result);\n        }\n        else {\n            matches.push({ index: i, schema: oneNode.schema });\n        }\n    }\n    if (matches.length === 1) {\n        return node.next(matches[0].schema);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({\n            value: data,\n            pointer,\n            schema,\n            matches\n        });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf,\n        errors\n    });\n}\n/**\n * Returns a ranking for the data and given schema\n *\n * @param draft\n * @param - json schema type: object\n * @param data\n * @param [pointer]\n * @return ranking value (higher is better)\n */\nfunction fuzzyObjectValue(node, data) {\n    const { draft, schema, pointer } = node;\n    if (data == null || schema.properties == null) {\n        return -1;\n    }\n    let value = 0;\n    const keys = Object.keys(schema.properties);\n    for (let i = 0; i < keys.length; i += 1) {\n        const key = keys[i];\n        if (data[key]) {\n            if (draft.isValid(data[key], schema.properties[key], pointer)) {\n                value += 1;\n            }\n        }\n    }\n    return value;\n}\n/**\n * Selects and returns a oneOf schema for the given data\n *\n * @param draft\n * @param data\n * @param [schema] - current json schema containing property oneOf\n * @param [pointer] - json pointer to data\n * @return oneOf schema or an error\n */\nexport function resolveOneOfFuzzy(node, data) {\n    const { schema, pointer, draft } = node;\n    if (!Array.isArray(schema.oneOf)) {\n        throw new Error(\"not a oneof schema\");\n        return node;\n    }\n    // !keyword: oneOfProperty\n    // an additional <DECLARATOR_ONEOF> (default `oneOfProperty`) on the schema will exactly determine the\n    // oneOf value (if set in data)\n    // @fixme\n    // abort if no data is given an DECLARATOR_ONEOF is set (used by getChildSchemaSelection)\n    // this case (data != null) should not be necessary\n    if (data != null && schema[DECLARATOR_ONEOF]) {\n        const errors = [];\n        const oneOfProperty = schema[DECLARATOR_ONEOF];\n        const oneOfValue = data[schema[DECLARATOR_ONEOF]];\n        if (oneOfValue === undefined) {\n            return draft.errors.missingOneOfPropertyError({\n                property: oneOfProperty,\n                pointer,\n                schema,\n                value: data\n            });\n        }\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n            const resultNode = draft.step(oneNode, oneOfProperty, data);\n            if (isJsonError(resultNode)) {\n                return resultNode;\n            }\n            let result = flattenArray(draft.validate(resultNode, oneOfValue));\n            result = result.filter(errorOrPromise);\n            if (result.length > 0) {\n                errors.push(...result);\n            }\n            else {\n                return resultNode.next(oneNode.schema);\n            }\n        }\n        return draft.errors.oneOfPropertyError({\n            property: oneOfProperty,\n            value: oneOfValue,\n            pointer,\n            schema,\n            errors\n        });\n    }\n    // keyword: oneOf\n    const matches = [];\n    for (let i = 0; i < schema.oneOf.length; i += 1) {\n        const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n        const one = oneNode.schema;\n        if (draft.isValid(data, one, pointer)) {\n            matches.push({ schema: one, index: i });\n        }\n    }\n    if (matches.length === 1) {\n        return node.next(matches[0].schema);\n    }\n    // fuzzy match oneOf\n    if (isObject(data)) {\n        let schemaOfItem;\n        let schemaOfIndex = -1;\n        let fuzzyGreatest = 0;\n        for (let i = 0; i < schema.oneOf.length; i += 1) {\n            const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));\n            const fuzzyValue = fuzzyObjectValue(oneNode, data);\n            if (fuzzyGreatest < fuzzyValue) {\n                fuzzyGreatest = fuzzyValue;\n                schemaOfItem = oneNode.schema;\n                schemaOfIndex = i;\n            }\n        }\n        if (schemaOfItem === undefined) {\n            return draft.errors.oneOfError({\n                value: JSON.stringify(data),\n                pointer,\n                schema,\n                oneOf: schema.oneOf\n            });\n        }\n        return node.next(schemaOfItem);\n    }\n    if (matches.length > 1) {\n        return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });\n    }\n    return draft.errors.oneOfError({\n        value: JSON.stringify(data),\n        pointer,\n        schema,\n        oneOf: schema.oneOf\n    });\n}\n/**\n * validates oneOf definition for given input data\n */\nconst validateOneOf = (node, value) => {\n    if (Array.isArray(node.schema.oneOf)) {\n        const nodeOrError = node.draft.resolveOneOf(node, value);\n        if (isJsonError(nodeOrError)) {\n            return nodeOrError;\n        }\n    }\n};\nexport { validateOneOf };\n", "import getTypeOf from \"./getTypeOf\";\nimport { isObject } from \"./utils/isObject\";\nexport function mergeSchema(a, b, ...omit) {\n    if ((b === null || b === void 0 ? void 0 : b.type) === \"error\") {\n        return b;\n    }\n    else if ((a === null || a === void 0 ? void 0 : a.type) === \"error\") {\n        return a;\n    }\n    const aType = getTypeOf(a);\n    const bType = getTypeOf(b);\n    if (aType !== bType) {\n        return a;\n    }\n    const schema = mergeSchema2(a, b);\n    for (let i = 0; i < omit.length; i += 1) {\n        delete schema[omit[i]];\n    }\n    return schema;\n}\nexport function mergeSchema2(a, b, property) {\n    var _a;\n    if (isObject(a) && isObject(b)) {\n        const newObject = {};\n        [...Object.keys(a), ...Object.keys(b)]\n            .filter((item, index, array) => array.indexOf(item) === index)\n            .forEach(key => (newObject[key] = mergeSchema2(a[key], b[key], key)));\n        return newObject;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (property === \"required\") {\n            return a.concat(b).filter((item, index, array) => array.indexOf(item) === index);\n        }\n        if (property === \"items\") {\n            const result = [];\n            for (let i = 0; i < b.length; i += 1) {\n                if (isObject(a[i]) && isObject(b[i]) && a[i].type === b[i].type) {\n                    result[i] = mergeSchema2(a[i], b[i]);\n                }\n                else {\n                    result.push((_a = b[i]) !== null && _a !== void 0 ? _a : a[i]);\n                }\n            }\n            return result;\n        }\n        const result = [];\n        const append = [];\n        for (let i = 0; i < Math.max(a.length, b.length); i += 1) {\n            if (isObject(a[i]) && isObject(b[i])) {\n                result[i] = mergeSchema2(a[i], b[i]);\n            }\n            else {\n                if (a[i] !== undefined && b[i] !== undefined) {\n                    result[i] = a[i];\n                    append.push(b[i]);\n                }\n                else if (a[i] !== undefined) {\n                    result[i] = a[i];\n                }\n                else if (b[i] !== undefined) {\n                    append.push(b[i]);\n                }\n            }\n        }\n        return [...result, ...append].filter((item, index, array) => array.indexOf(item) === index);\n    }\n    if (Array.isArray(b)) {\n        return b;\n    }\n    if (Array.isArray(a)) {\n        return a;\n    }\n    if (b !== undefined) {\n        return b;\n    }\n    return a;\n}\n", "/**\n * Omit properties from input schema. Accepts any number of properties to\n * remove. Example:\n *\n * ```ts\n * omit(myObject, \"if\", \"dependencies\");\n * ```\n *\n * @returns shallow copy of input object without specified properties\n */\nexport function omit(object, ...keysToOmit) {\n    const result = {};\n    Object.keys(object).forEach((key) => {\n        if (!keysToOmit.includes(key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n}\n", "/**\n * returns if-then-else as a json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns json schema defined by if-then-else or undefined\n */\nexport function resolveIfSchema(node, data) {\n    if (node.schema.if == null) {\n        return undefined;\n    }\n    if (node.schema.if === false) {\n        return node.next(node.schema.else);\n    }\n    if (node.schema.if && (node.schema.then || node.schema.else)) {\n        const ifNode = node.draft.resolveRef(node.next(node.schema.if));\n        const ifErrors = node.draft.validate(ifNode, data);\n        if (ifErrors.length === 0 && node.schema.then) {\n            const thenNode = node.next(node.schema.then);\n            return node.draft.resolveRef(thenNode);\n        }\n        if (ifErrors.length !== 0 && node.schema.else) {\n            const elseNode = node.next(node.schema.else);\n            return node.draft.resolveRef(elseNode);\n        }\n    }\n}\n/**\n * @returns validation result of it-then-else schema\n */\nconst validateIf = (node, value) => {\n    const resolvedNode = resolveIfSchema(node, value);\n    if (resolvedNode) {\n        // @recursiveRef ok, we not just add per pointer, but any evlauation to dynamic scope / validation path\n        return node.draft.validate(resolvedNode, value);\n    }\n};\nexport { validateIf };\n", "export function shallowCloneSchemaNode(node) {\n    return { ...node };\n}\n", "import { mergeSchema } from \"../mergeSchema\";\nimport { omit } from \"../utils/omit\";\nimport { resolveIfSchema } from \"./if\";\nimport { shallowCloneSchemaNode } from \"../utils/shallowCloneSchema\";\n/**\n * resolves schema\n * when complete this will have much duplication to step.object etc\n */\nexport function resolveSchema(node, data) {\n    const ifSchema = resolveIfSchema(node, data);\n    if (ifSchema) {\n        return ifSchema;\n    }\n    const schema = shallowCloneSchemaNode(node.schema);\n    return node.next(omit(schema, \"if\", \"then\", \"else\"));\n}\nexport function resolveAllOf(node, data) {\n    const { schema } = node;\n    let mergedSchema = shallowCloneSchemaNode(schema);\n    for (let i = 0; i < schema.allOf.length; i += 1) {\n        const allOfNode = node.next(schema.allOf[i]).resolveRef();\n        // @todo introduce draft.resolveSchema to iteratively resolve\n        const allOfSchema = resolveSchema(allOfNode, data).schema;\n        mergedSchema = mergeSchema(mergedSchema, allOfSchema);\n    }\n    delete mergedSchema.allOf;\n    return node.next(mergedSchema);\n}\n/**\n * @attention: subschemas have to be resolved upfront (e.g. if-else that do not apply)\n * Merge all allOf sub schema into a single schema. Returns undefined for\n * missing allOf definition.\n *\n * @returns json schema defined by allOf or undefined\n */\nexport function mergeAllOfSchema(draft, schema) {\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    let resolvedSchema = {};\n    allOf.forEach((subschema) => {\n        if (subschema == null) {\n            return;\n        }\n        const subSchemaNode = draft.createNode(subschema).resolveRef();\n        resolvedSchema = mergeSchema(resolvedSchema, subSchemaNode.schema);\n    });\n    return resolvedSchema;\n}\n/**\n * validate allOf definition for given input data\n */\nconst validateAllOf = (node, value) => {\n    const { draft, schema } = node;\n    const { allOf } = schema;\n    if (!Array.isArray(allOf) || allOf.length === 0) {\n        return;\n    }\n    const errors = [];\n    schema.allOf.forEach((subSchema) => {\n        errors.push(...draft.validate(node.next(subSchema), value));\n    });\n    return errors;\n};\nexport { validateAllOf };\n", "import getTypeOf from \"./getTypeOf\";\nimport { isObject } from \"./utils/isObject\";\nimport { isJsonError } from \"./types\";\nimport { mergeSchema } from \"./mergeSchema\";\nfunction merge(schema, ...omit) {\n    if (schema == null) {\n        throw new Error(`undefined schema`);\n    }\n    const node = this;\n    const mergedSchema = mergeSchema(node.schema, schema, ...omit);\n    return { ...node, schema: mergedSchema, path: [...node.path, node.schema] };\n}\nfunction resolveRef() {\n    const node = this;\n    return node.draft.resolveRef(node);\n}\nfunction next(schema, key) {\n    if (isJsonError(schema)) {\n        return schema;\n    }\n    if (schema == null) {\n        throw new Error(`undefined schema`);\n    }\n    if (!isObject(schema) && getTypeOf(schema) !== \"boolean\") {\n        throw new Error(`bad schema type ${getTypeOf(schema)}`);\n    }\n    const node = this;\n    return {\n        ...node,\n        pointer: key ? `${node.pointer}/${key}` : node.pointer,\n        schema,\n        path: [...node.path, node.schema]\n    };\n}\nexport function isSchemaNode(value) {\n    // @ts-expect-error unknown object\n    return isObject(value) && value.next && value.path && value.draft;\n}\nexport function createNode(draft, schema, pointer = \"#\") {\n    return { draft, pointer, schema, path: [], next, merge, resolveRef };\n}\n", "import { isSchemaNode } from \"./schemaNode\";\nexport default function resolveRef(node) {\n    if (!isSchemaNode(node)) {\n        throw new Error(\"schema node expected\");\n    }\n    if (node.schema == null || node.schema.$ref == null) {\n        return node;\n    }\n    if (node.schema.getRoot) {\n        // we actually always need to resolve the schema like this, since returned subschemas\n        // must resolve relative from their schema\n        const resolvedSchema = node.schema.getRoot().getRef(node.schema);\n        return node.next(resolvedSchema);\n    }\n    // tryout - this should never be called, except we missed something\n    const resolvedSchema = node.draft.rootSchema.getRef(node.schema);\n    return node.next(resolvedSchema);\n}\n", "import { isSchemaNode } from \"./schemaNode\";\n// 1. https://json-schema.org/draft/2019-09/json-schema-core#scopes\nfunction resolveRecursiveRef(node) {\n    const history = node.path;\n    // console.log(...history);\n    // RESTRICT BY CHANGE IN BASE-URL\n    let startIndex = 0;\n    for (let i = history.length - 1; i >= 0; i--) {\n        if (history[i].$id && /^https?:\\/\\//.test(history[i].$id) && history[i].$recursiveAnchor !== true) {\n            startIndex = i;\n            break;\n        }\n    }\n    // FROM THERE FIND FIRST OCCURENCE OF ANCHOR\n    const firstAnchor = history.find((s, index) => index >= startIndex && s.$recursiveAnchor === true);\n    if (firstAnchor) {\n        return node.next(firstAnchor);\n    }\n    // THEN RETURN LATEST BASE AS TARGET\n    for (let i = history.length - 1; i >= 0; i--) {\n        if (history[i].$id) {\n            return node.next(history[i]);\n        }\n    }\n    // OR RETURN ROOT\n    return node.next(node.draft.rootSchema);\n}\n/**\n * @todo update types\n * Note: JsonSchema my be false\n */\nexport default function resolveRef(node) {\n    if (!isSchemaNode(node)) {\n        throw new Error(\"expected node\");\n    }\n    if (node.schema == null) {\n        return node;\n    }\n    if (node.schema.$recursiveRef) {\n        return resolveRef(resolveRecursiveRef(node));\n    }\n    if (node.schema.$ref == null) {\n        return node;\n    }\n    const resolvedSchema = node.draft.rootSchema.getRef(node.schema);\n    if (resolvedSchema === false) {\n        return node.next(resolvedSchema);\n    }\n    // @draft >= 2019-09 we now merge schemas: in draft <= 7 $ref is treated as reference, not as schema\n    return node.merge(resolvedSchema, \"$ref\");\n}\n", "import { errorsOnly } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { isJsonError } from \"./types\";\nfunction createErrorNotification(onError) {\n    return function notifyError(error) {\n        if (Array.isArray(error)) {\n            error = flattenArray(error);\n            error.forEach(notifyError);\n            return error;\n        }\n        if (isJsonError(error)) {\n            onError(error);\n        }\n        return error;\n    };\n}\n/**\n * @async\n * Validate data by a json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param options\n * @param options.schema - json schema to use, defaults to draft.rootSchema\n * @param options.pointer - json pointer pointing to current value. Used in error reports\n * @param options.onError   - will be called for each error as soon as it is resolved\n * @return list of errors or empty\n */\nexport default function validateAsync(draft, value, options) {\n    const { schema, pointer, onError } = { schema: draft.rootSchema, pointer: \"#\", ...options };\n    let errors = draft.validate(draft.createNode(schema, pointer), value);\n    if (onError) {\n        errors = flattenArray(errors);\n        const notifyError = createErrorNotification(onError);\n        for (let i = 0; i < errors.length; i += 1) {\n            const error = errors[i];\n            if (error instanceof Promise) {\n                error.then(notifyError);\n            }\n            else if (isJsonError(error)) {\n                onError(error);\n            }\n        }\n    }\n    return Promise.all(errors)\n        .then(flattenArray)\n        .then((resolvedErrors) => resolvedErrors.filter(errorsOnly))\n        .catch((e) => {\n        console.log(\"Failed resolving promises\", e.message);\n        console.log(e.stack);\n        throw e;\n    });\n}\n", "/**\n * @returns list with unique values only\n */\nexport function uniqueItems(list) {\n    return list.filter((item, index) => list.indexOf(item) === index);\n}\n", "import getTypeOf from \"../getTypeOf\";\nimport { mergeSchema } from \"../mergeSchema\";\nimport { uniqueItems } from \"../utils/uniqueItems\";\nimport { isObject } from \"../utils/isObject\";\n/**\n * @todo add support for dependentRequired (draft 2019-09)\n * returns dependencies as an object json schema. does not merge with input\n * json schema. you probably will need to do so to correctly resolve\n * references.\n *\n * @returns merged json schema defined by dependencies or undefined\n */\nexport function resolveDependencies(node, data) {\n    var _a;\n    const { schema } = node;\n    // @draft >= 2019-09 dependentSchemas\n    const dependencies = (_a = schema.dependencies) !== null && _a !== void 0 ? _a : schema.dependentSchemas;\n    if (!isObject(dependencies) || !isObject(data)) {\n        return;\n    }\n    let updated = false;\n    let resolvedSchema = { required: [] };\n    Object.keys(dependencies).forEach((prop) => {\n        var _a, _b;\n        if (data[prop] == null &&\n            !(((_a = schema.required) === null || _a === void 0 ? void 0 : _a.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {\n            return;\n        }\n        const dependency = dependencies[prop];\n        // dependency array\n        if (Array.isArray(dependency)) {\n            updated = true;\n            resolvedSchema.required.push(...dependency);\n            return;\n        }\n        // dependency schema\n        if (isObject(dependency)) {\n            updated = true;\n            const dNode = node.next(dependency).resolveRef();\n            resolvedSchema = mergeSchema(resolvedSchema, dNode.schema);\n            return;\n        }\n    });\n    if (updated) {\n        resolvedSchema.required = uniqueItems(resolvedSchema.required);\n        return resolvedSchema;\n    }\n}\n/**\n * @draft 2019-09\n */\nexport const validateDependentRequired = (node, value) => {\n    const { draft, schema, pointer } = node;\n    const dependentRequired = schema.dependentRequired;\n    if (!isObject(dependentRequired)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        const dependencies = dependentRequired[property];\n        // @draft >= 6 boolean schema\n        if (dependencies === true) {\n            return;\n        }\n        if (dependencies === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        if (!Array.isArray(dependencies)) {\n            return;\n        }\n        for (let i = 0, l = dependencies.length; i < l; i += 1) {\n            if (value[dependencies[i]] === undefined) {\n                errors.push(draft.errors.missingDependencyError({ missingProperty: dependencies[i], pointer, schema, value }));\n            }\n        }\n    });\n    return errors;\n};\n/**\n * @draft 2019-09\n */\nexport const validateDependentSchemas = (node, value) => {\n    const { draft, schema, pointer } = node;\n    const dependentSchemas = schema.dependentSchemas;\n    if (!isObject(dependentSchemas)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        const dependencies = dependentSchemas[property];\n        // @draft >= 6 boolean schema\n        if (dependencies === true) {\n            return;\n        }\n        if (dependencies === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        if (!isObject(dependencies)) {\n            return;\n        }\n        draft.validate(node.next(dependencies), value).map(error => errors.push(error));\n    });\n    return errors;\n};\n/**\n * validate dependencies definition for given input data\n */\nexport const validateDependencies = (node, value) => {\n    const { draft, schema, pointer } = node;\n    // @draft >= 2019-09 dependentSchemas\n    const dependencies = schema.dependencies;\n    if (!isObject(dependencies)) {\n        return undefined;\n    }\n    const errors = [];\n    Object.keys(value).forEach((property) => {\n        if (dependencies[property] === undefined) {\n            return;\n        }\n        // @draft >= 6 boolean schema\n        if (dependencies[property] === true) {\n            return;\n        }\n        if (dependencies[property] === false) {\n            errors.push(draft.errors.missingDependencyError({ pointer, schema, value }));\n            return;\n        }\n        let dependencyErrors;\n        const type = getTypeOf(dependencies[property]);\n        const propertyValue = dependencies[property];\n        if (Array.isArray(propertyValue)) {\n            dependencyErrors = propertyValue\n                .filter((dependency) => value[dependency] === undefined)\n                .map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));\n        }\n        else if (type === \"object\") {\n            dependencyErrors = draft.validate(node.next(dependencies[property]), value);\n        }\n        else {\n            throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);\n        }\n        errors.push(...dependencyErrors);\n    });\n    return errors.length > 0 ? errors : undefined;\n};\n", "/**\n * @draft-04\n */\nimport { mergeSchema } from \"../mergeSchema\";\n/**\n * returns merged schema of all valid anyOf subschemas for the given input data.\n * Does not merge with rest input schema.\n *\n * @returns merged anyOf subschemas which are valid to the given input data.\n */\nexport function mergeValidAnyOfSchema(node, data) {\n    const { draft, schema } = node;\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return;\n    }\n    let resolvedSchema;\n    schema.anyOf.forEach((anySchema) => {\n        const anyNode = draft.resolveRef(node.next(anySchema));\n        if (draft.validate(anyNode, data).length === 0) {\n            resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anyNode.schema) : anyNode.schema;\n        }\n    });\n    if (resolvedSchema) {\n        return node.next(resolvedSchema);\n    }\n}\n/**\n * @unused this function is only exposed via draft and not used otherwise\n * @returns extended input schema with valid anyOf subschemas or JsonError if\n * no anyOf schema matches input data\n */\nexport function resolveAnyOf(node, data) {\n    const { anyOf } = node.schema;\n    if (!Array.isArray(anyOf) || anyOf.length === 0) {\n        return node;\n    }\n    const resolvedNode = mergeValidAnyOfSchema(node, data);\n    if (resolvedNode) {\n        const { pointer, schema } = node;\n        return node.draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });\n    }\n    return node.merge(resolvedNode.schema, \"anyOf\");\n}\n/**\n * validate anyOf definition for given input data\n */\nexport const validateAnyOf = (node, value) => {\n    const { draft, schema, pointer } = node;\n    if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {\n        return undefined;\n    }\n    // console.log(\"validate any of\", pointer, value);\n    for (let i = 0; i < schema.anyOf.length; i += 1) {\n        const nextNode = draft.resolveRef(node.next(schema.anyOf[i]));\n        if (draft.validate(nextNode, value).length === 0) {\n            return undefined;\n        }\n    }\n    return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });\n};\n", "import { isJsonError } from \"./types\";\nimport { isSchemaNode } from \"./schemaNode\";\nimport { mergeSchema } from \"./mergeSchema\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeAllOfSchema } from \"./features/allOf\";\nimport { mergeValidAnyOfSchema } from \"./features/anyOf\";\nimport { resolveOneOfFuzzy as resolveOneOf } from \"./features/oneOf\";\nimport { omit } from \"./utils/omit\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\nconst dynamicProperties = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\"];\nexport function isDynamicSchema(schema) {\n    const givenProps = Object.keys(schema);\n    return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;\n}\n/**\n * @note this utility does not reference draft methods for resolution\n * @todo consider using draft methods\n *\n * Resolves all dynamic schema definitions for the given input data and returns\n * the resulting json-schema without any dynamic schema definitions. The result\n * is not merged with the original input schema, thus static definitions of the\n * input schema are untouched and missing. For a full schema definition of this\n * input data you have to merge the result with the original schema\n * (@see reduceSchema)\n *\n * dynamic schema definitions: dependencies, allOf, anyOf, oneOf, if\n *\n * @returns static schema from resolved dynamic schema definitions for this\n *  specific input data\n */\nexport function resolveDynamicSchema(schemaNode, data) {\n    let resolvedSchema;\n    let error;\n    const node = schemaNode.draft.resolveRef(schemaNode);\n    const { draft } = node;\n    const schema = isSchemaNode(node) ? node.schema : node;\n    // @feature oneOf\n    if (schema.oneOf) {\n        const oneOfSchema = resolveOneOf(node, data);\n        if (isJsonError(oneOfSchema)) {\n            error = oneOfSchema;\n        }\n        else if (oneOfSchema) {\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema.schema);\n        }\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const allOf = schema.allOf.map((s) => {\n            // before merging allOf schema we need to resolve all subschemas\n            // if not, we would wrongly merge oneOf, if-then statements, etc\n            if (isDynamicSchema(s)) {\n                // copy of reduceSchema\n                const result = resolveDynamicSchema(node.next(s), data);\n                // note: result has no scope\n                if (result == null || isJsonError(result)) {\n                    return result;\n                }\n                const finalSchema = mergeSchema(s, result.schema);\n                return omit(finalSchema, ...toOmit);\n            }\n            return s;\n        });\n        if (allOf.length > 0) {\n            const allOfSchema = mergeAllOfSchema(draft, { allOf });\n            resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);\n        }\n    }\n    // @feature anyOf\n    const anyNode = mergeValidAnyOfSchema(node, data);\n    if (anyNode && anyNode.schema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyNode.schema);\n    }\n    // @feature dependencies\n    const dependenciesSchema = resolveDependencies(node, data);\n    if (dependenciesSchema) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);\n    }\n    // @feature if-then-else\n    const ifNodeResolved = resolveIfSchema(node, data);\n    if (isSchemaNode(ifNodeResolved)) {\n        resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifNodeResolved.schema);\n    }\n    if (resolvedSchema == null) {\n        return error;\n    }\n    if (isJsonError(resolvedSchema)) {\n        return resolvedSchema;\n    }\n    const nestedSchema = resolveDynamicSchema(node.next(resolvedSchema), data);\n    if (isSchemaNode(nestedSchema)) {\n        resolvedSchema = mergeSchema(resolvedSchema, nestedSchema.schema);\n    }\n    const finalSchema = omit(resolvedSchema, ...toOmit);\n    return node.next(finalSchema);\n}\n", "import { isSchemaNode } from \"./schemaNode\";\nimport { resolveDynamicSchema } from \"./resolveDynamicSchema\";\nconst toOmit = [\"allOf\", \"anyOf\", \"oneOf\", \"dependencies\", \"if\", \"then\", \"else\"];\n/**\n * reduces json schema by merging dynamic constructs like if-then-else,\n * dependencies, allOf, anyOf, oneOf, etc into a static json schema\n * omitting those properties.\n *\n * @returns input schema reduced by dynamic schema definitions for the given\n * input data\n */\nexport function reduceSchema(node, data) {\n    const resolvedSchema = resolveDynamicSchema(node, data);\n    if (isSchemaNode(resolvedSchema)) {\n        return node.merge(resolvedSchema.schema, ...toOmit);\n    }\n    if (resolvedSchema) {\n        return resolvedSchema; // error\n    }\n    return node;\n}\n", "export interface Cache {\n  has: (value: any) => boolean;\n  set: (key: any, value: any) => void;\n  get: (key: any) => any;\n}\n\nconst { toString: toStringFunction } = Function.prototype;\nconst { create } = Object;\nconst { toString: toStringObject } = Object.prototype;\n\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nclass LegacyCache {\n  private _keys: any[] = [];\n  private _values: any[] = [];\n\n  has(key: any) {\n    return !!~this._keys.indexOf(key);\n  }\n\n  get(key: any) {\n    return this._values[this._keys.indexOf(key)];\n  }\n\n  set(key: any, value: any) {\n    this._keys.push(key);\n    this._values.push(value);\n  }\n}\n\nfunction createCacheLegacy(): Cache {\n  return new LegacyCache();\n}\n\nfunction createCacheModern(): Cache {\n  return new WeakMap();\n}\n\n/**\n * Get a new cache object to prevent circular references.\n */\nexport const createCache =\n  typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;\n\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nexport function getCleanClone(prototype: any): any {\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === Object) {\n    return prototype === Object.prototype ? {} : create(prototype);\n  }\n\n  if (\n    Constructor &&\n    ~toStringFunction.call(Constructor).indexOf('[native code]')\n  ) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n}\n\nfunction getRegExpFlagsLegacy(regExp: RegExp): string {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n}\n\nfunction getRegExpFlagsModern(regExp: RegExp): string {\n  return regExp.flags;\n}\n\n/**\n * Get the flags to apply to the copied regexp.\n */\nexport const getRegExpFlags =\n  /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\n\nfunction getTagLegacy(value: any): string {\n  const type = toStringObject.call(value);\n\n  return type.substring(8, type.length - 1);\n}\n\nfunction getTagModern(value: any): string {\n  return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nexport const getTag =\n  typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;\n", "import { getCleanClone, getRegExpFlags } from './utils';\n\nimport type { Cache } from './utils';\n\nexport type InternalCopier<Value> = (value: Value, state: State) => Value;\n\nexport interface State {\n  Constructor: any;\n  cache: Cache;\n  copier: InternalCopier<any>;\n  prototype: any;\n}\n\nconst {\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';\n\nfunction getStrictPropertiesModern(object: any): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object)\n  );\n}\n\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nconst getStrictProperties = SUPPORTS_SYMBOL\n  ? getStrictPropertiesModern\n  : getOwnPropertyNames;\n\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict<Value>(\n  value: Value,\n  clone: Value,\n  state: State\n): Value {\n  const properties = getStrictProperties(value);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property === 'callee' || property === 'caller') {\n      continue;\n    }\n\n    descriptor = getOwnPropertyDescriptor(value, property);\n\n    if (!descriptor) {\n      // In extra edge cases where the property descriptor cannot be retrived, fall back to\n      // the loose assignment.\n      (clone as any)[property] = state.copier((value as any)[property], state);\n      continue;\n    }\n\n    // Only clone the value if actually a value, not a getter / setter.\n    if (!descriptor.get && !descriptor.set) {\n      descriptor.value = state.copier(descriptor.value, state);\n    }\n\n    try {\n      defineProperty(clone, property, descriptor);\n    } catch (error) {\n      // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n      (clone as any)[property] = descriptor.value;\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array.\n */\nexport function copyArrayLoose(array: any[], state: State) {\n  const clone = new state.Constructor();\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  for (let index = 0, length = array.length; index < length; ++index) {\n    clone[index] = state.copier(array[index], state);\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nexport function copyArrayStrict<Value extends any[]>(\n  array: Value,\n  state: State\n) {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  return copyOwnPropertiesStrict(array, clone, state);\n}\n\n/**\n * Copy the contents of the ArrayBuffer.\n */\nexport function copyArrayBuffer<Value extends ArrayBuffer>(\n  arrayBuffer: Value,\n  _state: State\n): Value {\n  return arrayBuffer.slice(0) as Value;\n}\n\n/**\n * Create a new Blob with the contents of the original.\n */\nexport function copyBlob<Value extends Blob>(\n  blob: Value,\n  _state: State\n): Value {\n  return blob.slice(0, blob.size, blob.type) as Value;\n}\n\n/**\n * Create a new DataView with the contents of the original.\n */\nexport function copyDataView<Value extends DataView>(\n  dataView: Value,\n  state: State\n): Value {\n  return new state.Constructor(copyArrayBuffer(dataView.buffer, state));\n}\n\n/**\n * Create a new Date based on the time of the original.\n */\nexport function copyDate<Value extends Date>(date: Value, state: State): Value {\n  return new state.Constructor(date.getTime());\n}\n\n/**\n * Deeply copy the keys and values of the original.\n */\nexport function copyMapLoose<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(map, clone);\n\n  map.forEach((value, key) => {\n    clone.set(key, state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nexport function copyMapStrict<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n) {\n  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n\nfunction copyObjectLooseLegacy<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone: any = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  return clone;\n}\n\nfunction copyObjectLooseModern<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  const symbols = getOwnPropertySymbols(object);\n\n  for (\n    let index = 0, length = symbols.length, symbol;\n    index < length;\n    ++index\n  ) {\n    symbol = symbols[index];\n\n    if (propertyIsEnumerable.call(object, symbol)) {\n      clone[symbol] = state.copier((object as any)[symbol], state);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nexport const copyObjectLoose = SUPPORTS_SYMBOL\n  ? copyObjectLooseModern\n  : copyObjectLooseLegacy;\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nexport function copyObjectStrict<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  return copyOwnPropertiesStrict(object, clone, state);\n}\n\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nexport function copyPrimitiveWrapper<\n  // Specifically use the object constructor types\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Value extends Boolean | Number | String\n>(primitiveObject: Value, state: State): Value {\n  return new state.Constructor(primitiveObject.valueOf());\n}\n\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nexport function copyRegExp<Value extends RegExp>(\n  regExp: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor(\n    regExp.source,\n    getRegExpFlags(regExp)\n  ) as Value;\n\n  clone.lastIndex = regExp.lastIndex;\n\n  return clone;\n}\n\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nexport function copySelf<Value>(value: Value, _state: State): Value {\n  return value;\n}\n\n/**\n * Deeply copy the values of the original.\n */\nexport function copySetLoose<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(set, clone);\n\n  set.forEach((value) => {\n    clone.add(state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nexport function copySetStrict<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n", "import {\n  copyArrayBuffer,\n  copyArrayLoose,\n  copyArrayStrict,\n  copyBlob,\n  copyDataView,\n  copyDate,\n  copyMapLoose,\n  copyMapStrict,\n  copyObjectLoose,\n  copyObjectStrict,\n  copyPrimitiveWrapper,\n  copyRegExp,\n  copySelf,\n  copySetLoose,\n  copySetStrict,\n} from './copier';\nimport { createCache, getTag } from './utils';\n\nimport type { InternalCopier, State } from './copier';\n\nexport type { State } from './copier';\n\nconst { isArray } = Array;\nconst { assign } = Object;\nconst getPrototypeOf = Object.getPrototypeOf || ((obj) => obj.__proto__)\n\nexport interface CreateCopierOptions {\n  array?: InternalCopier<any[]>;\n  arrayBuffer?: InternalCopier<ArrayBuffer>;\n  blob?: InternalCopier<Blob>;\n  dataView?: InternalCopier<DataView>;\n  date?: InternalCopier<Date>;\n  error?: InternalCopier<any>;\n  map?: InternalCopier<Map<any, any>>;\n  object?: InternalCopier<Record<string, any>>;\n  regExp?: InternalCopier<RegExp>;\n  set?: InternalCopier<Set<any>>;\n}\n\nconst DEFAULT_LOOSE_OPTIONS: Required<CreateCopierOptions> = {\n  array: copyArrayLoose,\n  arrayBuffer: copyArrayBuffer,\n  blob: copyBlob,\n  dataView: copyDataView,\n  date: copyDate,\n  error: copySelf,\n  map: copyMapLoose,\n  object: copyObjectLoose,\n  regExp: copyRegExp,\n  set: copySetLoose,\n};\nconst DEFAULT_STRICT_OPTIONS: Required<CreateCopierOptions> = assign(\n  {},\n  DEFAULT_LOOSE_OPTIONS,\n  {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n  }\n);\n\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(\n  options: Required<CreateCopierOptions>\n): Record<string, InternalCopier<any>> {\n  return {\n    Arguments: options.object,\n    Array: options.array,\n    ArrayBuffer: options.arrayBuffer,\n    Blob: options.blob,\n    Boolean: copyPrimitiveWrapper,\n    DataView: options.dataView,\n    Date: options.date,\n    Error: options.error,\n    Float32Array: options.arrayBuffer,\n    Float64Array: options.arrayBuffer,\n    Int8Array: options.arrayBuffer,\n    Int16Array: options.arrayBuffer,\n    Int32Array: options.arrayBuffer,\n    Map: options.map,\n    Number: copyPrimitiveWrapper,\n    Object: options.object,\n    Promise: copySelf,\n    RegExp: options.regExp,\n    Set: options.set,\n    String: copyPrimitiveWrapper,\n    WeakMap: copySelf,\n    WeakSet: copySelf,\n    Uint8Array: options.arrayBuffer,\n    Uint8ClampedArray: options.arrayBuffer,\n    Uint16Array: options.arrayBuffer,\n    Uint32Array: options.arrayBuffer,\n    Uint64Array: options.arrayBuffer,\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nexport function createCopier(options: CreateCopierOptions) {\n  const normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);\n  const tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n  const { Array: array, Object: object } = tagSpecificCopiers;\n\n  function copier(value: any, state: State): any {\n    state.prototype = state.Constructor = undefined;\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (state.cache.has(value)) {\n      return state.cache.get(value);\n    }\n\n    state.prototype = getPrototypeOf(value);\n    state.Constructor = state.prototype && state.prototype.constructor;\n\n    // plain objects\n    if (!state.Constructor || state.Constructor === Object) {\n      return object(value, state);\n    }\n\n    // arrays\n    if (isArray(value)) {\n      return array(value, state);\n    }\n\n    const tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n\n    if (tagSpecificCopier) {\n      return tagSpecificCopier(value, state);\n    }\n\n    return typeof value.then === 'function' ? value : object(value, state);\n  }\n\n  return function copy<Value>(value: Value): Value {\n    return copier(value, {\n      Constructor: undefined,\n      cache: createCache(),\n      copier,\n      prototype: undefined,\n    });\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nexport function createStrictCopier(options: CreateCopierOptions) {\n  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nexport const copyStrict = createStrictCopier({});\n\n/**\n * Copy an value deeply as much as possible.\n */\nexport default createCopier({});\n", "import copy from \"fast-copy\";\nexport default copy;\n", "import copy from \"../utils/copy\";\nimport { isJsonError } from \"../types\";\nimport { isSchemaNode } from \"../schemaNode\";\nexport class Draft {\n    constructor(config, schema) {\n        /** cache for remote schemas */\n        this.remotes = {};\n        /** error creators by id */\n        this.errors = {};\n        /** map for valid keywords of a type  */\n        this.typeKeywords = {};\n        /** keyword validators  */\n        this.validateKeyword = {};\n        /** type validators  */\n        this.validateType = {};\n        /** format validators  */\n        this.validateFormat = {};\n        this.config = config;\n        this.typeKeywords = copy(config.typeKeywords);\n        this.validateKeyword = Object.assign({}, config.validateKeyword);\n        this.validateType = Object.assign({}, config.validateType);\n        this.validateFormat = Object.assign({}, config.validateFormat);\n        this.errors = Object.assign({}, config.errors);\n        this.setSchema(schema);\n    }\n    get rootSchema() {\n        return this.__rootSchema;\n    }\n    set rootSchema(rootSchema) {\n        if (rootSchema == null) {\n            return;\n        }\n        this.__rootSchema = this.config.compileSchema(this, rootSchema);\n    }\n    /**\n     * register a json-schema to be referenced from another json-schema\n     * @param url - base-url of json-schema (aka id)\n     * @param schema - json-schema root\n     */\n    addRemoteSchema(url, schema) {\n        this.config.addRemoteSchema(this, url, schema);\n    }\n    compileSchema(schema) {\n        var _a;\n        return this.config.compileSchema(this, schema, (_a = this.rootSchema) !== null && _a !== void 0 ? _a : schema);\n    }\n    createSchemaOf(data) {\n        return this.config.createSchemaOf(data);\n    }\n    /**\n     * Iterates over data, retrieving its schema\n     *\n     * @param data - the data to iterate\n     * @param callback - will be called with (schema, data, pointer) on each item\n     * @param [schema] - the schema matching the data. Defaults to rootSchema\n     * @param [pointer] - pointer to current data. Default to rootPointer\n     */\n    each(data, callback, schema, pointer) {\n        const node = this.createNode(schema !== null && schema !== void 0 ? schema : this.rootSchema, pointer);\n        return this.config.each(node, data, callback);\n    }\n    eachSchema(callback, schema = this.rootSchema) {\n        return this.config.eachSchema(schema, callback);\n    }\n    getChildSchemaSelection(property, schema) {\n        return this.config.getChildSchemaSelection(this, property, schema);\n    }\n    /**\n     * Returns the json-schema of a data-json-pointer.\n     *\n     * To resolve dynamic schema where the type of json-schema is evaluated by\n     * its value, a data object has to be passed in options.\n     *\n     * Per default this function will return `undefined` for valid properties that\n     * do not have a defined schema. Use the option `withSchemaWarning: true` to\n     * receive an error with `code: schema-warning` containing the location of its\n     * last evaluated json-schema.\n     *\n     * Notes\n     *      - uses draft.step to walk through data and schema\n     *\n     * @param draft\n     * @param pointer - json pointer in data to get the json schema for\n     * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n     *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n     * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n     * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n     * @return resolved json-schema object of requested json-pointer location\n     */\n    getSchema(options) {\n        const result = this.getSchemaNode(options);\n        if (isSchemaNode(result)) {\n            return result.schema;\n        }\n        return result;\n    }\n    getSchemaNode(options) {\n        return this.config.getSchema(this, options);\n    }\n    /**\n     * Create data object matching the given schema\n     *\n     * @param [data] - optional template data\n     * @param [schema] - json schema, defaults to rootSchema\n     * @return created template data\n     */\n    getTemplate(data, schema, opts = this.config.templateDefaultOptions) {\n        return this.config.getTemplate(this, data, schema, opts);\n    }\n    isValid(data, schema, pointer) {\n        return this.config.isValid(this, data, schema, pointer);\n    }\n    createNode(schema, pointer = \"#\") {\n        return this.config.createNode(this, schema, pointer);\n    }\n    resolveAnyOf(node, data) {\n        return this.config.resolveAnyOf(node, data);\n    }\n    resolveAllOf(node, data) {\n        return this.config.resolveAllOf(node, data);\n    }\n    resolveRef(node) {\n        return this.config.resolveRef(node);\n    }\n    resolveOneOf(node, data) {\n        return this.config.resolveOneOf(node, data);\n    }\n    setSchema(schema) {\n        this.rootSchema = schema;\n    }\n    /**\n     * Returns the json-schema of the given object property or array item.\n     * e.g. it steps by one key into the data\n     *\n     * This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n     * returns the correct schema.\n     *\n     * @param  node\n     * @param  key       - property-name or array-index\n     * @param  data      - parent of key\n     * @return schema-node containing child schema or error if failed resolving key\n     */\n    step(node, key, data) {\n        return this.config.step(node, key, data);\n    }\n    validate(data, schema = this.rootSchema, pointer) {\n        if (isSchemaNode(data)) {\n            const inputData = schema;\n            const inuptNode = data;\n            return this.config.validate(inuptNode, inputData);\n        }\n        if (isJsonError(data)) {\n            return [data];\n        }\n        const node = this.createNode(schema, pointer);\n        return this.config.validate(node, data);\n    }\n}\n", "/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft, url, schema) {\n    schema.id = schema.id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n", "import { isObject } from \"./utils/isObject\";\nfunction eachProperty(property, schema, callback, pointer) {\n    const target = schema[property];\n    if (!isObject(target)) {\n        return;\n    }\n    Object.keys(target).forEach(key => {\n        if (Array.isArray(target[key])) {\n            // ignore depndencies list (of properties)\n            return;\n        }\n        if (key === \"$defs\") {\n            eachProperty(\"$defs\", target[key], callback, `${pointer}/${property}/$defs`);\n        }\n        else {\n            eachSchema(target[key], callback, `${pointer}/${property}/${key}`);\n        }\n    });\n}\nfunction eachItem(property, schema, callback, pointer) {\n    const target = schema[property];\n    if (!Array.isArray(target)) {\n        return;\n    }\n    target.forEach((s, key) => eachSchema(s, callback, `${pointer}/${property}/${key}`));\n}\nexport function eachSchema(schema, callback, pointer = \"\") {\n    if (schema === undefined) {\n        return;\n    }\n    // @ts-expect-error untyped\n    if (callback(schema, pointer) === true) {\n        return;\n    }\n    if (!isObject(schema)) {\n        return;\n    }\n    eachProperty(\"properties\", schema, callback, pointer);\n    eachProperty(\"patternProperties\", schema, callback, pointer);\n    eachSchema(schema.not, callback, `${pointer}/not`);\n    eachSchema(schema.additionalProperties, callback, `${pointer}/additionalProperties`);\n    eachProperty(\"dependencies\", schema, callback, pointer);\n    // items\n    isObject(schema.items) && eachSchema(schema.items, callback, `${pointer}/items`);\n    eachItem(\"items\", schema, callback, pointer);\n    // additional items\n    eachSchema(schema.additionalItems, callback, `${pointer}/additionalItems`);\n    // dynamic schemas\n    eachItem(\"allOf\", schema, callback, pointer);\n    eachItem(\"anyOf\", schema, callback, pointer);\n    eachItem(\"oneOf\", schema, callback, pointer);\n    eachSchema(schema.if, callback, `${pointer}/if`);\n    eachSchema(schema.then, callback, `${pointer}/then`);\n    eachSchema(schema.else, callback, `${pointer}/else`);\n    // definitions\n    eachProperty(\"definitions\", schema, callback, pointer);\n    eachProperty(\"$defs\", schema, callback, pointer);\n}\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nconst suffixes = /(#)+$/;\nconst trailingHash = /#$/;\nconst startingHashAndSlash = /^[#/]+/;\nconst isDomain = /^[^:]+:\\/\\/[^/]+\\//;\nconst trailingFragments = /\\/[^/]*$/;\nconst idAndPointer = /#.*$/;\n// @todo add missing test for urn ids\nconst isURN = /^urn:uuid:[0-9A-Fa-f]/;\nexport default function joinScope(previous, id) {\n    if (previous == null && id == null) {\n        return \"#\";\n    }\n    if (id == null) {\n        return previous.replace(trailingHash, \"\");\n    }\n    if (isURN.test(id)) {\n        return id;\n    }\n    if (previous == null || previous === \"\" || previous === \"#\") {\n        return id.replace(trailingHash, \"\");\n    }\n    if (id[0] === \"#\") {\n        return `${previous.replace(idAndPointer, \"\")}${id.replace(suffixes, \"\")}`;\n    }\n    if (isDomain.test(id)) {\n        return id.replace(trailingHash, \"\");\n    }\n    if (isDomain.test(previous) && id.startsWith(\"/\")) {\n        // we have a domain that should be joined with an absolute path\n        // thus we have to remove all paths from domain before joining\n        return `${previous.replace(/(^[^:]+:\\/\\/[^/]+)(.*)/, \"$1\")}/${id.replace(startingHashAndSlash, \"\")}`;\n    }\n    return `${previous.replace(trailingFragments, \"\")}/${id.replace(startingHashAndSlash, \"\")}`;\n}\n", "import { get } from \"@sagold/json-pointer\";\nimport splitRef from \"./splitRef\";\nimport getTypeOf from \"../getTypeOf\";\nconst suffixes = /(#)+$/g;\nconst isObject = (val) => getTypeOf(val) === \"object\";\n// 1. combined is known\n// 2. base or pointer is known\n// 3. base + pointer is known\nexport default function getRef(context, rootSchema, $search) {\n    var _a, _b, _c, _d, _e;\n    let $ref;\n    if (isObject($search)) {\n        $ref = $search.__ref || $search.$ref;\n    }\n    else {\n        $ref = $search;\n    }\n    if ($ref == null) {\n        return rootSchema;\n    }\n    // console.log(\"\\n$ref\", $ref);\n    let schema;\n    // is it a known $ref?\n    const $remote = $ref.replace(suffixes, \"\");\n    if (context.remotes[$remote] != null) {\n        schema = context.remotes[$remote];\n        // console.log(\"» remote\");\n        if (schema && schema.$ref) {\n            // console.log(\"»» reresolve\", schema);\n            // @todo add missing test for the following line\n            return getRef(context, schema, schema);\n        }\n        // console.log(\"»» return\", schema);\n        return schema;\n    }\n    // @ts-expect-error @draft 2019-09\n    const $anchor = (_a = context.anchors) === null || _a === void 0 ? void 0 : _a[$ref];\n    if ($anchor) {\n        // console.log(\"» anchor\", $anchor);\n        return get(rootSchema, $anchor);\n    }\n    if (context.ids[$ref] != null) {\n        // console.log(\"» id\", context.ids[$ref]);\n        schema = get(rootSchema, context.ids[$ref]);\n        if (schema && schema.$ref) {\n            // @todo add missing test for the following line\n            return getRef(context, rootSchema, schema);\n        }\n        return schema;\n    }\n    const $inputRef = $ref;\n    // is it a ref with host/pointer?\n    const fragments = splitRef($ref);\n    if (fragments.length === 0) {\n        return rootSchema;\n    }\n    if (fragments.length === 1) {\n        // console.log(\"» frag1\", fragments);\n        // console.log(\"ids\", rootSchema.getContext().ids);\n        $ref = fragments[0];\n        if (context.remotes[$ref]) {\n            // console.log(\"» remote\");\n            schema = context.remotes[$ref];\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema);\n            }\n        }\n        if (context.ids[$ref]) {\n            // console.log(\"» id\");\n            schema = get(rootSchema, context.ids[$ref]);\n            if (schema && schema.$ref) {\n                return getRef(context, rootSchema, schema);\n            }\n            return schema;\n        }\n        // @todo why this special case\n        const rootContextRef = (_b = rootSchema.getContext) === null || _b === void 0 ? void 0 : _b.call(rootSchema).ids[$ref];\n        if (rootContextRef) {\n            return getRef(context, rootSchema, rootContextRef);\n        }\n    }\n    if (fragments.length === 2) {\n        // console.log(\"» frag2\", fragments);\n        const base = fragments[0];\n        $ref = fragments[1];\n        // @todo this is unnecessary due to inconsistencies\n        const fromRemote = (_c = context.remotes[base]) !== null && _c !== void 0 ? _c : context.remotes[`${base}/`];\n        if (fromRemote) {\n            // console.log(\"» remote\");\n            // We have retrieved a different compiled json-schema. This compiled schema contains a\n            // separate scope (context) where we might need to work with\n            // ANCHOR\n            if (fromRemote.getContext && fromRemote.getContext().anchors[$inputRef] != null) {\n                // console.log(\"» remote » anchor\");\n                // an anchor is stored with its scope (id) it is defined in. Thus collisions are\n                // avoided, but the current condition is required to resolve the anchor for now\n                return fromRemote.getRef($inputRef);\n            }\n            // PATH (get_ref)\n            if (fromRemote.getRef) {\n                // console.log(\"» remote » ref\");\n                // resolve the local part of the reference in the new schema\n                return fromRemote.getRef($ref);\n            }\n            //log(\"warning: uncompiled remote - context may be wrong\", base);\n            return getRef(context, fromRemote, $ref);\n        }\n        // @todo this is unnecessary due to inconsistencies\n        const fromId = (_d = context.ids[base]) !== null && _d !== void 0 ? _d : context.ids[`${base}/`];\n        if (fromId) {\n            // console.log(\"» id\", fromId);\n            return getRef(context, get(rootSchema, fromId), $ref);\n        }\n    }\n    // console.log(\"» other\");\n    schema = get(rootSchema, (_e = context.ids[$ref]) !== null && _e !== void 0 ? _e : $ref);\n    if (schema && schema.$ref) {\n        return getRef(context, rootSchema, schema);\n    }\n    return schema;\n}\n", "const suffixes = /(#)+$/g;\nconst emptyValues = [\"\", null, \"#\"];\nexport default function splitRef($ref) {\n    if (emptyValues.includes($ref)) {\n        return [];\n    }\n    $ref = $ref.replace(suffixes, \"\");\n    if ($ref.indexOf(\"#\") === -1) {\n        return [$ref.replace(/(#|\\/)+$/g, \"\")];\n    }\n    if ($ref.indexOf(\"#\") === 0) {\n        return [$ref.replace(suffixes, \"\")];\n    }\n    const result = $ref.split(\"#\");\n    result[0] = result[0].replace(/(#|\\/)+$/g, \"\");\n    result[1] = `#${result[1].replace(suffixes, \"\")}`;\n    return result;\n}\n", "/* eslint max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { eachSchema } from \"../eachSchema\";\nimport joinScope from \"./joinScope\";\nimport getRef from \"./getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * compiles the input root schema for `$ref` resolution and returns it again\n * @attention this modifies input schema but maintains data-structure and thus returns\n * the same object with JSON.stringify\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param draft\n * @param schemaToCompile - json-schema to compile\n * @param [rootSchema] - compiled root json-schema to use for definitions resolution\n * @param [force] = false - force compile json-schema\n * @return compiled input json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    if (!schemaToCompile || schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    }\n    const context = { ids: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperties(compiledSchema, {\n        // flag this schema as compiled\n        [COMPILED]: { enumerable: false, value: true },\n        // add getRef-helper to this object\n        [GET_REF]: {\n            enumerable: false,\n            value: getRef.bind(null, context, compiledSchema)\n        }\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (schemaToCompile !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"definitions\", {\n            enumerable: false,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.id.startsWith(\"http\") && /(allOf|anyOf|oneOf)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.id = (_a = parentSchema.id) !== null && _a !== void 0 ? _a : schema.id;\n            }\n            context.ids[schema.id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.id);\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            // @todo currently not used:\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n            // console.log(\"compiled ref\", scope, schema.$ref, \"=>\", joinScope(scope, schema.$ref));\n        }\n    });\n    // console.log(JSON.stringify(context.ids, null, 2));\n    return compiledSchema;\n}\n", "import getTypeOf from \"./getTypeOf\";\nimport { isObject } from \"./utils/isObject\";\n/**\n * Create a simple json schema for the given input data\n * @param  data - data to get json schema for\n */\nexport default function createSchemaOf(data) {\n    if (data === undefined) {\n        return undefined;\n    }\n    const schema = {\n        type: getTypeOf(data)\n    };\n    if (schema.type === \"object\" && isObject(data)) {\n        schema.properties = {};\n        Object.keys(data).forEach((key) => (schema.properties[key] = createSchemaOf(data[key])));\n    }\n    if (schema.type === \"array\" && Array.isArray(data)) {\n        if (data.length === 1) {\n            schema.items = createSchemaOf(data[0]);\n        }\n        else {\n            schema.items = data.map(createSchemaOf);\n        }\n    }\n    return schema;\n}\n", "/* eslint no-invalid-this: 0 */\nimport { createCustomError } from \"../utils/createCustomError\";\nconst errors = {\n    additionalItemsError: createCustomError(\"AdditionalItemsError\"),\n    additionalPropertiesError: createCustomError(\"AdditionalPropertiesError\"),\n    allOfError: createCustomError(\"AllOfError\"),\n    anyOfError: createCustomError(\"AnyOfError\"),\n    constError: createCustomError(\"ConstError\"),\n    containsAnyError: createCustomError(\"ContainsAnyError\"),\n    containsArrayError: createCustomError(\"ContainsArrayError\"),\n    containsError: createCustomError(\"ContainsError\"),\n    containsMaxError: createCustomError(\"ContainsMaxError\"),\n    containsMinError: createCustomError(\"ContainsMinError\"),\n    enumError: createCustomError(\"EnumError\"),\n    forbiddenPropertyError: createCustomError(\"ForbiddenPropertyError\"),\n    formatDateError: createCustomError(\"FormatDateError\"),\n    formatDateTimeError: createCustomError(\"FormatDateTimeError\"),\n    formatDurationError: createCustomError(\"FormatDurationError\"),\n    formatEmailError: createCustomError(\"FormatEmailError\"),\n    formatHostnameError: createCustomError(\"FormatHostnameError\"),\n    formatIPV4Error: createCustomError(\"FormatIPV4Error\"),\n    formatIPV4LeadingZeroError: createCustomError(\"FormatIPV4LeadingZeroError\"),\n    formatIPV6Error: createCustomError(\"FormatIPV6Error\"),\n    formatIPV6LeadingZeroError: createCustomError(\"FormatIPV6LeadingZeroError\"),\n    formatJsonPointerError: createCustomError(\"FormatJsonPointerError\"),\n    formatRegExError: createCustomError(\"FormatRegExError\"),\n    formatTimeError: createCustomError(\"FormatTimeError\"),\n    formatURIError: createCustomError(\"FormatURIError\"),\n    formatURIReferenceError: createCustomError(\"FormatURIReferenceError\"),\n    formatURITemplateError: createCustomError(\"FormatURITemplateError\"),\n    formatURLError: createCustomError(\"FormatURLError\"),\n    formatUUIDError: createCustomError(\"FormatUUIDError\"),\n    invalidDataError: createCustomError(\"InvalidDataError\"),\n    invalidPropertyNameError: createCustomError(\"InvalidPropertyNameError\"),\n    invalidSchemaError: createCustomError(\"InvalidSchemaError\"),\n    invalidTypeError: createCustomError(\"InvalidTypeError\"),\n    maximumError: createCustomError(\"MaximumError\"),\n    maxItemsError: createCustomError(\"MaxItemsError\"),\n    maxLengthError: createCustomError(\"MaxLengthError\"),\n    maxPropertiesError: createCustomError(\"MaxPropertiesError\"),\n    minimumError: createCustomError(\"MinimumError\"),\n    minItemsError: createCustomError(\"MinItemsError\"),\n    minItemsOneError: createCustomError(\"MinItemsOneError\"),\n    minLengthError: createCustomError(\"MinLengthError\"),\n    minLengthOneError: createCustomError(\"MinLengthOneError\"),\n    minPropertiesError: createCustomError(\"MinPropertiesError\"),\n    missingDependencyError: createCustomError(\"MissingDependencyError\"),\n    missingOneOfPropertyError: createCustomError(\"MissingOneOfPropertyError\"),\n    multipleOfError: createCustomError(\"MultipleOfError\"),\n    multipleOneOfError: createCustomError(\"MultipleOneOfError\"),\n    noAdditionalPropertiesError: createCustomError(\"NoAdditionalPropertiesError\"),\n    notError: createCustomError(\"NotError\"),\n    oneOfError: createCustomError(\"OneOfError\"),\n    oneOfPropertyError: createCustomError(\"OneOfPropertyError\"),\n    patternError: createCustomError(\"PatternError\"),\n    patternPropertiesError: createCustomError(\"PatternPropertiesError\"),\n    requiredPropertyError: createCustomError(\"RequiredPropertyError\"),\n    schemaWarning: createCustomError(\"SchemaWarning\"),\n    typeError: createCustomError(\"TypeError\"),\n    undefinedValueError: createCustomError(\"UndefinedValueError\"),\n    unevaluatedItemsError: createCustomError(\"UnevaluatedItemsError\"),\n    unevaluatedPropertyError: createCustomError(\"UnevaluatedPropertyError\"),\n    uniqueItemsError: createCustomError(\"UniqueItemsError\"),\n    unknownPropertyError: createCustomError(\"UnknownPropertyError\"),\n    valueNotEmptyError: createCustomError(\"ValueNotEmptyError\")\n};\nexport default errors;\n", "import validUrl from \"valid-url\";\nimport { parse as parseIdnEmail } from \"smtp-address-parser\";\nimport getTypeOf from \"../getTypeOf\";\nconst isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nconst isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i;\nconst isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\\.?$/;\nconst matchDate = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/;\nconst matchTime = /^(?<time>(?:([0-1]\\d|2[0-3]):[0-5]\\d:(?<second>[0-5]\\d|60)))(?:\\.\\d+)?(?<offset>(?:z|[+-]([0-1]\\d|2[0-3])(?::?[0-5]\\d)?))$/i;\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst isValidJsonPointer = /^(?:\\/(?:[^~/]|~0|~1)*)*$/;\nconst isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/;\nconst isValidURIRef = /^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;\n// uri-template: https://tools.ietf.org/html/rfc6570\nconst isValidURITemplate = /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i;\nconst isValidDurationString = /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/;\n// Default Json-Schema formats: date-time, email, hostname, ipv4, ipv6, uri, uriref\nconst formatValidators = {\n    date: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        // full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n        const matches = value.match(matchDate);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        const year = +matches[1];\n        const month = +matches[2];\n        const day = +matches[3];\n        // https://tools.ietf.org/html/rfc3339#appendix-C\n        const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        if (month >= 1 &&\n            month <= 12 &&\n            day >= 1 &&\n            day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {\n            return undefined;\n        }\n        return draft.errors.formatDateError({ value, pointer, schema });\n    },\n    \"date-time\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        const dateAndTime = value.split(/t/i);\n        if (dateAndTime.length === 2) {\n            const dateIsValid = formatValidators.date(node, dateAndTime[0]) === undefined;\n            const timeIsValid = formatValidators.time(node, dateAndTime[1]) === undefined;\n            if (dateIsValid && timeIsValid) {\n                return undefined;\n            }\n        }\n        return draft.errors.formatDateTimeError({ value, pointer, schema });\n    },\n    duration: (node, value) => {\n        const type = getTypeOf(value);\n        if (type !== \"string\") {\n            return undefined;\n        }\n        // weeks cannot be combined with other units\n        const isInvalidDurationString = /(\\d+M)(\\d+W)|(\\d+Y)(\\d+W)/;\n        if (!isValidDurationString.test(value) ||\n            isInvalidDurationString.test(value)) {\n            return node.draft.errors.formatDurationError({\n                value,\n                pointer: node.pointer,\n                schema: node.schema\n            });\n        }\n    },\n    email: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // taken from https://github.com/ExodusMovement/schemasafe/blob/master/src/formats.js\n        if (value[0] === '\"') {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        const [name, host, ...rest] = value.split(\"@\");\n        if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (name[0] === \".\" || name.endsWith(\".\") || name.includes(\"..\")) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        if (!host.split(\".\").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    /**\n     * @draft 7\n     * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531\n     */\n    \"idn-email\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        try {\n            parseIdnEmail(value);\n            return undefined;\n        }\n        catch (e) {\n            return draft.errors.formatEmailError({ value, pointer, schema });\n        }\n    },\n    hostname: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (value === \"\" || isValidHostname.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatHostnameError({ value, pointer, schema });\n    },\n    ipv4: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 15 && isValidIPV4.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV4Error({ value, pointer, schema });\n    },\n    ipv6: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (value && value[0] === \"0\") {\n            // leading zeroes should be rejected, as they are treated as octals\n            return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });\n        }\n        if (value.length <= 45 && isValidIPV6.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatIPV6Error({ value, pointer, schema });\n    },\n    \"json-pointer\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    \"relative-json-pointer\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\") {\n            return undefined;\n        }\n        if (isValidRelativeJsonPointer.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatJsonPointerError({ value, pointer, schema });\n    },\n    regex: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value === \"string\" && /\\\\Z$/.test(value) === false) {\n            try {\n                new RegExp(value);\n                return undefined;\n            }\n            catch (e) { } // eslint-disable-line no-empty\n            return draft.errors.formatRegExError({ value, pointer, schema });\n        }\n        // v7 tests, ignore non-regex values\n        if (typeof value === \"object\" || typeof value === \"number\" || Array.isArray(value)) {\n            return undefined;\n        }\n        return draft.errors.formatRegExError({ value, pointer, schema });\n    },\n    // hh:mm:ss.sTZD\n    // RFC 3339 https://datatracker.ietf.org/doc/html/rfc3339#section-4\n    time: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        // https://github.com/cfworker/cfworker/blob/main/packages/json-schema/src/format.ts\n        const matches = value.match(matchTime);\n        if (!matches) {\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        // leap second\n        if (matches.groups.second === \"60\") {\n            // bail early\n            if (/23:59:60(z|\\+00:00)/i.test(value)) {\n                return undefined;\n            }\n            // check if sum matches 23:59\n            const minutes = matches.groups.time.match(/(\\d+):(\\d+):/);\n            const offsetMinutes = matches.groups.offset.match(/(\\d+):(\\d+)/);\n            if (offsetMinutes) {\n                const hour = parseInt(minutes[1]);\n                const offsetHour = parseInt(offsetMinutes[1]);\n                const min = parseInt(minutes[2]);\n                const offsetMin = parseInt(offsetMinutes[2]);\n                let deltaTime;\n                if (/^-/.test(matches.groups.offset)) {\n                    deltaTime = (hour + offsetHour) * 60 + (min + offsetMin);\n                }\n                else {\n                    deltaTime = (24 + hour - offsetHour) * 60 + (min - offsetMin);\n                }\n                const hours = Math.floor(deltaTime / 60);\n                const actualHour = hours % 24;\n                const actualMinutes = deltaTime - hours * 60;\n                if (actualHour === 23 && actualMinutes === 59) {\n                    return undefined;\n                }\n            }\n            return draft.errors.formatDateTimeError({ value, pointer, schema });\n        }\n        return undefined;\n    },\n    uri: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (validUrl.isUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIError({ value, pointer, schema });\n    },\n    \"uri-reference\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURIRef.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURIReferenceError({ value, pointer, schema });\n    },\n    \"uri-template\": (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (isValidURITemplate.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURITemplateError({ value, pointer, schema });\n    },\n    url: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (value === \"\" || validUrl.isWebUri(value)) {\n            return undefined;\n        }\n        return draft.errors.formatURLError({ value, pointer, schema });\n    },\n    uuid: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (typeof value !== \"string\" || value === \"\") {\n            return undefined;\n        }\n        if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {\n            return undefined;\n        }\n        return draft.errors.formatUUIDError({ value, pointer, schema });\n    }\n};\nexport default formatValidators;\n", "import { isJsonError } from \"./types\";\n/**\n * Returns a list of possible child-schemas for the given property key. In case of a oneOf selection, multiple schemas\n * could be added at the given property (e.g. item-index), thus an array of options is returned. In all other cases\n * a list with a single item will be returned\n *\n * @param draft        - draft to use\n * @param property    - parent schema of following property\n * @param [schema]    - parent schema of following property\n * @return\n */\nexport default function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {\n    var _a;\n    if (schema.oneOf) {\n        return schema.oneOf.map((item) => draft.createNode(item).resolveRef().schema);\n    }\n    if ((_a = schema.items) === null || _a === void 0 ? void 0 : _a.oneOf) {\n        return schema.items.oneOf.map((item) => draft.createNode(item).resolveRef().schema);\n    }\n    const node = draft.step(draft.createNode(schema), property, {});\n    if (isJsonError(node)) {\n        return node;\n    }\n    return [node.schema];\n}\n", "import gp from \"@sagold/json-pointer\";\nimport { isJsonError } from \"./types\";\nconst emptyObject = {};\n/**\n * Returns a node containing json-schema of a data-json-pointer.\n *\n * To resolve dynamic schema where the type of json-schema is evaluated by\n * its value, a data object has to be passed in options.\n *\n * Per default this function will return `undefined` schema for valid properties\n * that do not have a defined schema. Use the option `withSchemaWarning: true` to\n * receive an error with `code: schema-warning` containing the location of its\n * last evaluated json-schema.\n *\n * Example:\n *\n * ```ts\n * draft.setSchema({ type: \"object\", properties: { title: { type: \"string\" } } });\n * const result = draft.getSchema({  pointer: \"#/title\" }, data: { title: \"my header\" });\n * const schema = isSchemaNode(result) ? result.schema : undefined;\n * // schema = { type: \"string\" }\n * ```\n *\n * @param draft\n * @param [options.pointer] - json pointer in data to get the json schema for\n * @param [options.data] - the data object, which includes the json pointers value. This is optional, as\n *    long as no oneOf, anyOf, etc statement is part of the pointers schema\n * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema\n * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition\n * @return json-error or node containing schema of requested json-pointer location\n */\nexport default function getSchema(draft, options = emptyObject) {\n    const { pointer = \"#\", data, schema = draft.rootSchema, withSchemaWarning = false } = options;\n    const path = gp.split(pointer);\n    const node = draft.createNode(schema).resolveRef();\n    const result = _getSchema(node, path, data);\n    if (!withSchemaWarning && isJsonError(result) && result.code === \"schema-warning\") {\n        return draft.createNode(undefined);\n    }\n    return result;\n}\nfunction _getSchema(node, path, data = emptyObject) {\n    if (path.length === 0) {\n        return node.resolveRef();\n    }\n    const key = path.shift(); // step key\n    const nextNode = node.draft.step(node, key, data); // step schema\n    if (isJsonError(nextNode)) {\n        return nextNode;\n    }\n    // @ts-expect-error data\n    data = data[key]; // step data\n    return _getSchema(nextNode, path, data);\n}\n", "import deepmerge from \"deepmerge\";\nconst overwriteMerge = (destinationArray, sourceArray) => sourceArray;\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport default (a, b) => deepmerge(a, b, { arrayMerge: overwriteMerge });\n// var d = c.filter((item, pos) => c.indexOf(item) === pos)\nconst mergeUniqueItems = (destinationArray, sourceArray) => {\n    const all = destinationArray.concat(sourceArray);\n    return all.filter((item, pos) => all.indexOf(item) === pos);\n};\n/**\n * returns a new json-schema, where properties are combined and arrays are replaced\n */\nexport const mergeArraysUnique = (a, b) => deepmerge(a, b, { arrayMerge: mergeUniqueItems });\n", "import getTypeOf from \"../getTypeOf\";\nexport function isEmpty(v) {\n    const type = getTypeOf(v);\n    switch (type) {\n        case \"string\":\n        case \"array\":\n            // @ts-expect-error tested as array - could use ts type guard\n            return (v === null || v === void 0 ? void 0 : v.length) === 0;\n        case \"null\":\n        case \"undefined\":\n            return true;\n        case \"object\":\n            return Object.keys(v).length === 0;\n        default:\n            return false;\n    }\n}\n", "/* eslint quote-props: 0, max-statements-per-line: [\"error\", { \"max\": 2 }] */\nimport { resolveOneOfFuzzy } from \"./features/oneOf\";\nimport getTypeOf from \"./getTypeOf\";\nimport merge from \"./utils/merge\";\nimport copy from \"./utils/copy\";\nimport settings from \"./config/settings\";\nimport { isJsonError } from \"./types\";\nimport { isSchemaNode } from \"./schemaNode\";\nimport { isEmpty } from \"./utils/isEmpty\";\nimport { resolveIfSchema } from \"./features/if\";\nimport { mergeAllOfSchema, resolveSchema } from \"./features/allOf\";\nimport { resolveDependencies } from \"./features/dependencies\";\nimport { mergeSchema } from \"./mergeSchema\";\nconst defaultOptions = settings.templateDefaultOptions;\nlet cache;\nfunction shouldResolveRef(schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return true;\n    }\n    const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];\n    return value < settings.GET_TEMPLATE_RECURSION_LIMIT;\n}\nfunction resolveRef(draft, schema, pointer) {\n    const { $ref } = schema;\n    if ($ref == null) {\n        return schema;\n    }\n    // @todo pointer + ref is redundant?\n    cache[pointer] = cache[pointer] || {};\n    cache[pointer][$ref] = cache[pointer][$ref] || 0;\n    cache[pointer][$ref] += 1;\n    return draft.createNode(schema, pointer).resolveRef().schema;\n}\nfunction convertValue(type, value) {\n    if (type === \"string\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof value !== \"string\") {\n        return null;\n    }\n    try {\n        value = JSON.parse(value);\n        if (typeof value === type) {\n            return value;\n        }\n    }\n    catch (e) { } // eslint-disable-line no-empty\n    return null;\n}\n/**\n * Resolves $ref, allOf and anyOf schema-options, returning a combined json-schema.\n * Also returns a pointer-property on schema, that must be used as current pointer.\n *\n * @param draft\n * @param schema\n * @param data\n * @param pointer\n * @return resolved json-schema or input-schema\n */\nfunction createTemplateSchema(draft, schema, data, pointer, opts) {\n    // invalid schema\n    if (getTypeOf(schema) !== \"object\") {\n        return Object.assign({ pointer }, schema);\n    }\n    // return if reached recursion limit\n    if (shouldResolveRef(schema, pointer) === false && data == null) {\n        return false;\n    }\n    // resolve $ref and copy schema\n    let templateSchema = copy(resolveRef(draft, schema, pointer));\n    // @feature anyOf\n    if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {\n        // test if we may resolve\n        if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {\n            const resolvedAnyOf = resolveRef(draft, schema.anyOf[0], `${pointer}/anyOf/0`);\n            templateSchema = merge(templateSchema, resolvedAnyOf);\n            // add pointer return-value, if any\n            templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;\n        }\n        delete templateSchema.anyOf;\n    }\n    // @feature allOf\n    if (Array.isArray(schema.allOf)) {\n        const mayResolve = schema.allOf\n            .map((allOf, index) => shouldResolveRef(allOf, `${pointer}/allOf/${index}`))\n            .reduceRight((next, before) => next && before, true);\n        if (mayResolve) {\n            // before merging all-of, we need to resolve all if-then-else statesments\n            // we need to udpate data on the way to trigger if-then-else schemas sequentially.\n            // Note that this will make if-then-else order-dependent\n            const allOf = [];\n            let extendedData = copy(data);\n            for (let i = 0; i < schema.allOf.length; i += 1) {\n                const allNode = draft.createNode(schema.allOf[i], pointer);\n                allOf.push(resolveSchema(allNode, extendedData).schema);\n                extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);\n            }\n            const resolvedSchema = mergeAllOfSchema(draft, { allOf });\n            if (resolvedSchema) {\n                templateSchema = mergeSchema(templateSchema, resolvedSchema);\n            }\n        }\n    }\n    templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;\n    return templateSchema;\n}\nconst isJsonSchema = (template) => template && typeof template === \"object\";\n/**\n * Create data object matching the given schema\n *\n * @param draft - json schema draft\n * @param [data] - optional template data\n * @param [schema] - json schema, defaults to rootSchema\n * @return created template data\n */\nfunction getTemplate(draft, data, _schema, pointer, opts) {\n    var _a;\n    if (_schema == null) {\n        throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);\n    }\n    if (pointer == null) {\n        throw new Error(\"Missing pointer\");\n    }\n    // resolve $ref references, allOf and first anyOf definitions\n    let schema = createTemplateSchema(draft, _schema, data, pointer, opts);\n    if (!isJsonSchema(schema)) {\n        return undefined;\n    }\n    pointer = schema.pointer;\n    if (schema === null || schema === void 0 ? void 0 : schema.const) {\n        return schema.const;\n    }\n    // @feature oneOf\n    if (Array.isArray(schema.oneOf)) {\n        if (isEmpty(data)) {\n            const type = schema.oneOf[0].type ||\n                schema.type ||\n                (schema.const && typeof schema.const) ||\n                getTypeOf(data);\n            schema = { ...schema.oneOf[0], type };\n        }\n        else {\n            // find correct schema for data\n            const oneNode = draft.createNode(schema, pointer);\n            const resolvedNode = resolveOneOfFuzzy(oneNode, data);\n            if (isJsonError(resolvedNode)) {\n                if (data != null && opts.removeInvalidData !== true) {\n                    return data;\n                }\n                // override\n                schema = schema.oneOf[0];\n                data = undefined;\n            }\n            else {\n                const resolvedSchema = resolvedNode.schema;\n                resolvedSchema.type = (_a = resolvedSchema.type) !== null && _a !== void 0 ? _a : schema.type;\n                schema = resolvedSchema;\n            }\n        }\n    }\n    // @todo Array.isArray(schema.type)\n    // -> hasDefault? return\n    // if not -> pick first types\n    if (!isJsonSchema(schema) || schema.type == null) {\n        return undefined;\n    }\n    // @attention - very special case to support file instances\n    if (data instanceof File) {\n        return data;\n    }\n    const type = Array.isArray(schema.type)\n        ? selectType(schema.type, data, schema.default)\n        : schema.type;\n    // reset invalid type\n    const javascriptTypeOfData = getTypeOf(data);\n    if (data != null &&\n        javascriptTypeOfData !== type &&\n        !(javascriptTypeOfData === \"number\" && type === \"integer\")) {\n        data = convertValue(type, data);\n    }\n    if (TYPE[type] == null) {\n        // in case we could not resolve the type\n        // (schema-type could not be resolved and returned an error)\n        if (opts.removeInvalidData) {\n            return undefined;\n        }\n        return data;\n    }\n    const templateData = TYPE[type](draft, schema, data, pointer, opts);\n    return templateData;\n}\nfunction selectType(types, data, defaultValue) {\n    if (data == undefined) {\n        if (defaultValue != null) {\n            const defaultType = getTypeOf(defaultValue);\n            if (types.includes(defaultType)) {\n                return defaultType;\n            }\n        }\n        return types[0];\n    }\n    const dataType = getTypeOf(data);\n    if (types.includes(dataType)) {\n        return dataType;\n    }\n    return types[0];\n}\nconst TYPE = {\n    null: (draft, schema, data) => getDefault(schema, data, null),\n    string: (draft, schema, data) => getDefault(schema, data, \"\"),\n    number: (draft, schema, data) => getDefault(schema, data, 0),\n    integer: (draft, schema, data) => getDefault(schema, data, 0),\n    boolean: (draft, schema, data) => getDefault(schema, data, false),\n    object: (draft, schema, data, pointer, opts) => {\n        var _a;\n        const template = schema.default === undefined ? {} : schema.default;\n        const d = {}; // do not assign data here, to keep ordering from json-schema\n        const required = (opts.extendDefaults === false && schema.default !== undefined) ? [] : ((_a = schema.required) !== null && _a !== void 0 ? _a : []);\n        if (schema.properties) {\n            Object.keys(schema.properties).forEach((key) => {\n                const value = data == null || data[key] == null ? template[key] : data[key];\n                const isRequired = required.includes(key);\n                // Omit adding a property if it is not required or optional props should be added\n                if (value != null || isRequired || opts.addOptionalProps) {\n                    d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);\n                }\n            });\n        }\n        // @feature dependencies\n        // has to be done after resolving properties so dependency may trigger\n        const dNode = draft.createNode(schema, pointer);\n        let dependenciesSchema = resolveDependencies(dNode, d);\n        if (dependenciesSchema) {\n            dependenciesSchema = mergeSchema(schema, dependenciesSchema);\n            delete dependenciesSchema.dependencies;\n            const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);\n            Object.assign(d, dependencyData);\n        }\n        if (data) {\n            if (opts.removeInvalidData === true &&\n                (schema.additionalProperties === false ||\n                    getTypeOf(schema.additionalProperties) === \"object\")) {\n                if (getTypeOf(schema.additionalProperties) === \"object\") {\n                    Object.keys(data).forEach((key) => {\n                        if (d[key] == null) {\n                            // merge valid missing data (additionals) to resulting object\n                            if (draft.isValid(data[key], schema.additionalProperties)) {\n                                d[key] = data[key];\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                // merge any missing data (additionals) to resulting object\n                Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));\n            }\n        }\n        // @feature if-then-else\n        const node = draft.createNode(schema, pointer);\n        const ifSchema = resolveIfSchema(node, d);\n        if (isSchemaNode(ifSchema)) {\n            const additionalData = getTemplate(draft, d, { type: \"object\", ...ifSchema.schema }, pointer, opts);\n            Object.assign(d, additionalData);\n        }\n        // returns object, which is ordered by json-schema\n        return d;\n    },\n    // build array type of items, ignores additionalItems\n    array: (draft, schema, data, pointer, opts) => {\n        var _a, _b;\n        if (schema.items == null) {\n            return data || []; // items are undefined\n        }\n        const template = schema.default === undefined ? [] : schema.default;\n        const d = data || template;\n        const minItems = (opts.extendDefaults === false && schema.default !== undefined) ? 0 : (schema.minItems || 0);\n        // build defined set of items\n        if (Array.isArray(schema.items)) {\n            for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a = schema.items) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);\n            }\n            return d;\n        }\n        // abort if the schema is invalid\n        if (getTypeOf(schema.items) !== \"object\") {\n            return d;\n        }\n        // resolve allOf and first anyOf definition\n        const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);\n        if (templateSchema === false) {\n            return d;\n        }\n        pointer = templateSchema.pointer || pointer;\n        // build data for first oneOf-schema\n        if (templateSchema.oneOf && d.length === 0) {\n            const oneOfSchema = templateSchema.oneOf[0];\n            for (let i = 0; i < minItems; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);\n            }\n            return d;\n        }\n        // complete data selecting correct oneOf-schema\n        if (templateSchema.oneOf && d.length > 0) {\n            const itemCount = Math.max(minItems, d.length);\n            for (let i = 0; i < itemCount; i += 1) {\n                let value = d[i] == null ? template[i] : d[i];\n                const oneNode = draft.createNode(templateSchema, pointer);\n                let one = resolveOneOfFuzzy(oneNode, value);\n                if (one == null || isJsonError(one)) {\n                    // schema could not be resolved or data is invalid\n                    if (value != null && opts.removeInvalidData !== true) {\n                        // keep invalid value\n                        d[i] = value;\n                    }\n                    else {\n                        // replace invalid value\n                        value = undefined;\n                        one = templateSchema.oneOf[0];\n                        d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);\n                    }\n                }\n                else {\n                    // schema is valid\n                    d[i] = getTemplate(draft, value, one.schema, `${pointer}/oneOf/${i}`, opts);\n                }\n            }\n            return d;\n        }\n        // build data from items-definition\n        if (templateSchema.type) {\n            for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {\n                d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);\n            }\n            return d;\n        }\n        return d;\n    }\n};\nfunction getDefault(schema, templateValue, initValue) {\n    if (templateValue != null) {\n        return templateValue;\n    }\n    else if (schema.const) {\n        return schema.const;\n    }\n    else if (schema.default === undefined && Array.isArray(schema.enum)) {\n        return schema.enum[0];\n    }\n    else if (schema.default === undefined) {\n        return initValue;\n    }\n    return schema.default;\n}\nexport default (draft, data, schema = draft.rootSchema, opts) => {\n    cache = {};\n    if (opts) {\n        return getTemplate(draft, data, schema, \"#\", { ...defaultOptions, ...opts });\n    }\n    return getTemplate(draft, data, schema, \"#\", defaultOptions);\n};\n", "/**\n * Test if the data is valid according to the given schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema\n * @param [pointer] - json pointer pointing to value\n * @return if schema does match given value\n */\nexport default function isValid(draft, value, schema = draft.rootSchema, pointer = \"#\") {\n    const node = draft.createNode(schema, pointer);\n    return draft.validate(node, value).length === 0;\n}\n", "/* eslint no-bitwise: 0 */\n/**\n * taken from punycode@2.1.0\n *\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param string The Unicode input string (UCS-2).\n * @returns The new array of code points.\n */\nexport default function ucs2decode(string) {\n    const output = [];\n    let counter = 0;\n    const length = string.length;\n    while (counter < length) {\n        const value = string.charCodeAt(counter++);\n        if (value >= 0xd800 && value <= 0xdbff && counter < length) {\n            // It's a high surrogate, and there is a next character.\n            const extra = string.charCodeAt(counter++);\n            // eslint-disable-next-line eqeqeq\n            if ((extra & 0xfc00) == 0xdc00) {\n                // Low surrogate.\n                output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);\n            }\n            else {\n                // It's an unmatched surrogate; only append this code unit, in case the\n                // next code unit is the high surrogate of a surrogate pair.\n                output.push(value);\n                counter--;\n            }\n        }\n        else {\n            output.push(value);\n        }\n    }\n    return output;\n}\n", "/**\n * returns the floating point precision of a decimal number or 0\n */\nexport function getPrecision(value) {\n    const string = `${value}`;\n    if (string.includes(\"e-\")) {\n        return parseInt(string.replace(/.*e-/, \"\"));\n    }\n    const index = string.indexOf(\".\");\n    return index === -1 ? 0 : string.length - (index + 1);\n}\n", "import getTypeOf from \"../getTypeOf\";\nimport settings from \"../config/settings\";\nimport ucs2decode from \"../utils/punycode.ucs2decode\";\nimport { isObject } from \"../utils/isObject\";\nimport { isJsonError } from \"../types\";\nimport { validateAllOf } from \"../features/allOf\";\nimport { validateAnyOf } from \"../features/anyOf\";\nimport { validateDependencies } from \"../features/dependencies\";\nimport { validateOneOf } from \"../features/oneOf\";\nimport { getPrecision } from \"../utils/getPrecision\";\nimport deepEqual from \"fast-deep-equal\";\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasProperty = (value, property) => !(value[property] === undefined || !hasOwnProperty.call(value, property));\n// list of validation keywords: http://json-schema.org/latest/json-schema-validation.html#rfc.section.5\nconst KeywordValidation = {\n    additionalProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (schema.additionalProperties === true || schema.additionalProperties == null) {\n            return undefined;\n        }\n        if (getTypeOf(schema.patternProperties) === \"object\" &&\n            schema.additionalProperties === false) {\n            // this is an arrangement with patternProperties. patternProperties validate before additionalProperties:\n            // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#index-5\n            return undefined;\n        }\n        const errors = [];\n        let receivedProperties = Object.keys(value).filter((prop) => settings.propertyBlacklist.includes(prop) === false);\n        const expectedProperties = Object.keys(schema.properties || {});\n        if (getTypeOf(schema.patternProperties) === \"object\") {\n            // filter received properties by matching patternProperties\n            const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));\n            receivedProperties = receivedProperties.filter((prop) => {\n                for (let i = 0; i < patterns.length; i += 1) {\n                    if (patterns[i].test(prop)) {\n                        return false; // remove\n                    }\n                }\n                return true;\n            });\n        }\n        // adds an error for each an unexpected property\n        for (let i = 0, l = receivedProperties.length; i < l; i += 1) {\n            const property = receivedProperties[i];\n            if (expectedProperties.indexOf(property) === -1) {\n                const additionalIsObject = isObject(schema.additionalProperties);\n                // additionalProperties { oneOf: [] }\n                if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {\n                    const result = draft.resolveOneOf(node.next(schema.additionalProperties), value[property]);\n                    if (isJsonError(result)) {\n                        errors.push(draft.errors.additionalPropertiesError({\n                            pointer,\n                            schema: schema.additionalProperties,\n                            value,\n                            property: receivedProperties[i],\n                            properties: expectedProperties,\n                            // pass all validation errors\n                            errors: result.data.errors\n                        }));\n                    }\n                    else {\n                        errors.push(...draft.validate(node.next(result, property), value[property]));\n                    }\n                    // additionalProperties {}\n                }\n                else if (additionalIsObject) {\n                    const res = draft.validate(node.next(schema.additionalProperties, property), value[property]);\n                    errors.push(...res);\n                }\n                else {\n                    errors.push(draft.errors.noAdditionalPropertiesError({\n                        pointer,\n                        schema,\n                        value,\n                        property: receivedProperties[i],\n                        properties: expectedProperties\n                    }));\n                }\n            }\n        }\n        return errors;\n    },\n    allOf: validateAllOf,\n    anyOf: validateAnyOf,\n    dependencies: validateDependencies,\n    enum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const type = getTypeOf(value);\n        if (type === \"object\" || type === \"array\") {\n            const valueStr = JSON.stringify(value);\n            for (let i = 0; i < schema.enum.length; i += 1) {\n                if (JSON.stringify(schema.enum[i]) === valueStr) {\n                    return undefined;\n                }\n            }\n        }\n        else if (schema.enum.includes(value)) {\n            return undefined;\n        }\n        return draft.errors.enumError({ pointer, schema, value, values: schema.enum });\n    },\n    format: (node, value) => {\n        const { draft, schema } = node;\n        if (draft.validateFormat[schema.format]) {\n            const errors = draft.validateFormat[schema.format](node, value);\n            return errors;\n        }\n        // fail silently if given format is not defined\n        return undefined;\n    },\n    items: (node, value) => {\n        const { draft, schema, pointer } = node;\n        // @draft >= 7 bool schema\n        if (schema.items === false) {\n            if (Array.isArray(value) && value.length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidDataError({ pointer, value, schema });\n        }\n        const errors = [];\n        for (let i = 0; i < value.length; i += 1) {\n            const itemData = value[i];\n            // @todo reevaluate: incomplete schema is created here\n            const itemNode = draft.step(node.next(schema), i, value);\n            if (isJsonError(itemNode)) {\n                return [itemNode];\n            }\n            const itemErrors = draft.validate(itemNode, itemData);\n            errors.push(...itemErrors);\n        }\n        return errors;\n    },\n    maximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                value,\n                pointer,\n                schema\n            });\n        }\n        if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maxItems)) {\n            return undefined;\n        }\n        if (schema.maxItems < value.length) {\n            return draft.errors.maxItemsError({\n                maximum: schema.maxItems,\n                length: value.length,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    maxLength: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maxLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.maxLength < lengthOfString) {\n            return draft.errors.maxLengthError({\n                maxLength: schema.maxLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    maxProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const propertyCount = Object.keys(value).length;\n        if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {\n            return draft.errors.maxPropertiesError({\n                maxProperties: schema.maxProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minLength: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minLength)) {\n            return undefined;\n        }\n        const lengthOfString = ucs2decode(value).length;\n        if (schema.minLength > lengthOfString) {\n            if (schema.minLength === 1) {\n                return draft.errors.minLengthOneError({\n                    minLength: schema.minLength,\n                    length: lengthOfString,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minLengthError({\n                minLength: schema.minLength,\n                length: lengthOfString,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        if (schema.exclusiveMinimum === true && schema.minimum === value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minItems)) {\n            return undefined;\n        }\n        if (schema.minItems > value.length) {\n            if (schema.minItems === 1) {\n                return draft.errors.minItemsOneError({\n                    minItems: schema.minItems,\n                    length: value.length,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return draft.errors.minItemsError({\n                minItems: schema.minItems,\n                length: value.length,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minProperties)) {\n            return undefined;\n        }\n        const propertyCount = Object.keys(value).length;\n        if (schema.minProperties > propertyCount) {\n            return draft.errors.minPropertiesError({\n                minProperties: schema.minProperties,\n                length: propertyCount,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    multipleOf: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.multipleOf) || typeof value !== \"number\") {\n            return undefined;\n        }\n        const valuePrecision = getPrecision(value);\n        const multiplePrecision = getPrecision(schema.multipleOf);\n        if (valuePrecision > multiplePrecision) {\n            // value with higher precision then multipleOf-precision can never be multiple\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        const precision = Math.pow(10, multiplePrecision);\n        const val = Math.round(value * precision);\n        const multiple = Math.round(schema.multipleOf * precision);\n        if ((val % multiple) / precision !== 0) {\n            return draft.errors.multipleOfError({\n                multipleOf: schema.multipleOf,\n                value,\n                pointer,\n                schema\n            });\n        }\n        // maybe also check overflow\n        // https://stackoverflow.com/questions/1815367/catch-and-compute-overflow-during-multiplication-of-two-large-integers\n        return undefined;\n    },\n    not: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const errors = [];\n        if (draft.validate(node.next(schema.not), value).length === 0) {\n            errors.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));\n        }\n        return errors;\n    },\n    oneOf: validateOneOf,\n    pattern: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const pattern = new RegExp(schema.pattern, \"u\");\n        if (pattern.test(value) === false) {\n            return draft.errors.patternError({\n                pattern: schema.pattern,\n                description: schema.patternExample || schema.pattern,\n                received: value,\n                schema,\n                value,\n                pointer\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    schema,\n                    value,\n                    patterns: Object.keys(pp).join(\",\")\n                }));\n            }\n        });\n        return errors;\n    },\n    properties: (node, value) => {\n        const { draft, schema } = node;\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (hasProperty(value, key)) {\n                const itemNode = draft.step(node, key, value);\n                if (isJsonError(itemNode)) {\n                    errors.push(itemNode);\n                }\n                else {\n                    const keyErrors = draft.validate(itemNode, value[key]);\n                    errors.push(...keyErrors);\n                }\n            }\n        }\n        return errors;\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword\n    propertiesRequired: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const errors = [];\n        const keys = Object.keys(schema.properties || {});\n        for (let i = 0; i < keys.length; i += 1) {\n            const key = keys[i];\n            if (value[key] === undefined) {\n                errors.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));\n            }\n            else {\n                const itemNode = draft.step(node, key, value);\n                const keyErrors = draft.validate(itemNode, value[key]);\n                errors.push(...keyErrors);\n            }\n        }\n        return errors;\n    },\n    required: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            if (!hasProperty(value, property)) {\n                return draft.errors.requiredPropertyError({\n                    key: property,\n                    pointer,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword\n    requiredNotEmpty: (node, value) => {\n        const { schema } = node;\n        if (Array.isArray(schema.required) === false) {\n            return undefined;\n        }\n        return schema.required.map((property) => {\n            const { draft, schema, pointer } = node;\n            if (value[property] == null || value[property] === \"\") {\n                return draft.errors.valueNotEmptyError({\n                    property,\n                    pointer: `${pointer}/${property}`,\n                    schema,\n                    value\n                });\n            }\n            return undefined;\n        });\n    },\n    uniqueItems: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if ((Array.isArray(value) && schema.uniqueItems) === false) {\n            return undefined;\n        }\n        const duplicates = [];\n        const errors = [];\n        value.forEach((item, index) => {\n            for (let i = index + 1; i < value.length; i += 1) {\n                if (deepEqual(item, value[i]) && !duplicates.includes(i)) {\n                    errors.push(draft.errors.uniqueItemsError({\n                        pointer: `${pointer}/${i}`,\n                        duplicatePointer: `${pointer}/${index}`,\n                        arrayPointer: pointer,\n                        value: JSON.stringify(item),\n                        schema\n                    }));\n                    duplicates.push(i);\n                }\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n", "import getTypeOf from \"./getTypeOf\";\nimport createSchemaOf from \"./createSchemaOf\";\nimport { isJsonError } from \"./types\";\nimport { reduceSchema } from \"./reduceSchema\";\nconst stepType = {\n    array: (node, key, data) => {\n        const { draft, schema, pointer } = node;\n        const itemValue = data === null || data === void 0 ? void 0 : data[key];\n        const itemsType = getTypeOf(schema.items);\n        if (itemsType === \"object\") {\n            // @spec: ignore additionalItems, when items is schema-object\n            return reduceSchema(node.next(schema.items, key), itemValue);\n        }\n        if (itemsType === \"array\") {\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === true) {\n                return node.next(createSchemaOf(itemValue), key);\n            }\n            // @draft >= 7 bool schema, items:[true, false]\n            if (schema.items[key] === false) {\n                return draft.errors.invalidDataError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.items[key]) {\n                return draft.resolveRef(node.next(schema.items[key], key));\n            }\n            if (schema.additionalItems === false) {\n                return draft.errors.additionalItemsError({\n                    key,\n                    value: itemValue,\n                    pointer,\n                    schema\n                });\n            }\n            if (schema.additionalItems === true || schema.additionalItems === undefined) {\n                return node.next(createSchemaOf(itemValue), key);\n            }\n            if (getTypeOf(schema.additionalItems) === \"object\") {\n                return node.next(schema.additionalItems, key);\n            }\n            throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);\n        }\n        if (schema.additionalItems !== false && itemValue) {\n            // @todo reevaluate: incomplete schema is created here\n            // @todo support additionalItems: {schema}\n            return node.next(createSchemaOf(itemValue), key);\n        }\n        return new Error(`Invalid array schema for ${key} at ${pointer}`);\n    },\n    object: (node, key, data) => {\n        var _a, _b;\n        const { draft, pointer } = node;\n        const reduction = reduceSchema(node, data);\n        const schema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // @feature properties\n        const property = (_b = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _b === void 0 ? void 0 : _b[key];\n        if (property !== undefined) {\n            // @todo patternProperties also validate properties\n            // @feature boolean schema\n            if (property === false) {\n                return draft.errors.forbiddenPropertyError({\n                    property: key,\n                    value: data,\n                    pointer,\n                    schema\n                });\n            }\n            else if (property === true) {\n                return node.next(createSchemaOf(data === null || data === void 0 ? void 0 : data[key]), key);\n            }\n            const nextPropertyNode = draft.resolveRef(node.next(property, key));\n            if (isJsonError(nextPropertyNode)) {\n                return nextPropertyNode;\n            }\n            // check if there is a oneOf selection, which must be resolved\n            if (nextPropertyNode && Array.isArray(nextPropertyNode.schema.oneOf)) {\n                // @special case: this is a mix of a schema and optional definitions\n                // we resolve the schema here and add the original schema to `oneOfSchema`\n                const nextNode = node.next(nextPropertyNode.schema, key);\n                const result = draft.resolveOneOf(nextNode, data[key]);\n                if (isJsonError(result)) {\n                    return result;\n                }\n                return nextNode.merge(result.schema, \"oneOf\");\n            }\n            if (nextPropertyNode) {\n                return nextPropertyNode;\n            }\n        }\n        // @feature patternProperties\n        const { patternProperties } = schema;\n        if (getTypeOf(patternProperties) === \"object\") {\n            // find matching property key\n            let regex;\n            const patterns = Object.keys(patternProperties);\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                regex = new RegExp(patterns[i]);\n                if (regex.test(key)) {\n                    return node.next(patternProperties[patterns[i]], key);\n                }\n            }\n        }\n        // @feature additionalProperties\n        const { additionalProperties } = schema;\n        if (getTypeOf(additionalProperties) === \"object\") {\n            return node.next(schema.additionalProperties, key);\n        }\n        if (data && (additionalProperties === undefined || additionalProperties === true)) {\n            const generatedSchema = createSchemaOf(data[key]);\n            return generatedSchema ? node.next(generatedSchema, key) : undefined;\n        }\n        return draft.errors.unknownPropertyError({\n            property: key,\n            value: data,\n            pointer: `${pointer}`,\n            schema\n        });\n    }\n};\n/**\n * Returns the json-schema of the given object property or array item.\n * e.g. it steps by one key into the data\n *\n *  This helper determines the location of the property within the schema (additional properties, oneOf, ...) and\n *  returns the correct schema.\n *\n * @param  draft      - validator\n * @param  key       - property-name or array-index\n * @param  schema    - json schema of current data\n * @param  data      - parent of key\n * @param  [pointer] - pointer to schema and data (parent of key)\n * @return Schema or Error if failed resolving key\n */\nexport default function step(node, key, data) {\n    var _a;\n    const { draft, schema, pointer } = node;\n    const typeOfData = getTypeOf(data);\n    let schemaType = (_a = schema.type) !== null && _a !== void 0 ? _a : typeOfData;\n    // @draft >= 4 ?\n    if (Array.isArray(schemaType)) {\n        if (!schemaType.includes(typeOfData)) {\n            return draft.errors.typeError({\n                value: data,\n                pointer,\n                expected: schema.type,\n                received: typeOfData,\n                schema\n            });\n        }\n        schemaType = typeOfData;\n    }\n    const stepFunction = stepType[schemaType];\n    if (stepFunction) {\n        const childNode = stepFunction(node, `${key}`, data);\n        if (childNode === undefined) {\n            return draft.errors.schemaWarning({ pointer, value: data, schema, key });\n        }\n        return childNode;\n    }\n    return new Error(`Unsupported schema type ${schema.type} for key ${key}`);\n}\n", "/**\n * @todo: type is also a keyword, as is properties, items, etc\n *\n * An instance has one of six primitive types (http://json-schema.org/latest/json-schema-node.draft.html#rfc.section.4.2)\n * or seven in case of ajv https://github.com/epoberezkin/ajv/blob/master/KEYWORDS.md#type\n * 1 null, 2 boolean, 3 object, 4 array, 5 number, 6 string (7 integer)\n */\nconst typeValidators = {\n    array: (node, value) => node.draft.typeKeywords.array\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    object: (node, value) => node.draft.typeKeywords.object\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    string: (node, value) => node.draft.typeKeywords.string\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    integer: (node, value) => node.draft.typeKeywords.number\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    number: (node, value) => node.draft.typeKeywords.number\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    boolean: (node, value) => node.draft.typeKeywords.boolean\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value)),\n    null: (node, value) => node.draft.typeKeywords.null\n        .filter((key) => node.schema && node.schema[key] != null)\n        .map((key) => node.draft.validateKeyword[key](node, value))\n};\nexport default typeValidators;\n", "import getTypeOf from \"./getTypeOf\";\nimport { errorOrPromise } from \"./utils/filter\";\nimport flattenArray from \"./utils/flattenArray\";\nimport { isJsonError } from \"./types\";\nimport { isSchemaNode } from \"./schemaNode\";\nimport equal from \"fast-deep-equal\";\nfunction getJsonSchemaType(value, expectedType) {\n    const jsType = getTypeOf(value);\n    if (jsType === \"number\" &&\n        (expectedType === \"integer\" ||\n            (Array.isArray(expectedType) && expectedType.includes(\"integer\")))) {\n        return Number.isInteger(value) || isNaN(value) ? \"integer\" : \"number\";\n    }\n    return jsType;\n}\n/**\n * Validates data with json schema\n *\n * @param draft - validator\n * @param value - value to validate\n * @param [schema] - json schema, defaults to rootSchema\n * @param [pointer] - json pointer pointing to value (used for error-messages only)\n * @return list of errors or empty\n */\nexport default function validate(node, value) {\n    if (!isSchemaNode(node)) {\n        throw new Error(\"node expected\");\n    }\n    const { draft, pointer } = node;\n    node = node.resolveRef();\n    const schema = node.schema;\n    if (schema == null) {\n        throw new Error(\"missing schema\");\n    }\n    // @draft >= 07\n    if (getTypeOf(schema) === \"boolean\") {\n        if (schema) {\n            return [];\n        }\n        return [draft.errors.invalidDataError({ pointer, schema, value })];\n    }\n    if (isJsonError(schema)) {\n        return [schema];\n    }\n    // @draft >= 6 const\n    if (schema.const !== undefined) {\n        if (equal(schema.const, value)) {\n            return [];\n        }\n        return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];\n    }\n    const receivedType = getJsonSchemaType(value, schema.type);\n    const expectedType = schema.type || receivedType;\n    if (receivedType !== expectedType &&\n        (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {\n        return [\n            draft.errors.typeError({\n                pointer,\n                schema,\n                value,\n                received: receivedType,\n                expected: expectedType\n            })\n        ];\n    }\n    if (draft.validateType[receivedType] == null) {\n        return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];\n    }\n    // get type validation results\n    const errors = flattenArray(draft.validateType[receivedType](node, value));\n    return errors.filter(errorOrPromise); // ignore promises here\n}\n", "import getTypeOf from \"./getTypeOf\";\nimport { isSchemaNode } from \"./schemaNode\";\n/**\n * Iterates over data, retrieving its schema\n *\n * @param draft - validator\n * @param data - the data to iterate\n * @param callback - will be called with (schema, data, pointer) on each item\n * @param [schema] - the schema matching the data. Defaults to rootSchema\n * @param [pointer] - pointer to current data. Default to rootPointer\n */\nexport function each(schemaNode, data, callback) {\n    const node = schemaNode.resolveRef();\n    const { draft, schema, pointer } = node;\n    callback(schema, data, pointer);\n    const dataType = getTypeOf(data);\n    if (dataType === \"object\") {\n        Object.keys(data).forEach((key) => {\n            const nextNode = draft.step(node, key, data);\n            if (isSchemaNode(nextNode)) {\n                each(nextNode, data[key], callback);\n            }\n        });\n    }\n    else if (dataType === \"array\") {\n        data.forEach((next, key) => {\n            const nextNode = draft.step(node, key, data);\n            if (isSchemaNode(nextNode)) {\n                each(nextNode, data[key], callback);\n            }\n        });\n    }\n}\n", "import addRemoteSchema from \"./addRemoteSchema\";\nimport compileSchema from \"../compile\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveRef from \"../resolveRef.strict\";\nimport settings from \"../config/settings\";\nimport step from \"../step\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { createNode } from \"../schemaNode\";\nimport { Draft } from \"../draft\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nconst draft04Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"enum\", \"not\", \"allOf\", \"anyOf\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"minProperties\",\n            \"maxProperties\",\n            \"patternProperties\",\n            \"properties\",\n            \"required\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    createNode,\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft04 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft04Config, config), schema);\n    }\n}\nexport { Draft04, draft04Config };\n", "/**\n * register a json-schema to be referenced from another json-schema\n * @param url    base-url of json-schema (aka id)\n * @param schema\n */\nexport default function addRemoteSchema(draft, url, schema) {\n    // @draft >= 6\n    schema.$id = schema.$id || url;\n    draft.remotes[url] = draft.compileSchema(schema);\n}\n", "import { eachSchema } from \"../../eachSchema\";\n// import remotes from \"../../../remotes\";\nimport joinScope from \"../../compile/joinScope\";\nimport getRef from \"../../compile/getRef\";\nimport { get } from \"@sagold/json-pointer\";\nconst COMPILED = \"__compiled\";\nconst COMPILED_REF = \"__ref\";\nconst GET_REF = \"getRef\";\nconst GET_ROOT = \"getRoot\";\nconst GET_CONTEXT = \"getContext\";\nconst suffixes = /(#|\\/)+$/g;\n/**\n * @draft 6, 2019-09\n * - starting with _draft 2019-09_ plain name fragments are no longer defined with $id,\n *  but instead with the new keyword $anchor (which has a different syntax)\n *  https://json-schema.org/draft/2019-09/release-notes#incompatible-changes\n * - in _draft 2019-09_ only $recursiveAnchor and $recursiveRef have been introduced\n * - starting with _draft 6_ id is named $id\n *\n * compiles the input root schema for $ref resolution and returns it again\n * @attention this modifies input schema but maintains object-structure\n *\n * for a compiled json-schema you can call getRef on any contained schema (location of type).\n * this resolves a $ref target to a valid schema (for a valid $ref)\n *\n * @param rootSchema root json-schema ($id, defs, ... ) to compile\n * @param [force] = false force compile json-schema\n * @return compiled json-schema\n */\nexport default function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {\n    // @ts-expect-error incomplete JsonSchema type\n    if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === undefined) {\n        return schemaToCompile;\n    }\n    if (schemaToCompile[COMPILED] !== undefined) {\n        return schemaToCompile;\n    } // eslint-disable-line\n    // console.log(\"compile schema\", schemaToCompile.$id);\n    const context = { ids: {}, anchors: {}, remotes: draft.remotes };\n    const rootSchemaAsString = JSON.stringify(schemaToCompile);\n    const compiledSchema = JSON.parse(rootSchemaAsString);\n    Object.defineProperties(compiledSchema, {\n        [COMPILED]: { enumerable: false, value: true },\n        [GET_CONTEXT]: { enumerable: false, value: () => context },\n        [GET_REF]: {\n            enumerable: false,\n            value: getRef.bind(null, context, compiledSchema)\n        }\n    });\n    // bail early, when no $refs are defined\n    if (force === false && rootSchemaAsString.includes(\"$ref\") === false) {\n        return compiledSchema;\n    }\n    // compile this schema under rootSchema, making definitions available to $ref-resolution\n    if (compiledSchema !== rootSchema) {\n        Object.defineProperty(compiledSchema, \"$defs\", {\n            enumerable: true,\n            value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)\n        });\n    }\n    const scopes = {};\n    const getRoot = () => compiledSchema;\n    eachSchema(compiledSchema, (schema, pointer) => {\n        var _a;\n        if (schema.$id) {\n            // if this is a schema being merged on root object, we cannot override\n            // parents locations, but must reuse it\n            if (schema.$id.startsWith(\"http\") && /(allOf|anyOf|oneOf|if)\\/\\d+$/.test(pointer)) {\n                const parentPointer = pointer.replace(/\\/(allOf|anyOf|oneOf|if)\\/\\d+$/, \"\");\n                const parentSchema = get(compiledSchema, parentPointer);\n                schema.$id = (_a = parentSchema.$id) !== null && _a !== void 0 ? _a : schema.$id;\n            }\n            context.ids[schema.$id.replace(suffixes, \"\")] = pointer;\n        }\n        // build up scopes and add them to $ref-resolution map\n        pointer = `#${pointer}`.replace(/##+/, \"#\");\n        const previousPointer = pointer.replace(/\\/[^/]+$/, \"\");\n        const parentPointer = pointer.replace(/\\/[^/]+\\/[^/]+$/, \"\");\n        const previousScope = scopes[previousPointer] || scopes[parentPointer];\n        const scope = joinScope(previousScope, schema.$id);\n        // // @todo specify behaviour - we do not save ids with trailing slashes...\n        scopes[pointer] = scope;\n        if (context.ids[scope] == null) {\n            context.ids[scope] = pointer;\n        }\n        if (schema.$anchor) {\n            context.anchors[`${scope}#${schema.$anchor}`] = pointer;\n        }\n        if (schema.$ref && !schema[COMPILED_REF]) {\n            Object.defineProperty(schema, COMPILED_REF, {\n                enumerable: false,\n                value: joinScope(scope, schema.$ref)\n            });\n            Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });\n        }\n    });\n    // console.log(\"ids\", context.ids);\n    // console.log(\"anchors\", context.anchors);\n    return compiledSchema;\n}\n", "import Keywords from \"../../validation/keyword\";\nimport getTypeOf from \"../../getTypeOf\";\nimport { validateIf } from \"../../features/if\";\nconst KeywordValidation = {\n    ...Keywords,\n    // @draft >= 6\n    contains: (node, value) => {\n        var _a, _b;\n        const { draft, schema, pointer } = node;\n        if (schema.contains === false) {\n            return draft.errors.containsArrayError({ pointer, value, schema });\n        }\n        if (schema.contains === true) {\n            if (Array.isArray(value) && value.length === 0) {\n                return draft.errors.containsAnyError({ pointer, value, schema });\n            }\n            return undefined;\n        }\n        if (getTypeOf(schema.contains) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        let count = 0;\n        for (let i = 0; i < value.length; i += 1) {\n            if (draft.validate(node.next(schema.contains, i), value[i]).length === 0) {\n                count++;\n            }\n        }\n        // @draft >= 2019-09\n        const max = (_a = schema.maxContains) !== null && _a !== void 0 ? _a : Infinity;\n        const min = (_b = schema.minContains) !== null && _b !== void 0 ? _b : 1;\n        if (max >= count && min <= count) {\n            return undefined;\n        }\n        if (max < count) {\n            return draft.errors.containsMaxError({ pointer, schema, delta: count - max, value });\n        }\n        if (min > count) {\n            return draft.errors.containsMinError({ pointer, schema, delta: min - count, value });\n        }\n        return draft.errors.containsError({ pointer, schema, value });\n    },\n    exclusiveMaximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.exclusiveMaximum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMaximum <= value) {\n            return draft.errors.maximumError({\n                maximum: schema.exclusiveMaximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    exclusiveMinimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.exclusiveMinimum)) {\n            return undefined;\n        }\n        if (schema.exclusiveMinimum >= value) {\n            return draft.errors.minimumError({\n                minimum: schema.exclusiveMinimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    // @feature if-then-else\n    if: validateIf,\n    maximum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.maximum)) {\n            return undefined;\n        }\n        if (schema.maximum && schema.maximum < value) {\n            return draft.errors.maximumError({\n                maximum: schema.maximum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    minimum: (node, value) => {\n        const { draft, schema, pointer } = node;\n        if (isNaN(schema.minimum)) {\n            return undefined;\n        }\n        if (schema.minimum > value) {\n            return draft.errors.minimumError({\n                minimum: schema.minimum,\n                length: value,\n                pointer,\n                schema,\n                value\n            });\n        }\n        return undefined;\n    },\n    patternProperties: (node, value) => {\n        const { draft, schema, pointer } = node;\n        const properties = schema.properties || {};\n        const pp = schema.patternProperties;\n        if (getTypeOf(pp) !== \"object\") {\n            return undefined;\n        }\n        const errors = [];\n        const keys = Object.keys(value);\n        const patterns = Object.keys(pp).map((expr) => ({\n            regex: new RegExp(expr),\n            patternSchema: pp[expr]\n        }));\n        keys.forEach((key) => {\n            let patternFound = false;\n            for (let i = 0, l = patterns.length; i < l; i += 1) {\n                if (patterns[i].regex.test(key)) {\n                    patternFound = true;\n                    // for a boolean schema `false`, always invalidate\n                    if (patterns[i].patternSchema === false) {\n                        errors.push(draft.errors.patternPropertiesError({\n                            key,\n                            pointer,\n                            patterns: Object.keys(pp).join(\",\"),\n                            schema,\n                            value\n                        }));\n                        return;\n                    }\n                    const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);\n                    if (valErrors && valErrors.length > 0) {\n                        errors.push(...valErrors);\n                    }\n                }\n            }\n            if (properties[key]) {\n                return;\n            }\n            if (patternFound === false && schema.additionalProperties === false) {\n                // this is an arrangement with additionalProperties\n                errors.push(draft.errors.patternPropertiesError({\n                    key,\n                    pointer,\n                    patterns: Object.keys(pp).join(\",\"),\n                    schema,\n                    value\n                }));\n            }\n        });\n        return errors;\n    },\n    // @draft >= 6\n    propertyNames: (node, value) => {\n        const { draft, schema, pointer } = node;\n        // bool schema\n        if (schema.propertyNames === false) {\n            // empty objects are valid\n            if (Object.keys(value).length === 0) {\n                return undefined;\n            }\n            return draft.errors.invalidPropertyNameError({\n                property: Object.keys(value),\n                pointer,\n                value,\n                schema\n            });\n        }\n        if (schema.propertyNames === true) {\n            return undefined;\n        }\n        if (getTypeOf(schema.propertyNames) !== \"object\") {\n            // ignore invalid schema\n            return undefined;\n        }\n        const errors = [];\n        const properties = Object.keys(value);\n        const propertySchema = { ...schema.propertyNames, type: \"string\" };\n        properties.forEach((prop) => {\n            const nextNode = node.next(propertySchema, prop);\n            const validationResult = draft.validate(nextNode, prop);\n            if (validationResult.length > 0) {\n                errors.push(draft.errors.invalidPropertyNameError({\n                    property: prop,\n                    pointer,\n                    validationError: validationResult[0],\n                    value: value[prop],\n                    schema\n                }));\n            }\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveRef from \"../resolveRef.strict\";\nimport settings from \"../config/settings\";\nimport step from \"../step\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { createNode } from \"../schemaNode\";\nimport { Draft } from \"../draft\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nconst draft06Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\",\n            \"allOf\",\n            \"anyOf\",\n            \"if\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    createNode,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft06 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft06Config, config), schema);\n    }\n}\nexport { Draft06, draft06Config };\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"../draft06/validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveRef from \"../resolveRef.strict\";\nimport settings from \"../config/settings\";\nimport step from \"../step\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { createNode } from \"../schemaNode\";\nimport { Draft } from \"../draft\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nconst draft07Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            \"dependencies\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\"\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    createNode,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft07 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft07Config, config), schema);\n    }\n}\nexport { Draft07, draft07Config };\n", "import Keywords from \"../../draft06/validation/keyword\";\nimport { isObject } from \"../../utils/isObject\";\nimport { reduceSchema } from \"../../reduceSchema\";\nimport { validateDependentSchemas, validateDependentRequired } from \"../../features/dependencies\";\n/**\n * Get a list of tests to search for a matching pattern to a property\n */\nconst getPatternTests = (patternProperties) => isObject(patternProperties)\n    ? Object.keys(patternProperties).map((pattern) => new RegExp(pattern))\n    : [];\n/** tests if a property is evaluated by the given schema */\nfunction isPropertyEvaluated(schemaNode, propertyName, value) {\n    var _a, _b;\n    const node = schemaNode.draft.resolveRef(schemaNode);\n    const { schema } = node;\n    if (schema.additionalProperties === true) {\n        return true;\n    }\n    // PROPERTIES\n    if ((_a = schema.properties) === null || _a === void 0 ? void 0 : _a[propertyName]) {\n        const nextSchema = (_b = schema.properties) === null || _b === void 0 ? void 0 : _b[propertyName];\n        if (node.draft.isValid(value, nextSchema)) {\n            return true;\n        }\n    }\n    // PATTERN-PROPERTIES\n    const patterns = getPatternTests(schema.patternProperties);\n    if (patterns.find((pattern) => pattern.test(propertyName))) {\n        return true;\n    }\n    // ADDITIONAL-PROPERTIES\n    if (isObject(schema.additionalProperties)) {\n        const nextSchema = schema.additionalProperties;\n        return node.draft.validate(node.next(nextSchema), value);\n    }\n    return false;\n}\nconst KeywordValidation = {\n    // ...omit(Keywords, \"dependencies\"),\n    ...Keywords,\n    dependencies: undefined,\n    dependentSchemas: validateDependentSchemas,\n    dependentRequired: validateDependentRequired,\n    /**\n     * @draft >= 2019-09\n     * Similar to additionalProperties, but can \"see\" into subschemas and across references\n     * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.2.4\n     */\n    unevaluatedProperties: (node, value) => {\n        var _a;\n        const { draft, schema, pointer } = node;\n        // if not in properties, evaluated by additionalProperties and not matches patternProperties\n        // @todo we need to know dynamic parent statements - they should not be counted as evaluated...\n        if (!isObject(value) || schema.unevaluatedProperties == null) {\n            return undefined;\n        }\n        let unevaluated = Object.keys(value);\n        if (unevaluated.length === 0) {\n            return undefined;\n        }\n        // resolve all dynamic schemas\n        const reduction = reduceSchema(node, value);\n        const resolvedSchema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // console.log(\"unevaluatedProperties\", JSON.stringify(resolvedSchema, null, 2), value);\n        if (resolvedSchema.unevaluatedProperties === true) {\n            return undefined;\n        }\n        const testPatterns = getPatternTests(resolvedSchema.patternProperties);\n        unevaluated = unevaluated.filter((key) => {\n            var _a;\n            if ((_a = resolvedSchema.properties) === null || _a === void 0 ? void 0 : _a[key]) {\n                return false;\n            }\n            // special case: an evaluation in if statement counts too\n            // we have an unevaluated prop only if the if-schema does not match\n            if (isObject(schema.if) &&\n                isPropertyEvaluated(node.next({ type: \"object\", ...schema.if }), key, value[key])) {\n                return false;\n            }\n            if (testPatterns.find((pattern) => pattern.test(key))) {\n                return false;\n            }\n            // @todo is this evaluated by additionaProperties per property\n            if (resolvedSchema.additionalProperties) {\n                return false;\n            }\n            return true;\n        });\n        if (unevaluated.length === 0) {\n            return undefined;\n        }\n        const errors = [];\n        if (resolvedSchema.unevaluatedProperties === false) {\n            unevaluated.forEach((key) => {\n                errors.push(draft.errors.unevaluatedPropertyError({\n                    pointer: `${pointer}/${key}`,\n                    value: JSON.stringify(value[key]),\n                    schema\n                }));\n            });\n            return errors;\n        }\n        unevaluated.forEach((key) => {\n            if (isObject(resolvedSchema.unevaluatedProperties)) {\n                // note: only key changes\n                const keyErrors = draft.validate(node.next(resolvedSchema.unevaluatedProperties, key), value[key]);\n                errors.push(...keyErrors);\n            }\n        });\n        return errors;\n    },\n    /**\n     * @draft >= 2019-09\n     * Similar to additionalItems, but can \"see\" into subschemas and across references\n     * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.1.3\n     */\n    unevaluatedItems: (node, value) => {\n        var _a;\n        const { draft, schema, pointer } = node;\n        // if not in items, and not matches additionalItems\n        if (!Array.isArray(value) ||\n            value.length === 0 ||\n            schema.unevaluatedItems == null ||\n            schema.unevaluatedItems === true) {\n            return undefined;\n        }\n        // resolve all dynamic schemas\n        const reduction = reduceSchema(draft.resolveRef(node), value);\n        const resolvedSchema = ((_a = reduction.schema) !== null && _a !== void 0 ? _a : reduction);\n        // console.log(\"unevaluatedItems\", JSON.stringify(resolvedSchema, null, 2), value);\n        if (resolvedSchema.unevaluatedItems === true || resolvedSchema.additionalItems === true) {\n            return undefined;\n        }\n        if (isObject(schema.if)) {\n            const nextSchemaNode = { type: \"array\", ...schema.if };\n            if (draft.isValid(value, nextSchemaNode)) {\n                if (Array.isArray(nextSchemaNode.items) &&\n                    nextSchemaNode.items.length === value.length) {\n                    return undefined;\n                }\n            }\n            // need to test remaining items?\n        }\n        if (isObject(resolvedSchema.items)) {\n            const nextSchemaNode = { ...resolvedSchema, unevaluatedItems: undefined };\n            const errors = draft.validate(node.next(nextSchemaNode), value);\n            return errors.map((e) => draft.errors.unevaluatedItemsError({ ...e.data }));\n        }\n        if (Array.isArray(resolvedSchema.items)) {\n            const items = [];\n            for (let i = resolvedSchema.items.length; i < value.length; i += 1) {\n                if (i < resolvedSchema.items.length) {\n                    if (draft.validate(node.next(resolvedSchema.items[i], i), value[i]).length > 0) {\n                        items.push({ index: i, value: value[i] });\n                    }\n                }\n                else {\n                    items.push({ index: i, value: value[i] });\n                }\n            }\n            return items.map((item) => draft.errors.unevaluatedItemsError({\n                pointer: `${pointer}/${item.index}`,\n                value: JSON.stringify(item.value),\n                schema: resolvedSchema.unevaluatedItems\n            }));\n        }\n        if (isObject(resolvedSchema.unevaluatedItems)) {\n            return value.map((item, index) => {\n                if (!draft.isValid(item, resolvedSchema.unevaluatedItems)) {\n                    return draft.errors.unevaluatedItemsError({\n                        pointer: `${pointer}/${index}`,\n                        value: JSON.stringify(item),\n                        schema: resolvedSchema.unevaluatedItems\n                    });\n                }\n            });\n        }\n        const errors = [];\n        value.forEach((item, index) => {\n            errors.push(draft.errors.unevaluatedItemsError({\n                pointer: `${pointer}/${index}`,\n                value: JSON.stringify(item),\n                schema\n            }));\n        });\n        return errors;\n    }\n};\nexport default KeywordValidation;\n", "import addRemoteSchema from \"../addRemoteSchema\";\nimport compileSchema from \"../draft06/compile\";\nimport createSchemaOf from \"../createSchemaOf\";\nimport ERRORS from \"../validation/errors\";\nimport FORMATS from \"../validation/format\";\nimport getChildSchemaSelection from \"../getChildSchemaSelection\";\nimport getSchema from \"../getSchema\";\nimport getTemplate from \"../getTemplate\";\nimport isValid from \"../isValid\";\nimport KEYWORDS from \"./validation/keyword\";\nimport merge from \"../utils/merge\";\nimport resolveRef from \"../resolveRef\";\nimport settings from \"../config/settings\";\nimport step from \"../step\";\nimport TYPES from \"../validation/type\";\nimport validate from \"../validate\";\nimport { createNode } from \"../schemaNode\";\nimport { Draft } from \"../draft\";\nimport { each } from \"../each\";\nimport { eachSchema } from \"../eachSchema\";\nimport { resolveAllOf } from \"../features/allOf\";\nimport { resolveAnyOf } from \"../features/anyOf\";\nimport { resolveOneOf } from \"../features/oneOf\";\nconst draft2019Config = {\n    typeKeywords: {\n        array: [\n            \"allOf\",\n            \"anyOf\",\n            \"contains\",\n            \"enum\",\n            \"if\",\n            \"items\",\n            \"maxItems\",\n            \"minItems\",\n            \"not\",\n            \"oneOf\",\n            \"unevaluatedItems\",\n            \"uniqueItems\"\n        ],\n        boolean: [\"allOf\", \"anyOf\", \"enum\", \"not\", \"oneOf\"],\n        object: [\n            \"additionalProperties\",\n            \"allOf\",\n            \"anyOf\",\n            // \"dependencies\",\n            \"dependentSchemas\",\n            \"dependentRequired\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxProperties\",\n            \"minProperties\",\n            \"not\",\n            \"oneOf\",\n            \"patternProperties\",\n            \"properties\",\n            \"propertyNames\",\n            \"required\",\n            \"unevaluatedProperties\" // 2019-09\n        ],\n        string: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"format\",\n            \"if\",\n            \"maxLength\",\n            \"minLength\",\n            \"not\",\n            \"oneOf\",\n            \"pattern\"\n        ],\n        number: [\n            \"allOf\",\n            \"anyOf\",\n            \"enum\",\n            \"exclusiveMaximum\",\n            \"exclusiveMinimum\",\n            \"format\",\n            \"if\",\n            \"maximum\",\n            \"minimum\",\n            \"multipleOf\",\n            \"not\",\n            \"oneOf\"\n        ],\n        null: [\"allOf\", \"anyOf\", \"enum\", \"format\", \"not\", \"oneOf\"]\n    },\n    validateKeyword: KEYWORDS,\n    validateType: TYPES,\n    validateFormat: FORMATS,\n    errors: ERRORS,\n    createNode,\n    addRemoteSchema,\n    compileSchema,\n    createSchemaOf,\n    each,\n    eachSchema,\n    getChildSchemaSelection,\n    getSchema,\n    getTemplate,\n    isValid,\n    resolveAllOf,\n    resolveAnyOf,\n    resolveOneOf,\n    resolveRef,\n    step,\n    validate,\n    templateDefaultOptions: settings.templateDefaultOptions\n};\nclass Draft2019 extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draft2019Config, config), schema);\n    }\n}\nexport { Draft2019, draft2019Config };\n", "import merge from \"../utils/merge\";\nimport { resolveOneOfFuzzy } from \"../features/oneOf\";\nimport resolveRef from \"../resolveRef\";\nimport { Draft } from \"../draft\";\nimport { draft07Config } from \"../draft07\";\nconst draftJsonEditorConfig = {\n    ...draft07Config,\n    resolveOneOf: resolveOneOfFuzzy,\n    resolveRef\n};\nclass JsonEditor extends Draft {\n    constructor(schema, config = {}) {\n        super(merge(draftJsonEditorConfig, config), schema);\n    }\n}\nexport { JsonEditor, draftJsonEditorConfig };\n", "import { createError, createCustomError } from \"./lib/utils/createCustomError\";\nimport getTypeOf from \"./lib/getTypeOf\";\nimport { resolveOneOf, resolveOneOfFuzzy } from \"./lib/features/oneOf\";\nimport { resolveAllOf } from \"./lib/features/allOf\";\nimport resolveRefStrict from \"./lib/resolveRef.strict\";\nimport resolveRef from \"./lib/resolveRef\";\nimport settings from \"./lib/config/settings\";\nimport strings from \"./lib/config/strings\";\nimport validateAsync from \"./lib/validateAsync\";\nimport { reduceSchema } from \"./lib/reduceSchema\";\nimport { resolveDynamicSchema, isDynamicSchema } from \"./lib/resolveDynamicSchema\";\nimport { mergeSchema } from \"./lib/mergeSchema\";\nimport render from \"./lib/utils/render\";\nimport { Draft } from \"./lib/draft\";\nimport { Draft04, draft04Config } from \"./lib/draft04\";\nimport { Draft06, draft06Config } from \"./lib/draft06\";\nimport { Draft07, draft07Config } from \"./lib/draft07\";\nimport { Draft2019, draft2019Config } from \"./lib/draft2019\";\nimport { JsonEditor, draftJsonEditorConfig } from \"./lib/jsoneditor\";\nimport { isJsonError } from \"./lib/types\";\nimport { isSchemaNode, createNode } from \"./lib/schemaNode\";\nconst config = { strings };\nexport { config, createCustomError, createError, createNode, // v10\nDraft, Draft04, // core implementing draft04 specs\ndraft04Config, // config implementing draft04 specs\nDraft06, // core implementing draft06 specs\ndraft06Config, // config implementing draft06 specs\nDraft07, // core implementing draft07 specs\ndraft07Config, // config implementing draft07 specs\nDraft2019, // core implementing draft2019-09 specs\ndraft2019Config, // config implementing draft2019-09 specs\ndraftJsonEditorConfig, // adjusted config of draft04 to better support the json-editor\ngetTypeOf, // returns the javascript datatype\nisDynamicSchema, // v8\nisJsonError, isSchemaNode, // v10\nJsonEditor, // adjusted core of draft07 to better support the json-editor\nmergeSchema, // v8\nreduceSchema, // v8\nrender, resolveAllOf, resolveDynamicSchema, // v8\nresolveOneOf, resolveOneOfFuzzy, resolveRefStrict, resolveRef, settings, validateAsync // async validation of data by a schema\n };\n"],
  "mappings": "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",
  "names": ["t", "n", "r", "e", "o", "i", "l", "module", "index", "next", "_a", "isMergeableObject", "deepmerge", "next", "equal", "_a", "errors", "omit", "_a", "index", "result", "errors", "omit", "resolveRef", "resolvedSchema", "index", "resolveRef", "errors", "index", "_a", "errors", "finalSchema", "toOmit", "LegacyCache", "_a", "index", "config", "_a", "suffixes", "suffixes", "isObject", "_a", "import_json_pointer", "suffixes", "_a", "parentPointer", "parseIdnEmail", "validUrl", "_a", "import_json_pointer", "gp", "deepmerge", "resolveRef", "index", "next", "_a", "type", "index", "hasOwnProperty", "errors", "schema", "index", "deepEqual", "_a", "import_fast_deep_equal", "equal", "errors", "next", "resolveRef", "config", "addRemoteSchema", "import_json_pointer", "COMPILED", "COMPILED_REF", "GET_REF", "GET_ROOT", "suffixes", "compileSchema", "_a", "parentPointer", "KeywordValidation", "_a", "errors", "keyword_default", "keyword_default", "addRemoteSchema", "compileSchema", "resolveRef", "config", "keyword_default", "addRemoteSchema", "compileSchema", "resolveRef", "config", "_a", "KeywordValidation", "keyword_default", "errors", "index", "keyword_default", "addRemoteSchema", "compileSchema", "resolveRef", "config", "resolveRef", "config"]
}
