import {
  __commonJS,
  __toESM
} from "./chunk-4YJ6HKSX.js";

// ../../node_modules/@sagold/json-pointer/dist/jsonPointer.js
var require_jsonPointer = __commonJS({
  "../../node_modules/@sagold/json-pointer/dist/jsonPointer.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define("jsonPointer", [], t) : "object" == typeof exports ? exports.jsonPointer = t() : e.jsonPointer = t();
    }("undefined" != typeof self ? self : exports, () => (() => {
      "use strict";
      var e = { d: (t2, n2) => {
        for (var r2 in n2) e.o(n2, r2) && !e.o(t2, r2) && Object.defineProperty(t2, r2, { enumerable: true, get: n2[r2] });
      }, o: (e2, t2) => Object.prototype.hasOwnProperty.call(e2, t2), r: (e2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
      } }, t = {};
      function n(e2) {
        return "#" === e2 || "" === e2 || Array.isArray(e2) && 0 === e2.length || false;
      }
      e.r(t), e.d(t, { default: () => _, get: () => s, isRoot: () => n, join: () => P, remove: () => v, removeUndefinedItems: () => m, set: () => g, split: () => f, splitLast: () => O });
      const r = /~1/g, o = /~0/g, i = /(^#?\/?)/g;
      function l(e2) {
        return e2.replace(r, "/").replace(o, "~");
      }
      function u(e2) {
        return l(decodeURIComponent(e2));
      }
      function f(e2) {
        if (null == e2 || "string" != typeof e2 || n(e2)) return Array.isArray(e2) ? e2 : [];
        const t2 = e2.indexOf("#") >= 0 ? u : l, r2 = (e2 = e2.replace(i, "")).split("/");
        for (let e3 = 0, n2 = r2.length; e3 < n2; e3 += 1) r2[e3] = t2(r2[e3]);
        return r2;
      }
      function s(e2, t2, r2 = void 0) {
        if (null == t2 || null == e2) return r2;
        if (n(t2)) return e2;
        const o2 = c(e2, f(t2));
        return void 0 === o2 ? r2 : o2;
      }
      function c(e2, t2) {
        const n2 = t2.shift();
        if (void 0 !== e2) return void 0 !== n2 ? c(e2[n2], t2) : e2;
      }
      const p = /^\[.*\]$/, d = /^\[(.+)\]$/;
      function a(e2, t2) {
        return "__proto__" === e2 || "constructor" == e2 && t2.length > 0 && "prototype" == t2[0];
      }
      function g(e2, t2, n2) {
        if (null == t2) return e2;
        const r2 = f(t2);
        if (0 === r2.length) return e2;
        null == e2 && (e2 = p.test(r2[0]) ? [] : {});
        let o2, i2, l2 = e2;
        for (; r2.length > 1; ) o2 = r2.shift(), i2 = p.test(r2[0]), a(o2, r2) || (l2 = h(l2, o2, i2));
        return o2 = r2.pop(), y(l2, o2, n2), e2;
      }
      function y(e2, t2, n2) {
        let r2;
        const o2 = t2.match(d);
        "[]" === t2 && Array.isArray(e2) ? e2.push(n2) : o2 ? (r2 = o2.pop(), e2[r2] = n2) : e2[t2] = n2;
      }
      function h(e2, t2, n2) {
        if (null != e2[t2]) return e2[t2];
        const r2 = n2 ? [] : {};
        return y(e2, t2, r2), r2;
      }
      function m(e2) {
        let t2 = 0, n2 = 0;
        for (; t2 + n2 < e2.length; ) void 0 === e2[t2 + n2] && (n2 += 1), e2[t2] = e2[t2 + n2], t2 += 1;
        return e2.length = e2.length - n2, e2;
      }
      function v(e2, t2, n2) {
        const r2 = f(t2), o2 = r2.pop(), i2 = s(e2, r2);
        return i2 && delete i2[o2], Array.isArray(i2) && true !== n2 && m(i2), e2;
      }
      const j = /~/g, b = /\//g;
      function A(e2, t2) {
        if (0 === e2.length) return t2 ? "#" : "";
        for (let n2 = 0, r2 = e2.length; n2 < r2; n2 += 1) e2[n2] = e2[n2].replace(j, "~0").replace(b, "~1"), t2 && (e2[n2] = encodeURIComponent(e2[n2]));
        return (t2 ? "#/" : "/") + e2.join("/");
      }
      function P(e2, ...t2) {
        const n2 = [];
        if (Array.isArray(e2)) return A(e2, true === arguments[1]);
        const r2 = arguments[arguments.length - 1], o2 = "boolean" == typeof r2 ? r2 : e2 && "#" === e2[0];
        for (let e3 = 0, t3 = arguments.length; e3 < t3; e3 += 1) n2.push.apply(n2, f(arguments[e3]));
        const i2 = [];
        for (let e3 = 0, t3 = n2.length; e3 < t3; e3 += 1) if (".." === n2[e3]) {
          if (0 === i2.length) return o2 ? "#" : "";
          i2.pop();
        } else i2.push(n2[e3]);
        return A(i2, o2);
      }
      function O(e2) {
        const t2 = f(e2);
        if (0 === t2.length) return "string" == typeof e2 && "#" === e2[0] ? ["#", t2[0]] : ["", void 0];
        if (1 === t2.length) return "#" === e2[0] ? ["#", t2[0]] : ["", t2[0]];
        const n2 = t2.pop();
        return [P(t2, "#" === e2[0]), n2];
      }
      const _ = { get: s, set: g, remove: v, join: P, split: f, splitLast: O, isRoot: n, removeUndefinedItems: m };
      return t;
    })());
  }
});

// ../../node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "../../node_modules/valid-url/index.js"(exports, module) {
    (function(module2) {
      "use strict";
      module2.exports.is_uri = is_iri;
      module2.exports.is_http_uri = is_http_iri;
      module2.exports.is_https_uri = is_https_iri;
      module2.exports.is_web_uri = is_web_iri;
      module2.exports.isUri = is_iri;
      module2.exports.isHttpUri = is_http_iri;
      module2.exports.isHttpsUri = is_https_iri;
      module2.exports.isWebUri = is_web_iri;
      var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path.length >= 0)) return;
        if (authority && authority.length) {
          if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
          if (/^\/\//.test(path)) return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path = "";
        var port = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme) return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https") return;
        } else {
          if (scheme.toLowerCase() != "http") return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module);
  }
});

// ../../node_modules/nearley/lib/nearley.js
var require_nearley = __commonJS({
  "../../node_modules/nearley/lib/nearley.js"(exports, module) {
    (function(root, factory) {
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else {
        root.nearley = factory();
      }
    })(exports, function() {
      function Rule(name, symbols, postprocess) {
        this.id = ++Rule.highestId;
        this.name = name;
        this.symbols = symbols;
        this.postprocess = postprocess;
        return this;
      }
      Rule.highestId = 0;
      Rule.prototype.toString = function(withCursorAt) {
        var symbolSequence = typeof withCursorAt === "undefined" ? this.symbols.map(getSymbolShortDisplay).join(" ") : this.symbols.slice(0, withCursorAt).map(getSymbolShortDisplay).join(" ") + " ● " + this.symbols.slice(withCursorAt).map(getSymbolShortDisplay).join(" ");
        return this.name + " → " + symbolSequence;
      };
      function State(rule, dot, reference, wantedBy) {
        this.rule = rule;
        this.dot = dot;
        this.reference = reference;
        this.data = [];
        this.wantedBy = wantedBy;
        this.isComplete = this.dot === rule.symbols.length;
      }
      State.prototype.toString = function() {
        return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
      };
      State.prototype.nextState = function(child) {
        var state = new State(this.rule, this.dot + 1, this.reference, this.wantedBy);
        state.left = this;
        state.right = child;
        if (state.isComplete) {
          state.data = state.build();
          state.right = void 0;
        }
        return state;
      };
      State.prototype.build = function() {
        var children = [];
        var node = this;
        do {
          children.push(node.right.data);
          node = node.left;
        } while (node.left);
        children.reverse();
        return children;
      };
      State.prototype.finish = function() {
        if (this.rule.postprocess) {
          this.data = this.rule.postprocess(this.data, this.reference, Parser.fail);
        }
      };
      function Column(grammar, index2) {
        this.grammar = grammar;
        this.index = index2;
        this.states = [];
        this.wants = {};
        this.scannable = [];
        this.completed = {};
      }
      Column.prototype.process = function(nextColumn) {
        var states = this.states;
        var wants = this.wants;
        var completed = this.completed;
        for (var w = 0; w < states.length; w++) {
          var state = states[w];
          if (state.isComplete) {
            state.finish();
            if (state.data !== Parser.fail) {
              var wantedBy = state.wantedBy;
              for (var i = wantedBy.length; i--; ) {
                var left = wantedBy[i];
                this.complete(left, state);
              }
              if (state.reference === this.index) {
                var exp = state.rule.name;
                (this.completed[exp] = this.completed[exp] || []).push(state);
              }
            }
          } else {
            var exp = state.rule.symbols[state.dot];
            if (typeof exp !== "string") {
              this.scannable.push(state);
              continue;
            }
            if (wants[exp]) {
              wants[exp].push(state);
              if (completed.hasOwnProperty(exp)) {
                var nulls = completed[exp];
                for (var i = 0; i < nulls.length; i++) {
                  var right = nulls[i];
                  this.complete(state, right);
                }
              }
            } else {
              wants[exp] = [state];
              this.predict(exp);
            }
          }
        }
      };
      Column.prototype.predict = function(exp) {
        var rules = this.grammar.byName[exp] || [];
        for (var i = 0; i < rules.length; i++) {
          var r = rules[i];
          var wantedBy = this.wants[exp];
          var s = new State(r, 0, this.index, wantedBy);
          this.states.push(s);
        }
      };
      Column.prototype.complete = function(left, right) {
        var copy = left.nextState(right);
        this.states.push(copy);
      };
      function Grammar(rules, start) {
        this.rules = rules;
        this.start = start || this.rules[0].name;
        var byName = this.byName = {};
        this.rules.forEach(function(rule) {
          if (!byName.hasOwnProperty(rule.name)) {
            byName[rule.name] = [];
          }
          byName[rule.name].push(rule);
        });
      }
      Grammar.fromCompiled = function(rules, start) {
        var lexer = rules.Lexer;
        if (rules.ParserStart) {
          start = rules.ParserStart;
          rules = rules.ParserRules;
        }
        var rules = rules.map(function(r) {
          return new Rule(r.name, r.symbols, r.postprocess);
        });
        var g = new Grammar(rules, start);
        g.lexer = lexer;
        return g;
      };
      function StreamLexer() {
        this.reset("");
      }
      StreamLexer.prototype.reset = function(data, state) {
        this.buffer = data;
        this.index = 0;
        this.line = state ? state.line : 1;
        this.lastLineBreak = state ? -state.col : 0;
      };
      StreamLexer.prototype.next = function() {
        if (this.index < this.buffer.length) {
          var ch = this.buffer[this.index++];
          if (ch === "\n") {
            this.line += 1;
            this.lastLineBreak = this.index;
          }
          return { value: ch };
        }
      };
      StreamLexer.prototype.save = function() {
        return {
          line: this.line,
          col: this.index - this.lastLineBreak
        };
      };
      StreamLexer.prototype.formatError = function(token, message) {
        var buffer = this.buffer;
        if (typeof buffer === "string") {
          var lines = buffer.split("\n").slice(
            Math.max(0, this.line - 5),
            this.line
          );
          var nextLineBreak = buffer.indexOf("\n", this.index);
          if (nextLineBreak === -1) nextLineBreak = buffer.length;
          var col = this.index - this.lastLineBreak;
          var lastLineDigits = String(this.line).length;
          message += " at line " + this.line + " col " + col + ":\n\n";
          message += lines.map(function(line, i) {
            return pad(this.line - lines.length + i + 1, lastLineDigits) + " " + line;
          }, this).join("\n");
          message += "\n" + pad("", lastLineDigits + col) + "^\n";
          return message;
        } else {
          return message + " at index " + (this.index - 1);
        }
        function pad(n, length) {
          var s = String(n);
          return Array(length - s.length + 1).join(" ") + s;
        }
      };
      function Parser(rules, start, options) {
        if (rules instanceof Grammar) {
          var grammar = rules;
          var options = start;
        } else {
          var grammar = Grammar.fromCompiled(rules, start);
        }
        this.grammar = grammar;
        this.options = {
          keepHistory: false,
          lexer: grammar.lexer || new StreamLexer()
        };
        for (var key in options || {}) {
          this.options[key] = options[key];
        }
        this.lexer = this.options.lexer;
        this.lexerState = void 0;
        var column = new Column(grammar, 0);
        var table = this.table = [column];
        column.wants[grammar.start] = [];
        column.predict(grammar.start);
        column.process();
        this.current = 0;
      }
      Parser.fail = {};
      Parser.prototype.feed = function(chunk) {
        var lexer = this.lexer;
        lexer.reset(chunk, this.lexerState);
        var token;
        while (true) {
          try {
            token = lexer.next();
            if (!token) {
              break;
            }
          } catch (e) {
            var nextColumn = new Column(this.grammar, this.current + 1);
            this.table.push(nextColumn);
            var err = new Error(this.reportLexerError(e));
            err.offset = this.current;
            err.token = e.token;
            throw err;
          }
          var column = this.table[this.current];
          if (!this.options.keepHistory) {
            delete this.table[this.current - 1];
          }
          var n = this.current + 1;
          var nextColumn = new Column(this.grammar, n);
          this.table.push(nextColumn);
          var literal = token.text !== void 0 ? token.text : token.value;
          var value = lexer.constructor === StreamLexer ? token.value : token;
          var scannable = column.scannable;
          for (var w = scannable.length; w--; ) {
            var state = scannable[w];
            var expect = state.rule.symbols[state.dot];
            if (expect.test ? expect.test(value) : expect.type ? expect.type === token.type : expect.literal === literal) {
              var next2 = state.nextState({ data: value, token, isToken: true, reference: n - 1 });
              nextColumn.states.push(next2);
            }
          }
          nextColumn.process();
          if (nextColumn.states.length === 0) {
            var err = new Error(this.reportError(token));
            err.offset = this.current;
            err.token = token;
            throw err;
          }
          if (this.options.keepHistory) {
            column.lexerState = lexer.save();
          }
          this.current++;
        }
        if (column) {
          this.lexerState = lexer.save();
        }
        this.results = this.finish();
        return this;
      };
      Parser.prototype.reportLexerError = function(lexerError) {
        var tokenDisplay, lexerMessage;
        var token = lexerError.token;
        if (token) {
          tokenDisplay = "input " + JSON.stringify(token.text[0]) + " (lexer error)";
          lexerMessage = this.lexer.formatError(token, "Syntax error");
        } else {
          tokenDisplay = "input (lexer error)";
          lexerMessage = lexerError.message;
        }
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportError = function(token) {
        var tokenDisplay = (token.type ? token.type + " token: " : "") + JSON.stringify(token.value !== void 0 ? token.value : token);
        var lexerMessage = this.lexer.formatError(token, "Syntax error");
        return this.reportErrorCommon(lexerMessage, tokenDisplay);
      };
      Parser.prototype.reportErrorCommon = function(lexerMessage, tokenDisplay) {
        var lines = [];
        lines.push(lexerMessage);
        var lastColumnIndex = this.table.length - 2;
        var lastColumn = this.table[lastColumnIndex];
        var expectantStates = lastColumn.states.filter(function(state) {
          var nextSymbol = state.rule.symbols[state.dot];
          return nextSymbol && typeof nextSymbol !== "string";
        });
        if (expectantStates.length === 0) {
          lines.push("Unexpected " + tokenDisplay + ". I did not expect any more input. Here is the state of my parse table:\n");
          this.displayStateStack(lastColumn.states, lines);
        } else {
          lines.push("Unexpected " + tokenDisplay + ". Instead, I was expecting to see one of the following:\n");
          var stateStacks = expectantStates.map(function(state) {
            return this.buildFirstStateStack(state, []) || [state];
          }, this);
          stateStacks.forEach(function(stateStack) {
            var state = stateStack[0];
            var nextSymbol = state.rule.symbols[state.dot];
            var symbolDisplay = this.getSymbolDisplay(nextSymbol);
            lines.push("A " + symbolDisplay + " based on:");
            this.displayStateStack(stateStack, lines);
          }, this);
        }
        lines.push("");
        return lines.join("\n");
      };
      Parser.prototype.displayStateStack = function(stateStack, lines) {
        var lastDisplay;
        var sameDisplayCount = 0;
        for (var j = 0; j < stateStack.length; j++) {
          var state = stateStack[j];
          var display = state.rule.toString(state.dot);
          if (display === lastDisplay) {
            sameDisplayCount++;
          } else {
            if (sameDisplayCount > 0) {
              lines.push("    ^ " + sameDisplayCount + " more lines identical to this");
            }
            sameDisplayCount = 0;
            lines.push("    " + display);
          }
          lastDisplay = display;
        }
      };
      Parser.prototype.getSymbolDisplay = function(symbol) {
        return getSymbolLongDisplay(symbol);
      };
      Parser.prototype.buildFirstStateStack = function(state, visited) {
        if (visited.indexOf(state) !== -1) {
          return null;
        }
        if (state.wantedBy.length === 0) {
          return [state];
        }
        var prevState = state.wantedBy[0];
        var childVisited = [state].concat(visited);
        var childResult = this.buildFirstStateStack(prevState, childVisited);
        if (childResult === null) {
          return null;
        }
        return [state].concat(childResult);
      };
      Parser.prototype.save = function() {
        var column = this.table[this.current];
        column.lexerState = this.lexerState;
        return column;
      };
      Parser.prototype.restore = function(column) {
        var index2 = column.index;
        this.current = index2;
        this.table[index2] = column;
        this.table.splice(index2 + 1);
        this.lexerState = column.lexerState;
        this.results = this.finish();
      };
      Parser.prototype.rewind = function(index2) {
        if (!this.options.keepHistory) {
          throw new Error("set option `keepHistory` to enable rewinding");
        }
        this.restore(this.table[index2]);
      };
      Parser.prototype.finish = function() {
        var considerations = [];
        var start = this.grammar.start;
        var column = this.table[this.table.length - 1];
        column.states.forEach(function(t) {
          if (t.rule.name === start && t.dot === t.rule.symbols.length && t.reference === 0 && t.data !== Parser.fail) {
            considerations.push(t);
          }
        });
        return considerations.map(function(c) {
          return c.data;
        });
      };
      function getSymbolLongDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return "character matching " + symbol;
          } else if (symbol.type) {
            return symbol.type + " token";
          } else if (symbol.test) {
            return "token matching " + String(symbol.test);
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      function getSymbolShortDisplay(symbol) {
        var type = typeof symbol;
        if (type === "string") {
          return symbol;
        } else if (type === "object") {
          if (symbol.literal) {
            return JSON.stringify(symbol.literal);
          } else if (symbol instanceof RegExp) {
            return symbol.toString();
          } else if (symbol.type) {
            return "%" + symbol.type;
          } else if (symbol.test) {
            return "<" + String(symbol.test) + ">";
          } else {
            throw new Error("Unknown symbol type: " + symbol);
          }
        }
      }
      return {
        Parser,
        Grammar,
        Rule
      };
    });
  }
});

// ../../node_modules/smtp-address-parser/dist/lib/grammar.js
var require_grammar = __commonJS({
  "../../node_modules/smtp-address-parser/dist/lib/grammar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function id(d) {
      return d[0];
    }
    var deepFlatten = (arr) => [].concat(...arr.map((v) => Array.isArray(v) ? deepFlatten(v) : v));
    function flat_string(d) {
      if (d) {
        if (Array.isArray(d))
          return deepFlatten(d).join("");
        return d;
      }
      return "";
    }
    var grammar = {
      Lexer: void 0,
      ParserRules: [
        { "name": "Reverse_path", "symbols": ["Path"] },
        { "name": "Reverse_path$string$1", "symbols": [{ "literal": "<" }, { "literal": ">" }], "postprocess": (d) => d.join("") },
        { "name": "Reverse_path", "symbols": ["Reverse_path$string$1"] },
        { "name": "Forward_path$subexpression$1$subexpression$1", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": "@" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path$subexpression$1", "symbols": ["Forward_path$subexpression$1$subexpression$1", "Domain", { "literal": ">" }] },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$1"] },
        { "name": "Forward_path$subexpression$2", "symbols": [{ "literal": "<" }, /[pP]/, /[oO]/, /[sS]/, /[tT]/, /[mM]/, /[aA]/, /[sS]/, /[tT]/, /[eE]/, /[rR]/, { "literal": ">" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "Forward_path", "symbols": ["Forward_path$subexpression$2"] },
        { "name": "Forward_path", "symbols": ["Path"] },
        { "name": "Path$ebnf$1$subexpression$1", "symbols": ["A_d_l", { "literal": ":" }] },
        { "name": "Path$ebnf$1", "symbols": ["Path$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "Path$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "Path", "symbols": [{ "literal": "<" }, "Path$ebnf$1", "Mailbox", { "literal": ">" }] },
        { "name": "A_d_l$ebnf$1", "symbols": [] },
        { "name": "A_d_l$ebnf$1$subexpression$1", "symbols": [{ "literal": "," }, "At_domain"] },
        { "name": "A_d_l$ebnf$1", "symbols": ["A_d_l$ebnf$1", "A_d_l$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "A_d_l", "symbols": ["At_domain", "A_d_l$ebnf$1"] },
        { "name": "At_domain", "symbols": [{ "literal": "@" }, "Domain"] },
        { "name": "Domain$ebnf$1", "symbols": [] },
        { "name": "Domain$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "sub_domain"] },
        { "name": "Domain$ebnf$1", "symbols": ["Domain$ebnf$1", "Domain$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Domain", "symbols": ["sub_domain", "Domain$ebnf$1"] },
        { "name": "sub_domain", "symbols": ["U_label"] },
        { "name": "Let_dig", "symbols": ["ALPHA_DIGIT"], "postprocess": id },
        { "name": "Ldh_str$ebnf$1", "symbols": [] },
        { "name": "Ldh_str$ebnf$1", "symbols": ["Ldh_str$ebnf$1", "ALPHA_DIG_DASH"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Ldh_str", "symbols": ["Ldh_str$ebnf$1", "Let_dig"] },
        { "name": "U_Let_dig", "symbols": ["ALPHA_DIGIT_U"], "postprocess": id },
        { "name": "U_Ldh_str$ebnf$1", "symbols": [] },
        { "name": "U_Ldh_str$ebnf$1", "symbols": ["U_Ldh_str$ebnf$1", "ALPHA_DIG_DASH_U"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "U_Ldh_str", "symbols": ["U_Ldh_str$ebnf$1", "U_Let_dig"] },
        { "name": "U_label$ebnf$1$subexpression$1", "symbols": ["U_Ldh_str"] },
        { "name": "U_label$ebnf$1", "symbols": ["U_label$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "U_label$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "U_label", "symbols": ["U_Let_dig", "U_label$ebnf$1"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv4_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["IPv6_address_literal"] },
        { "name": "address_literal$subexpression$1", "symbols": ["General_address_literal"] },
        { "name": "address_literal", "symbols": [{ "literal": "[" }, "address_literal$subexpression$1", { "literal": "]" }] },
        {
          "name": "non_local_part",
          "symbols": ["Domain"],
          "postprocess": function(d) {
            return { DomainName: flat_string(d[0]) };
          }
        },
        {
          "name": "non_local_part",
          "symbols": ["address_literal"],
          "postprocess": function(d) {
            return { AddressLiteral: flat_string(d[0]) };
          }
        },
        {
          "name": "Mailbox",
          "symbols": ["Local_part", { "literal": "@" }, "non_local_part"],
          "postprocess": function(d) {
            return { localPart: flat_string(d[0]), domainPart: flat_string(d[2]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Dot_string"],
          "postprocess": function(d) {
            return { DotString: flat_string(d[0]) };
          }
        },
        {
          "name": "Local_part",
          "symbols": ["Quoted_string"],
          "postprocess": function(d) {
            return { QuotedString: flat_string(d[0]) };
          }
        },
        { "name": "Dot_string$ebnf$1", "symbols": [] },
        { "name": "Dot_string$ebnf$1$subexpression$1", "symbols": [{ "literal": "." }, "Atom"] },
        { "name": "Dot_string$ebnf$1", "symbols": ["Dot_string$ebnf$1", "Dot_string$ebnf$1$subexpression$1"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Dot_string", "symbols": ["Atom", "Dot_string$ebnf$1"] },
        { "name": "Atom$ebnf$1", "symbols": [/[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/] },
        { "name": "Atom$ebnf$1", "symbols": ["Atom$ebnf$1", /[0-9A-Za-z!#$%&'*+\-/=?^_`{|}~\u0080-\uFFFF/]/], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Atom", "symbols": ["Atom$ebnf$1"] },
        { "name": "Quoted_string$ebnf$1", "symbols": [] },
        { "name": "Quoted_string$ebnf$1", "symbols": ["Quoted_string$ebnf$1", "QcontentSMTP"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "Quoted_string", "symbols": ["DQUOTE", "Quoted_string$ebnf$1", "DQUOTE"] },
        { "name": "QcontentSMTP", "symbols": ["qtextSMTP"] },
        { "name": "QcontentSMTP", "symbols": ["quoted_pairSMTP"] },
        { "name": "quoted_pairSMTP", "symbols": [{ "literal": "\\" }, /[\x20-\x7e]/] },
        { "name": "qtextSMTP", "symbols": [/[\x20-\x21\x23-\x5b\x5d-\x7e\u0080-\uFFFF]/], "postprocess": id },
        { "name": "IPv4_address_literal$macrocall$2", "symbols": [{ "literal": "." }, "Snum"] },
        { "name": "IPv4_address_literal$macrocall$1", "symbols": ["IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2", "IPv4_address_literal$macrocall$2"] },
        { "name": "IPv4_address_literal", "symbols": ["Snum", "IPv4_address_literal$macrocall$1"] },
        { "name": "IPv6_address_literal$subexpression$1", "symbols": [/[iI]/, /[pP]/, /[vV]/, { "literal": "6" }, { "literal": ":" }], "postprocess": function(d) {
          return d.join("");
        } },
        { "name": "IPv6_address_literal", "symbols": ["IPv6_address_literal$subexpression$1", "IPv6_addr"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["dcontent"] },
        { "name": "General_address_literal$ebnf$1", "symbols": ["General_address_literal$ebnf$1", "dcontent"], "postprocess": (d) => d[0].concat([d[1]]) },
        { "name": "General_address_literal", "symbols": ["Standardized_tag", { "literal": ":" }, "General_address_literal$ebnf$1"] },
        { "name": "Standardized_tag", "symbols": ["Ldh_str"] },
        { "name": "dcontent", "symbols": [/[\x21-\x5a\x5e-\x7e]/], "postprocess": id },
        { "name": "Snum", "symbols": ["DIGIT"] },
        { "name": "Snum$subexpression$1", "symbols": [/[1-9]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$1"] },
        { "name": "Snum$subexpression$2", "symbols": [{ "literal": "1" }, "DIGIT", "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$2"] },
        { "name": "Snum$subexpression$3", "symbols": [{ "literal": "2" }, /[0-4]/, "DIGIT"] },
        { "name": "Snum", "symbols": ["Snum$subexpression$3"] },
        { "name": "Snum$subexpression$4", "symbols": [{ "literal": "2" }, { "literal": "5" }, /[0-5]/] },
        { "name": "Snum", "symbols": ["Snum$subexpression$4"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6_comp"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_full"] },
        { "name": "IPv6_addr", "symbols": ["IPv6v4_comp"] },
        { "name": "IPv6_hex", "symbols": ["HEXDIG"] },
        { "name": "IPv6_hex$subexpression$1", "symbols": ["HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$1"] },
        { "name": "IPv6_hex$subexpression$2", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$2"] },
        { "name": "IPv6_hex$subexpression$3", "symbols": ["HEXDIG", "HEXDIG", "HEXDIG", "HEXDIG"] },
        { "name": "IPv6_hex", "symbols": ["IPv6_hex$subexpression$3"] },
        { "name": "IPv6_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_full$macrocall$1", "symbols": ["IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2", "IPv6_full$macrocall$2"] },
        { "name": "IPv6_full", "symbols": ["IPv6_hex", "IPv6_full$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$1", "symbols": ["IPv6_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6_comp$ebnf$2$subexpression$1$macrocall$1"] },
        { "name": "IPv6_comp$ebnf$2", "symbols": ["IPv6_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6_comp", "symbols": ["IPv6_comp$ebnf$1", "IPv6_comp$string$1", "IPv6_comp$ebnf$2"] },
        { "name": "IPv6v4_full$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_full$macrocall$1", "symbols": ["IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2", "IPv6v4_full$macrocall$2"] },
        { "name": "IPv6v4_full", "symbols": ["IPv6_hex", "IPv6v4_full$macrocall$1", { "literal": ":" }, "IPv4_address_literal"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$1$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$1$subexpression$1$macrocall$1"] },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": ["IPv6v4_comp$ebnf$1$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$1", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp$string$1", "symbols": [{ "literal": ":" }, { "literal": ":" }], "postprocess": (d) => d.join("") },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "symbols": [{ "literal": ":" }, "IPv6_hex"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$2"] },
        { "name": "IPv6v4_comp$ebnf$2$subexpression$1", "symbols": ["IPv6_hex", "IPv6v4_comp$ebnf$2$subexpression$1$macrocall$1", { "literal": ":" }] },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": ["IPv6v4_comp$ebnf$2$subexpression$1"], "postprocess": id },
        { "name": "IPv6v4_comp$ebnf$2", "symbols": [], "postprocess": () => null },
        { "name": "IPv6v4_comp", "symbols": ["IPv6v4_comp$ebnf$1", "IPv6v4_comp$string$1", "IPv6v4_comp$ebnf$2", "IPv4_address_literal"] },
        { "name": "DIGIT", "symbols": [/[0-9]/], "postprocess": id },
        { "name": "ALPHA_DIGIT_U", "symbols": [/[0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "ALPHA_DIGIT", "symbols": [/[0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH", "symbols": [/[-0-9A-Za-z]/], "postprocess": id },
        { "name": "ALPHA_DIG_DASH_U", "symbols": [/[-0-9A-Za-z\u0080-\uFFFF]/], "postprocess": id },
        { "name": "HEXDIG", "symbols": [/[0-9A-Fa-f]/], "postprocess": id },
        { "name": "DQUOTE", "symbols": [{ "literal": '"' }], "postprocess": id }
      ],
      ParserStart: "Reverse_path"
    };
    exports.default = grammar;
  }
});

// ../../node_modules/smtp-address-parser/dist/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/smtp-address-parser/dist/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.canonicalize = exports.canonicalize_quoted_string = exports.normalize = exports.normalize_dot_string = exports.parse = void 0;
    var nearley = require_nearley();
    var grammar_1 = __importDefault(require_grammar());
    grammar_1.default.ParserStart = "Mailbox";
    var grammar = nearley.Grammar.fromCompiled(grammar_1.default);
    function parse(address) {
      const parser = new nearley.Parser(grammar);
      parser.feed(address);
      if (parser.results.length !== 1) {
        throw new Error("address parsing failed: ambiguous grammar");
      }
      return parser.results[0];
    }
    exports.parse = parse;
    function normalize_dot_string(dot_string) {
      const tagless = function() {
        const plus_loc = dot_string.indexOf("+");
        if (plus_loc === -1) {
          return dot_string;
        }
        return dot_string.substr(0, plus_loc);
      }();
      const dotless = tagless.replace(/\./g, "");
      return dotless.toLowerCase();
    }
    exports.normalize_dot_string = normalize_dot_string;
    function normalize(address) {
      var _a2, _b;
      const a = parse(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = (_b = a.localPart.QuotedString) !== null && _b !== void 0 ? _b : normalize_dot_string(a.localPart.DotString);
      return `${local}@${domain}`;
    }
    exports.normalize = normalize;
    function canonicalize_quoted_string(quoted_string) {
      const unquoted = quoted_string.substr(1).substr(0, quoted_string.length - 2);
      const unescaped = unquoted.replace(/(?:\\(.))/g, "$1");
      const reescaped = unescaped.replace(/(?:(["\\]))/g, "\\$1");
      return `"${reescaped}"`;
    }
    exports.canonicalize_quoted_string = canonicalize_quoted_string;
    function canonicalize(address) {
      var _a2;
      const a = parse(address);
      const domain = (_a2 = a.domainPart.AddressLiteral) !== null && _a2 !== void 0 ? _a2 : a.domainPart.DomainName.toLowerCase();
      const local = a.localPart.QuotedString ? canonicalize_quoted_string(a.localPart.QuotedString) : a.localPart.DotString;
      return `${local}@${domain}`;
    }
    exports.canonicalize = canonicalize;
  }
});

// ../../node_modules/deepmerge/dist/cjs.js
var require_cjs = __commonJS({
  "../../node_modules/deepmerge/dist/cjs.js"(exports, module) {
    "use strict";
    var isMergeableObject = function isMergeableObject2(value) {
      return isNonNullObject(value) && !isSpecial(value);
    };
    function isNonNullObject(value) {
      return !!value && typeof value === "object";
    }
    function isSpecial(value) {
      var stringValue = Object.prototype.toString.call(value);
      return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value);
    }
    var canUseSymbol = typeof Symbol === "function" && Symbol.for;
    var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
    function isReactElement(value) {
      return value.$$typeof === REACT_ELEMENT_TYPE;
    }
    function emptyTarget(val) {
      return Array.isArray(val) ? [] : {};
    }
    function cloneUnlessOtherwiseSpecified(value, options) {
      return options.clone !== false && options.isMergeableObject(value) ? deepmerge2(emptyTarget(value), value, options) : value;
    }
    function defaultArrayMerge(target, source, options) {
      return target.concat(source).map(function(element) {
        return cloneUnlessOtherwiseSpecified(element, options);
      });
    }
    function getMergeFunction(key, options) {
      if (!options.customMerge) {
        return deepmerge2;
      }
      var customMerge = options.customMerge(key);
      return typeof customMerge === "function" ? customMerge : deepmerge2;
    }
    function getEnumerableOwnPropertySymbols(target) {
      return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
        return Object.propertyIsEnumerable.call(target, symbol);
      }) : [];
    }
    function getKeys(target) {
      return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
    }
    function propertyIsOnObject(object, property) {
      try {
        return property in object;
      } catch (_) {
        return false;
      }
    }
    function propertyIsUnsafe(target, key) {
      return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
    }
    function mergeObject(target, source, options) {
      var destination = {};
      if (options.isMergeableObject(target)) {
        getKeys(target).forEach(function(key) {
          destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
        });
      }
      getKeys(source).forEach(function(key) {
        if (propertyIsUnsafe(target, key)) {
          return;
        }
        if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
          destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
        } else {
          destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
        }
      });
      return destination;
    }
    function deepmerge2(target, source, options) {
      options = options || {};
      options.arrayMerge = options.arrayMerge || defaultArrayMerge;
      options.isMergeableObject = options.isMergeableObject || isMergeableObject;
      options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
      var sourceIsArray = Array.isArray(source);
      var targetIsArray = Array.isArray(target);
      var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
      if (!sourceAndTargetTypesMatch) {
        return cloneUnlessOtherwiseSpecified(source, options);
      } else if (sourceIsArray) {
        return options.arrayMerge(target, source, options);
      } else {
        return mergeObject(target, source, options);
      }
    }
    deepmerge2.all = function deepmergeAll(array, options) {
      if (!Array.isArray(array)) {
        throw new Error("first argument should be an array");
      }
      return array.reduce(function(prev, next2) {
        return deepmerge2(prev, next2, options);
      }, {});
    };
    var deepmerge_1 = deepmerge2;
    module.exports = deepmerge_1;
  }
});

// ../../node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// ../../node_modules/json-schema-library/dist/module/lib/config/strings.js
var strings_default = {
  // validation errors
  AdditionalItemsError: "Array at `{{pointer}}` may not have an additional item `{{key}}`",
  AdditionalPropertiesError: "Additional property `{{property}}` on `{{pointer}}` does not match schema `{{schema}}`",
  AllOfError: "Value `{{value}}` at `{{pointer}}` does not match schema of `{{allOf}}`",
  AnyOfError: "Value `{{value}}` at `{{pointer}}` does not match any schema of `{{anyOf}}`",
  ConstError: "Expected value at `{{pointer}}` to be `{{expected}}`, but value given is `{{value}}`",
  containsAnyError: "The array at `{{pointer}}` must contain at least one item",
  ContainsArrayError: "The property at `{{pointer}}` must not be an array",
  ContainsError: "The array at `{{pointer}}` must contain an element that matches `{{schema}}`",
  ContainsMinError: "The array at `{{pointer}}` contains {{delta}} too few items matching `{{schema}}`",
  ContainsMaxError: "The array at `{{pointer}}` contains {{delta}} too many items matching `{{schema}}`",
  EnumError: "Expected given value `{{value}}` in `{{pointer}}` to be one of `{{values}}`",
  ForbiddenPropertyError: "Property name `{{property}}` at `{{pointer}}` is not allowed",
  FormatDateError: "Value `{{value}}` at `{{pointer}}` is not a valid date",
  FormatDateTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid date-time",
  FormatDurationError: "Value `{{value}}` at `{{pointer}}` is not a valid duration",
  FormatEmailError: "Value `{{value}}` at `{{pointer}}` is not a valid email",
  FormatHostnameError: "Value `{{value}}` at `{{pointer}}` is not a valid hostname",
  FormatIPV4Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv4 address",
  FormatIPV4LeadingZeroError: "IPv4 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatIPV6Error: "Value `{{value}}` at `{{pointer}}` is not a valid IPv6 address",
  FormatIPV6LeadingZeroError: "IPv6 addresses starting with zero are invalid, since they are interpreted as octals",
  FormatJsonPointerError: "Value `{{value}}` at `{{pointer}}` is not a valid json-pointer",
  FormatRegExError: "Value `{{value}}` at `{{pointer}}` is not a valid regular expression",
  FormatTimeError: "Value `{{value}}` at `{{pointer}}` is not a valid time",
  FormatURIError: "Value `{{value}}` at `{{pointer}}` is not a valid uri",
  FormatURIReferenceError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-reference",
  FormatURITemplateError: "Value `{{value}}` at `{{pointer}}` is not a valid uri-template",
  FormatURLError: "Value `{{value}}` at `{{pointer}}` is not a valid url",
  FormatUUIDError: "Value `{{value}}` at `{{pointer}}` is not a valid uuid",
  InvalidDataError: "No value may be specified in `{{pointer}}`",
  InvalidPropertyNameError: "Invalid property name `{{property}}` at `{{pointer}}`",
  MaximumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{maximum}}` at maximum",
  MaxItemsError: "Too many items in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MaxLengthError: "Value `{{pointer}}` should have a maximum length of `{{maxLength}}`, but got `{{length}}`.",
  MaxPropertiesError: "Too many properties in `{{pointer}}`, should be `{{maximum}}` at most, but got `{{length}}`",
  MinimumError: "Value in `{{pointer}}` is `{{length}}`, but should be `{{minimum}}` at minimum",
  MinItemsError: "Too few items in `{{pointer}}`, should be at least `{{minItems}}`, but got `{{length}}`",
  MinItemsOneError: "At least one item is required in `{{pointer}}`",
  MinLengthError: "Value `{{pointer}}` should have a minimum length of `{{minLength}}`, but got `{{length}}`.",
  MinLengthOneError: "A value is required in `{{pointer}}`",
  MinPropertiesError: "Too few properties in `{{pointer}}`, should be at least `{{minimum}}`, but got `{{length}}`",
  MissingDependencyError: "The required propery '{{missingProperty}}' in `{{pointer}}` is missing",
  MissingOneOfPropertyError: "Value at `{{pointer}}` property: `{{property}}`",
  MultipleOfError: "Expected `{{value}}` in `{{pointer}}` to be multiple of `{{multipleOf}}`",
  MultipleOneOfError: "Value `{{value}}` should not match multiple schemas in oneOf `{{matches}}`",
  NoAdditionalPropertiesError: "Additional property `{{property}}` in `{{pointer}}` is not allowed",
  NotError: "Value `{{value}}` at pointer should not match schema `{{not}}`",
  OneOfError: "Value `{{value}}` in `{{pointer}}` does not match any given oneof schema",
  OneOfPropertyError: "Failed finding a matching oneOfProperty schema in `{{pointer}}` where `{{property}}` matches `{{value}}`",
  PatternError: "Value in `{{pointer}}` should match `{{description}}`, but received `{{received}}`",
  PatternPropertiesError: "Property `{{key}}` does not match any patterns in `{{pointer}}`. Valid patterns are: {{patterns}}",
  RequiredPropertyError: "The required property `{{key}}` is missing at `{{pointer}}`",
  SchemaWarning: "Failed retrieving a schema from '{{pointer}}' to key '{{key}}'",
  TypeError: "Expected `{{value}}` ({{received}}) in `{{pointer}}` to be of type `{{expected}}`",
  UndefinedValueError: "Value must not be undefined in `{{pointer}}`",
  UnevaluatedPropertyError: "Invalid unevaluated property `{{pointer}}`",
  UnevaluatedItemsError: "Invalid unevaluated item `{{pointer}}`",
  UniqueItemsError: "Items in array must be unique. Value `{{value}}` in `{{pointer}}` is a duplicate of {{duplicatePointer}}.",
  UnknownPropertyError: "Could not find a valid schema for property `{{pointer}}` within object",
  ValueNotEmptyError: "A value for `{{property}}` is required at `{{pointer}}`"
};

// ../../node_modules/json-schema-library/dist/module/lib/getTypeOf.js
var toString = Object.prototype.toString;
function getTypeOf(value) {
  const type = toString.call(value).match(/\s([^\]]+)\]/).pop().toLowerCase();
  if (type === "file") {
    return "object";
  }
  return type;
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/render.js
var OBJECT_TYPE = "object";
var ARRAY_TYPE = "array";
function render(template, data = {}) {
  return template.replace(/\{\{\w+\}\}/g, (match) => {
    const key = match.replace(/[{}]/g, "");
    const variable = data[key];
    const variableType = getTypeOf(variable);
    if (variableType === OBJECT_TYPE || variableType === ARRAY_TYPE) {
      return JSON.stringify(variable);
    }
    return variable;
  });
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/__.js
function __(keyword, data, fallback = keyword) {
  var _a2;
  const template = (_a2 = strings_default[keyword]) !== null && _a2 !== void 0 ? _a2 : fallback;
  return render(template, data);
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/createCustomError.js
function dashCase(text) {
  return text.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function createError(name, data) {
  return {
    type: "error",
    name,
    code: dashCase(name),
    message: __(name, data),
    data
  };
}
function createCustomError(name) {
  return createError.bind(null, name);
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/flattenArray.js
function flattenArray(list, result = []) {
  for (let i = 0; i < list.length; i += 1) {
    const item = list[i];
    if (Array.isArray(item)) {
      flattenArray(item, result);
    } else {
      result.push(item);
    }
  }
  return result;
}

// ../../node_modules/json-schema-library/dist/module/lib/config/settings.js
var settings_default = {
  DECLARATOR_ONEOF: "oneOfProperty",
  GET_TEMPLATE_RECURSION_LIMIT: 1,
  propertyBlacklist: ["_id"],
  templateDefaultOptions: {
    addOptionalProps: false,
    removeInvalidData: false,
    extendDefaults: true
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/types.js
function isJsonError(error) {
  return (error === null || error === void 0 ? void 0 : error.type) === "error";
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/filter.js
function isPromise(obj) {
  return obj instanceof Promise;
}
function errorOrPromise(error) {
  return isJsonError(error) || isPromise(error);
}
function errorsOnly(error) {
  return isJsonError(error);
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/isObject.js
function isObject(v) {
  return getTypeOf(v) === "object";
}

// ../../node_modules/json-schema-library/dist/module/lib/features/oneOf.js
var { DECLARATOR_ONEOF } = settings_default;
function resolveOneOf(node, data) {
  const { schema, draft, pointer } = node;
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors3 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = node.next(schema.oneOf[i]).resolveRef();
      const resultNode = draft.step(oneNode, oneOfProperty, data);
      if (isJsonError(resultNode)) {
        return resultNode;
      }
      let result = flattenArray(draft.validate(resultNode, oneOfValue));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors3.push(...result);
      } else {
        return resultNode.next(oneNode.schema);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors3
    });
  }
  const matches = [];
  const errors2 = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
    let result = flattenArray(draft.validate(oneNode, data));
    result = result.filter(errorOrPromise);
    if (result.length > 0) {
      errors2.push(...result);
    } else {
      matches.push({ index: i, schema: oneNode.schema });
    }
  }
  if (matches.length === 1) {
    return node.next(matches[0].schema);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({
      value: data,
      pointer,
      schema,
      matches
    });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf,
    errors: errors2
  });
}
function fuzzyObjectValue(node, data) {
  const { draft, schema, pointer } = node;
  if (data == null || schema.properties == null) {
    return -1;
  }
  let value = 0;
  const keys = Object.keys(schema.properties);
  for (let i = 0; i < keys.length; i += 1) {
    const key = keys[i];
    if (data[key]) {
      if (draft.isValid(data[key], schema.properties[key], pointer)) {
        value += 1;
      }
    }
  }
  return value;
}
function resolveOneOfFuzzy(node, data) {
  const { schema, pointer, draft } = node;
  if (!Array.isArray(schema.oneOf)) {
    throw new Error("not a oneof schema");
    return node;
  }
  if (data != null && schema[DECLARATOR_ONEOF]) {
    const errors2 = [];
    const oneOfProperty = schema[DECLARATOR_ONEOF];
    const oneOfValue = data[schema[DECLARATOR_ONEOF]];
    if (oneOfValue === void 0) {
      return draft.errors.missingOneOfPropertyError({
        property: oneOfProperty,
        pointer,
        schema,
        value: data
      });
    }
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
      const resultNode = draft.step(oneNode, oneOfProperty, data);
      if (isJsonError(resultNode)) {
        return resultNode;
      }
      let result = flattenArray(draft.validate(resultNode, oneOfValue));
      result = result.filter(errorOrPromise);
      if (result.length > 0) {
        errors2.push(...result);
      } else {
        return resultNode.next(oneNode.schema);
      }
    }
    return draft.errors.oneOfPropertyError({
      property: oneOfProperty,
      value: oneOfValue,
      pointer,
      schema,
      errors: errors2
    });
  }
  const matches = [];
  for (let i = 0; i < schema.oneOf.length; i += 1) {
    const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
    const one = oneNode.schema;
    if (draft.isValid(data, one, pointer)) {
      matches.push({ schema: one, index: i });
    }
  }
  if (matches.length === 1) {
    return node.next(matches[0].schema);
  }
  if (isObject(data)) {
    let schemaOfItem;
    let schemaOfIndex = -1;
    let fuzzyGreatest = 0;
    for (let i = 0; i < schema.oneOf.length; i += 1) {
      const oneNode = draft.resolveRef(node.next(schema.oneOf[i]));
      const fuzzyValue = fuzzyObjectValue(oneNode, data);
      if (fuzzyGreatest < fuzzyValue) {
        fuzzyGreatest = fuzzyValue;
        schemaOfItem = oneNode.schema;
        schemaOfIndex = i;
      }
    }
    if (schemaOfItem === void 0) {
      return draft.errors.oneOfError({
        value: JSON.stringify(data),
        pointer,
        schema,
        oneOf: schema.oneOf
      });
    }
    return node.next(schemaOfItem);
  }
  if (matches.length > 1) {
    return draft.errors.multipleOneOfError({ matches, pointer, schema, value: data });
  }
  return draft.errors.oneOfError({
    value: JSON.stringify(data),
    pointer,
    schema,
    oneOf: schema.oneOf
  });
}
var validateOneOf = (node, value) => {
  if (Array.isArray(node.schema.oneOf)) {
    const nodeOrError = node.draft.resolveOneOf(node, value);
    if (isJsonError(nodeOrError)) {
      return nodeOrError;
    }
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/mergeSchema.js
function mergeSchema(a, b, ...omit2) {
  if ((b === null || b === void 0 ? void 0 : b.type) === "error") {
    return b;
  } else if ((a === null || a === void 0 ? void 0 : a.type) === "error") {
    return a;
  }
  const aType = getTypeOf(a);
  const bType = getTypeOf(b);
  if (aType !== bType) {
    return a;
  }
  const schema = mergeSchema2(a, b);
  for (let i = 0; i < omit2.length; i += 1) {
    delete schema[omit2[i]];
  }
  return schema;
}
function mergeSchema2(a, b, property) {
  var _a2;
  if (isObject(a) && isObject(b)) {
    const newObject = {};
    [...Object.keys(a), ...Object.keys(b)].filter((item, index2, array) => array.indexOf(item) === index2).forEach((key) => newObject[key] = mergeSchema2(a[key], b[key], key));
    return newObject;
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (property === "required") {
      return a.concat(b).filter((item, index2, array) => array.indexOf(item) === index2);
    }
    if (property === "items") {
      const result2 = [];
      for (let i = 0; i < b.length; i += 1) {
        if (isObject(a[i]) && isObject(b[i]) && a[i].type === b[i].type) {
          result2[i] = mergeSchema2(a[i], b[i]);
        } else {
          result2.push((_a2 = b[i]) !== null && _a2 !== void 0 ? _a2 : a[i]);
        }
      }
      return result2;
    }
    const result = [];
    const append = [];
    for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
      if (isObject(a[i]) && isObject(b[i])) {
        result[i] = mergeSchema2(a[i], b[i]);
      } else {
        if (a[i] !== void 0 && b[i] !== void 0) {
          result[i] = a[i];
          append.push(b[i]);
        } else if (a[i] !== void 0) {
          result[i] = a[i];
        } else if (b[i] !== void 0) {
          append.push(b[i]);
        }
      }
    }
    return [...result, ...append].filter((item, index2, array) => array.indexOf(item) === index2);
  }
  if (Array.isArray(b)) {
    return b;
  }
  if (Array.isArray(a)) {
    return a;
  }
  if (b !== void 0) {
    return b;
  }
  return a;
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/omit.js
function omit(object, ...keysToOmit) {
  const result = {};
  Object.keys(object).forEach((key) => {
    if (!keysToOmit.includes(key)) {
      result[key] = object[key];
    }
  });
  return result;
}

// ../../node_modules/json-schema-library/dist/module/lib/features/if.js
function resolveIfSchema(node, data) {
  if (node.schema.if == null) {
    return void 0;
  }
  if (node.schema.if === false) {
    return node.next(node.schema.else);
  }
  if (node.schema.if && (node.schema.then || node.schema.else)) {
    const ifNode = node.draft.resolveRef(node.next(node.schema.if));
    const ifErrors = node.draft.validate(ifNode, data);
    if (ifErrors.length === 0 && node.schema.then) {
      const thenNode = node.next(node.schema.then);
      return node.draft.resolveRef(thenNode);
    }
    if (ifErrors.length !== 0 && node.schema.else) {
      const elseNode = node.next(node.schema.else);
      return node.draft.resolveRef(elseNode);
    }
  }
}
var validateIf = (node, value) => {
  const resolvedNode = resolveIfSchema(node, value);
  if (resolvedNode) {
    return node.draft.validate(resolvedNode, value);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/utils/shallowCloneSchema.js
function shallowCloneSchemaNode(node) {
  return { ...node };
}

// ../../node_modules/json-schema-library/dist/module/lib/features/allOf.js
function resolveSchema(node, data) {
  const ifSchema = resolveIfSchema(node, data);
  if (ifSchema) {
    return ifSchema;
  }
  const schema = shallowCloneSchemaNode(node.schema);
  return node.next(omit(schema, "if", "then", "else"));
}
function resolveAllOf(node, data) {
  const { schema } = node;
  let mergedSchema = shallowCloneSchemaNode(schema);
  for (let i = 0; i < schema.allOf.length; i += 1) {
    const allOfNode = node.next(schema.allOf[i]).resolveRef();
    const allOfSchema = resolveSchema(allOfNode, data).schema;
    mergedSchema = mergeSchema(mergedSchema, allOfSchema);
  }
  delete mergedSchema.allOf;
  return node.next(mergedSchema);
}
function mergeAllOfSchema(draft, schema) {
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  let resolvedSchema = {};
  allOf.forEach((subschema) => {
    if (subschema == null) {
      return;
    }
    const subSchemaNode = draft.createNode(subschema).resolveRef();
    resolvedSchema = mergeSchema(resolvedSchema, subSchemaNode.schema);
  });
  return resolvedSchema;
}
var validateAllOf = (node, value) => {
  const { draft, schema } = node;
  const { allOf } = schema;
  if (!Array.isArray(allOf) || allOf.length === 0) {
    return;
  }
  const errors2 = [];
  schema.allOf.forEach((subSchema) => {
    errors2.push(...draft.validate(node.next(subSchema), value));
  });
  return errors2;
};

// ../../node_modules/json-schema-library/dist/module/lib/schemaNode.js
function merge(schema, ...omit2) {
  if (schema == null) {
    throw new Error(`undefined schema`);
  }
  const node = this;
  const mergedSchema = mergeSchema(node.schema, schema, ...omit2);
  return { ...node, schema: mergedSchema, path: [...node.path, node.schema] };
}
function resolveRef() {
  const node = this;
  return node.draft.resolveRef(node);
}
function next(schema, key) {
  if (isJsonError(schema)) {
    return schema;
  }
  if (schema == null) {
    throw new Error(`undefined schema`);
  }
  if (!isObject(schema) && getTypeOf(schema) !== "boolean") {
    throw new Error(`bad schema type ${getTypeOf(schema)}`);
  }
  const node = this;
  return {
    ...node,
    pointer: key ? `${node.pointer}/${key}` : node.pointer,
    schema,
    path: [...node.path, node.schema]
  };
}
function isSchemaNode(value) {
  return isObject(value) && value.next && value.path && value.draft;
}
function createNode(draft, schema, pointer = "#") {
  return { draft, pointer, schema, path: [], next, merge, resolveRef };
}

// ../../node_modules/json-schema-library/dist/module/lib/resolveRef.strict.js
function resolveRef2(node) {
  if (!isSchemaNode(node)) {
    throw new Error("schema node expected");
  }
  if (node.schema == null || node.schema.$ref == null) {
    return node;
  }
  if (node.schema.getRoot) {
    const resolvedSchema2 = node.schema.getRoot().getRef(node.schema);
    return node.next(resolvedSchema2);
  }
  const resolvedSchema = node.draft.rootSchema.getRef(node.schema);
  return node.next(resolvedSchema);
}

// ../../node_modules/json-schema-library/dist/module/lib/resolveRef.js
function resolveRecursiveRef(node) {
  const history = node.path;
  let startIndex = 0;
  for (let i = history.length - 1; i >= 0; i--) {
    if (history[i].$id && /^https?:\/\//.test(history[i].$id) && history[i].$recursiveAnchor !== true) {
      startIndex = i;
      break;
    }
  }
  const firstAnchor = history.find((s, index2) => index2 >= startIndex && s.$recursiveAnchor === true);
  if (firstAnchor) {
    return node.next(firstAnchor);
  }
  for (let i = history.length - 1; i >= 0; i--) {
    if (history[i].$id) {
      return node.next(history[i]);
    }
  }
  return node.next(node.draft.rootSchema);
}
function resolveRef3(node) {
  if (!isSchemaNode(node)) {
    throw new Error("expected node");
  }
  if (node.schema == null) {
    return node;
  }
  if (node.schema.$recursiveRef) {
    return resolveRef3(resolveRecursiveRef(node));
  }
  if (node.schema.$ref == null) {
    return node;
  }
  const resolvedSchema = node.draft.rootSchema.getRef(node.schema);
  if (resolvedSchema === false) {
    return node.next(resolvedSchema);
  }
  return node.merge(resolvedSchema, "$ref");
}

// ../../node_modules/json-schema-library/dist/module/lib/validateAsync.js
function createErrorNotification(onError) {
  return function notifyError(error) {
    if (Array.isArray(error)) {
      error = flattenArray(error);
      error.forEach(notifyError);
      return error;
    }
    if (isJsonError(error)) {
      onError(error);
    }
    return error;
  };
}
function validateAsync(draft, value, options) {
  const { schema, pointer, onError } = { schema: draft.rootSchema, pointer: "#", ...options };
  let errors2 = draft.validate(draft.createNode(schema, pointer), value);
  if (onError) {
    errors2 = flattenArray(errors2);
    const notifyError = createErrorNotification(onError);
    for (let i = 0; i < errors2.length; i += 1) {
      const error = errors2[i];
      if (error instanceof Promise) {
        error.then(notifyError);
      } else if (isJsonError(error)) {
        onError(error);
      }
    }
  }
  return Promise.all(errors2).then(flattenArray).then((resolvedErrors) => resolvedErrors.filter(errorsOnly)).catch((e) => {
    console.log("Failed resolving promises", e.message);
    console.log(e.stack);
    throw e;
  });
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/uniqueItems.js
function uniqueItems(list) {
  return list.filter((item, index2) => list.indexOf(item) === index2);
}

// ../../node_modules/json-schema-library/dist/module/lib/features/dependencies.js
function resolveDependencies(node, data) {
  var _a2;
  const { schema } = node;
  const dependencies = (_a2 = schema.dependencies) !== null && _a2 !== void 0 ? _a2 : schema.dependentSchemas;
  if (!isObject(dependencies) || !isObject(data)) {
    return;
  }
  let updated = false;
  let resolvedSchema = { required: [] };
  Object.keys(dependencies).forEach((prop) => {
    var _a3, _b;
    if (data[prop] == null && !(((_a3 = schema.required) === null || _a3 === void 0 ? void 0 : _a3.includes(prop)) || ((_b = resolvedSchema.required) === null || _b === void 0 ? void 0 : _b.includes(prop)))) {
      return;
    }
    const dependency = dependencies[prop];
    if (Array.isArray(dependency)) {
      updated = true;
      resolvedSchema.required.push(...dependency);
      return;
    }
    if (isObject(dependency)) {
      updated = true;
      const dNode = node.next(dependency).resolveRef();
      resolvedSchema = mergeSchema(resolvedSchema, dNode.schema);
      return;
    }
  });
  if (updated) {
    resolvedSchema.required = uniqueItems(resolvedSchema.required);
    return resolvedSchema;
  }
}
var validateDependentRequired = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependentRequired = schema.dependentRequired;
  if (!isObject(dependentRequired)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    const dependencies = dependentRequired[property];
    if (dependencies === true) {
      return;
    }
    if (dependencies === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    if (!Array.isArray(dependencies)) {
      return;
    }
    for (let i = 0, l = dependencies.length; i < l; i += 1) {
      if (value[dependencies[i]] === void 0) {
        errors2.push(draft.errors.missingDependencyError({ missingProperty: dependencies[i], pointer, schema, value }));
      }
    }
  });
  return errors2;
};
var validateDependentSchemas = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependentSchemas = schema.dependentSchemas;
  if (!isObject(dependentSchemas)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    const dependencies = dependentSchemas[property];
    if (dependencies === true) {
      return;
    }
    if (dependencies === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    if (!isObject(dependencies)) {
      return;
    }
    draft.validate(node.next(dependencies), value).map((error) => errors2.push(error));
  });
  return errors2;
};
var validateDependencies = (node, value) => {
  const { draft, schema, pointer } = node;
  const dependencies = schema.dependencies;
  if (!isObject(dependencies)) {
    return void 0;
  }
  const errors2 = [];
  Object.keys(value).forEach((property) => {
    if (dependencies[property] === void 0) {
      return;
    }
    if (dependencies[property] === true) {
      return;
    }
    if (dependencies[property] === false) {
      errors2.push(draft.errors.missingDependencyError({ pointer, schema, value }));
      return;
    }
    let dependencyErrors;
    const type = getTypeOf(dependencies[property]);
    const propertyValue = dependencies[property];
    if (Array.isArray(propertyValue)) {
      dependencyErrors = propertyValue.filter((dependency) => value[dependency] === void 0).map((missingProperty) => draft.errors.missingDependencyError({ missingProperty, pointer, schema, value }));
    } else if (type === "object") {
      dependencyErrors = draft.validate(node.next(dependencies[property]), value);
    } else {
      throw new Error(`Invalid dependency definition for ${pointer}/${property}. Must be string[] or schema`);
    }
    errors2.push(...dependencyErrors);
  });
  return errors2.length > 0 ? errors2 : void 0;
};

// ../../node_modules/json-schema-library/dist/module/lib/features/anyOf.js
function mergeValidAnyOfSchema(node, data) {
  const { draft, schema } = node;
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return;
  }
  let resolvedSchema;
  schema.anyOf.forEach((anySchema) => {
    const anyNode = draft.resolveRef(node.next(anySchema));
    if (draft.validate(anyNode, data).length === 0) {
      resolvedSchema = resolvedSchema ? mergeSchema(resolvedSchema, anyNode.schema) : anyNode.schema;
    }
  });
  if (resolvedSchema) {
    return node.next(resolvedSchema);
  }
}
function resolveAnyOf(node, data) {
  const { anyOf } = node.schema;
  if (!Array.isArray(anyOf) || anyOf.length === 0) {
    return node;
  }
  const resolvedNode = mergeValidAnyOfSchema(node, data);
  if (resolvedNode) {
    const { pointer, schema } = node;
    return node.draft.errors.anyOfError({ pointer, schema, value: data, anyOf: JSON.stringify(anyOf) });
  }
  return node.merge(resolvedNode.schema, "anyOf");
}
var validateAnyOf = (node, value) => {
  const { draft, schema, pointer } = node;
  if (!Array.isArray(schema.anyOf) || schema.anyOf.length === 0) {
    return void 0;
  }
  for (let i = 0; i < schema.anyOf.length; i += 1) {
    const nextNode = draft.resolveRef(node.next(schema.anyOf[i]));
    if (draft.validate(nextNode, value).length === 0) {
      return void 0;
    }
  }
  return draft.errors.anyOfError({ pointer, schema, value, anyOf: schema.anyOf });
};

// ../../node_modules/json-schema-library/dist/module/lib/resolveDynamicSchema.js
var toOmit = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
var dynamicProperties = ["allOf", "anyOf", "oneOf", "dependencies", "if"];
function isDynamicSchema(schema) {
  const givenProps = Object.keys(schema);
  return dynamicProperties.findIndex((prop) => givenProps.includes(prop)) !== -1;
}
function resolveDynamicSchema(schemaNode, data) {
  let resolvedSchema;
  let error;
  const node = schemaNode.draft.resolveRef(schemaNode);
  const { draft } = node;
  const schema = isSchemaNode(node) ? node.schema : node;
  if (schema.oneOf) {
    const oneOfSchema = resolveOneOfFuzzy(node, data);
    if (isJsonError(oneOfSchema)) {
      error = oneOfSchema;
    } else if (oneOfSchema) {
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, oneOfSchema.schema);
    }
  }
  if (Array.isArray(schema.allOf)) {
    const allOf = schema.allOf.map((s) => {
      if (isDynamicSchema(s)) {
        const result = resolveDynamicSchema(node.next(s), data);
        if (result == null || isJsonError(result)) {
          return result;
        }
        const finalSchema2 = mergeSchema(s, result.schema);
        return omit(finalSchema2, ...toOmit);
      }
      return s;
    });
    if (allOf.length > 0) {
      const allOfSchema = mergeAllOfSchema(draft, { allOf });
      resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, allOfSchema);
    }
  }
  const anyNode = mergeValidAnyOfSchema(node, data);
  if (anyNode && anyNode.schema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, anyNode.schema);
  }
  const dependenciesSchema = resolveDependencies(node, data);
  if (dependenciesSchema) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, dependenciesSchema);
  }
  const ifNodeResolved = resolveIfSchema(node, data);
  if (isSchemaNode(ifNodeResolved)) {
    resolvedSchema = mergeSchema(resolvedSchema !== null && resolvedSchema !== void 0 ? resolvedSchema : {}, ifNodeResolved.schema);
  }
  if (resolvedSchema == null) {
    return error;
  }
  if (isJsonError(resolvedSchema)) {
    return resolvedSchema;
  }
  const nestedSchema = resolveDynamicSchema(node.next(resolvedSchema), data);
  if (isSchemaNode(nestedSchema)) {
    resolvedSchema = mergeSchema(resolvedSchema, nestedSchema.schema);
  }
  const finalSchema = omit(resolvedSchema, ...toOmit);
  return node.next(finalSchema);
}

// ../../node_modules/json-schema-library/dist/module/lib/reduceSchema.js
var toOmit2 = ["allOf", "anyOf", "oneOf", "dependencies", "if", "then", "else"];
function reduceSchema(node, data) {
  const resolvedSchema = resolveDynamicSchema(node, data);
  if (isSchemaNode(resolvedSchema)) {
    return node.merge(resolvedSchema.schema, ...toOmit2);
  }
  if (resolvedSchema) {
    return resolvedSchema;
  }
  return node;
}

// ../../node_modules/fast-copy/dist/esm/index.mjs
var toStringFunction = Function.prototype.toString;
var create = Object.create;
var toStringObject = Object.prototype.toString;
var LegacyCache = (
  /** @class */
  function() {
    function LegacyCache2() {
      this._keys = [];
      this._values = [];
    }
    LegacyCache2.prototype.has = function(key) {
      return !!~this._keys.indexOf(key);
    };
    LegacyCache2.prototype.get = function(key) {
      return this._values[this._keys.indexOf(key)];
    };
    LegacyCache2.prototype.set = function(key, value) {
      this._keys.push(key);
      this._values.push(value);
    };
    return LegacyCache2;
  }()
);
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
var createCache = typeof WeakMap !== "undefined" ? createCacheModern : createCacheLegacy;
function getCleanClone(prototype) {
  if (!prototype) {
    return create(null);
  }
  var Constructor = prototype.constructor;
  if (Constructor === Object) {
    return prototype === Object.prototype ? {} : create(prototype);
  }
  if (Constructor && ~toStringFunction.call(Constructor).indexOf("[native code]")) {
    try {
      return new Constructor();
    } catch (_a2) {
    }
  }
  return create(prototype);
}
function getRegExpFlagsLegacy(regExp) {
  var flags = "";
  if (regExp.global) {
    flags += "g";
  }
  if (regExp.ignoreCase) {
    flags += "i";
  }
  if (regExp.multiline) {
    flags += "m";
  }
  if (regExp.unicode) {
    flags += "u";
  }
  if (regExp.sticky) {
    flags += "y";
  }
  return flags;
}
function getRegExpFlagsModern(regExp) {
  return regExp.flags;
}
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(value) {
  var type = toStringObject.call(value);
  return type.substring(8, type.length - 1);
}
function getTagModern(value) {
  return value[Symbol.toStringTag] || getTagLegacy(value);
}
var getTag = typeof Symbol !== "undefined" ? getTagModern : getTagLegacy;
var defineProperty = Object.defineProperty;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var _a = Object.prototype;
var hasOwnProperty = _a.hasOwnProperty;
var propertyIsEnumerable = _a.propertyIsEnumerable;
var SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === "function";
function getStrictPropertiesModern(object) {
  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));
}
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
function copyOwnPropertiesStrict(value, clone, state) {
  var properties = getStrictProperties(value);
  for (var index2 = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index2 < length_1; ++index2) {
    property = properties[index2];
    if (property === "callee" || property === "caller") {
      continue;
    }
    descriptor = getOwnPropertyDescriptor(value, property);
    if (!descriptor) {
      clone[property] = state.copier(value[property], state);
      continue;
    }
    if (!descriptor.get && !descriptor.set) {
      descriptor.value = state.copier(descriptor.value, state);
    }
    try {
      defineProperty(clone, property, descriptor);
    } catch (error) {
      clone[property] = descriptor.value;
    }
  }
  return clone;
}
function copyArrayLoose(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  for (var index2 = 0, length_2 = array.length; index2 < length_2; ++index2) {
    clone[index2] = state.copier(array[index2], state);
  }
  return clone;
}
function copyArrayStrict(array, state) {
  var clone = new state.Constructor();
  state.cache.set(array, clone);
  return copyOwnPropertiesStrict(array, clone, state);
}
function copyArrayBuffer(arrayBuffer, _state) {
  return arrayBuffer.slice(0);
}
function copyBlob(blob, _state) {
  return blob.slice(0, blob.size, blob.type);
}
function copyDataView(dataView, state) {
  return new state.Constructor(copyArrayBuffer(dataView.buffer));
}
function copyDate(date, state) {
  return new state.Constructor(date.getTime());
}
function copyMapLoose(map, state) {
  var clone = new state.Constructor();
  state.cache.set(map, clone);
  map.forEach(function(value, key) {
    clone.set(key, state.copier(value, state));
  });
  return clone;
}
function copyMapStrict(map, state) {
  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);
}
function copyObjectLooseLegacy(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  return clone;
}
function copyObjectLooseModern(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  for (var key in object) {
    if (hasOwnProperty.call(object, key)) {
      clone[key] = state.copier(object[key], state);
    }
  }
  var symbols = getOwnPropertySymbols(object);
  for (var index2 = 0, length_3 = symbols.length, symbol = void 0; index2 < length_3; ++index2) {
    symbol = symbols[index2];
    if (propertyIsEnumerable.call(object, symbol)) {
      clone[symbol] = state.copier(object[symbol], state);
    }
  }
  return clone;
}
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
function copyObjectStrict(object, state) {
  var clone = getCleanClone(state.prototype);
  state.cache.set(object, clone);
  return copyOwnPropertiesStrict(object, clone, state);
}
function copyPrimitiveWrapper(primitiveObject, state) {
  return new state.Constructor(primitiveObject.valueOf());
}
function copyRegExp(regExp, state) {
  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));
  clone.lastIndex = regExp.lastIndex;
  return clone;
}
function copySelf(value, _state) {
  return value;
}
function copySetLoose(set, state) {
  var clone = new state.Constructor();
  state.cache.set(set, clone);
  set.forEach(function(value) {
    clone.add(state.copier(value, state));
  });
  return clone;
}
function copySetStrict(set, state) {
  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);
}
var isArray = Array.isArray;
var assign = Object.assign;
var getPrototypeOf = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
var DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
};
var DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
function getTagSpecificCopiers(options) {
  return {
    Arguments: options.object,
    Array: options.array,
    ArrayBuffer: options.arrayBuffer,
    Blob: options.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: options.dataView,
    Date: options.date,
    Error: options.error,
    Float32Array: options.arrayBuffer,
    Float64Array: options.arrayBuffer,
    Int8Array: options.arrayBuffer,
    Int16Array: options.arrayBuffer,
    Int32Array: options.arrayBuffer,
    Map: options.map,
    Number: copyPrimitiveWrapper,
    Object: options.object,
    Promise: copySelf,
    RegExp: options.regExp,
    Set: options.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: options.arrayBuffer,
    Uint8ClampedArray: options.arrayBuffer,
    Uint16Array: options.arrayBuffer,
    Uint32Array: options.arrayBuffer,
    Uint64Array: options.arrayBuffer
  };
}
function createCopier(options) {
  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);
  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);
  var array = tagSpecificCopiers.Array, object = tagSpecificCopiers.Object;
  function copier(value, state) {
    state.prototype = state.Constructor = void 0;
    if (!value || typeof value !== "object") {
      return value;
    }
    if (state.cache.has(value)) {
      return state.cache.get(value);
    }
    state.prototype = getPrototypeOf(value);
    state.Constructor = state.prototype && state.prototype.constructor;
    if (!state.Constructor || state.Constructor === Object) {
      return object(value, state);
    }
    if (isArray(value)) {
      return array(value, state);
    }
    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];
    if (tagSpecificCopier) {
      return tagSpecificCopier(value, state);
    }
    return typeof value.then === "function" ? value : object(value, state);
  }
  return function copy(value) {
    return copier(value, {
      Constructor: void 0,
      cache: createCache(),
      copier,
      prototype: void 0
    });
  };
}
function createStrictCopier(options) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));
}
var copyStrict = createStrictCopier({});
var index = createCopier({});

// ../../node_modules/json-schema-library/dist/module/lib/utils/copy.js
var copy_default = index;

// ../../node_modules/json-schema-library/dist/module/lib/draft/index.js
var Draft = class {
  constructor(config2, schema) {
    this.remotes = {};
    this.errors = {};
    this.typeKeywords = {};
    this.validateKeyword = {};
    this.validateType = {};
    this.validateFormat = {};
    this.config = config2;
    this.typeKeywords = copy_default(config2.typeKeywords);
    this.validateKeyword = Object.assign({}, config2.validateKeyword);
    this.validateType = Object.assign({}, config2.validateType);
    this.validateFormat = Object.assign({}, config2.validateFormat);
    this.errors = Object.assign({}, config2.errors);
    this.setSchema(schema);
  }
  get rootSchema() {
    return this.__rootSchema;
  }
  set rootSchema(rootSchema) {
    if (rootSchema == null) {
      return;
    }
    this.__rootSchema = this.config.compileSchema(this, rootSchema);
  }
  /**
   * register a json-schema to be referenced from another json-schema
   * @param url - base-url of json-schema (aka id)
   * @param schema - json-schema root
   */
  addRemoteSchema(url, schema) {
    this.config.addRemoteSchema(this, url, schema);
  }
  compileSchema(schema) {
    var _a2;
    return this.config.compileSchema(this, schema, (_a2 = this.rootSchema) !== null && _a2 !== void 0 ? _a2 : schema);
  }
  createSchemaOf(data) {
    return this.config.createSchemaOf(data);
  }
  /**
   * Iterates over data, retrieving its schema
   *
   * @param data - the data to iterate
   * @param callback - will be called with (schema, data, pointer) on each item
   * @param [schema] - the schema matching the data. Defaults to rootSchema
   * @param [pointer] - pointer to current data. Default to rootPointer
   */
  each(data, callback, schema, pointer) {
    const node = this.createNode(schema !== null && schema !== void 0 ? schema : this.rootSchema, pointer);
    return this.config.each(node, data, callback);
  }
  eachSchema(callback, schema = this.rootSchema) {
    return this.config.eachSchema(schema, callback);
  }
  getChildSchemaSelection(property, schema) {
    return this.config.getChildSchemaSelection(this, property, schema);
  }
  /**
   * Returns the json-schema of a data-json-pointer.
   *
   * To resolve dynamic schema where the type of json-schema is evaluated by
   * its value, a data object has to be passed in options.
   *
   * Per default this function will return `undefined` for valid properties that
   * do not have a defined schema. Use the option `withSchemaWarning: true` to
   * receive an error with `code: schema-warning` containing the location of its
   * last evaluated json-schema.
   *
   * Notes
   *      - uses draft.step to walk through data and schema
   *
   * @param draft
   * @param pointer - json pointer in data to get the json schema for
   * @param [options.data] - the data object, which includes the json pointers value. This is optional, as
   *    long as no oneOf, anyOf, etc statement is part of the pointers schema
   * @param [options.schema] - the json schema to iterate. Defaults to draft.rootSchema
   * @param [options.withSchemaWarning] - if true returns an error instead of `undefined` for valid properties missing a schema definition
   * @return resolved json-schema object of requested json-pointer location
   */
  getSchema(options) {
    const result = this.getSchemaNode(options);
    if (isSchemaNode(result)) {
      return result.schema;
    }
    return result;
  }
  getSchemaNode(options) {
    return this.config.getSchema(this, options);
  }
  /**
   * Create data object matching the given schema
   *
   * @param [data] - optional template data
   * @param [schema] - json schema, defaults to rootSchema
   * @return created template data
   */
  getTemplate(data, schema, opts = this.config.templateDefaultOptions) {
    return this.config.getTemplate(this, data, schema, opts);
  }
  isValid(data, schema, pointer) {
    return this.config.isValid(this, data, schema, pointer);
  }
  createNode(schema, pointer = "#") {
    return this.config.createNode(this, schema, pointer);
  }
  resolveAnyOf(node, data) {
    return this.config.resolveAnyOf(node, data);
  }
  resolveAllOf(node, data) {
    return this.config.resolveAllOf(node, data);
  }
  resolveRef(node) {
    return this.config.resolveRef(node);
  }
  resolveOneOf(node, data) {
    return this.config.resolveOneOf(node, data);
  }
  setSchema(schema) {
    this.rootSchema = schema;
  }
  /**
   * Returns the json-schema of the given object property or array item.
   * e.g. it steps by one key into the data
   *
   * This helper determines the location of the property within the schema (additional properties, oneOf, ...) and
   * returns the correct schema.
   *
   * @param  node
   * @param  key       - property-name or array-index
   * @param  data      - parent of key
   * @return schema-node containing child schema or error if failed resolving key
   */
  step(node, key, data) {
    return this.config.step(node, key, data);
  }
  validate(data, schema = this.rootSchema, pointer) {
    if (isSchemaNode(data)) {
      const inputData = schema;
      const inuptNode = data;
      return this.config.validate(inuptNode, inputData);
    }
    if (isJsonError(data)) {
      return [data];
    }
    const node = this.createNode(schema, pointer);
    return this.config.validate(node, data);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/draft04/addRemoteSchema.js
function addRemoteSchema(draft, url, schema) {
  schema.id = schema.id || url;
  draft.remotes[url] = draft.compileSchema(schema);
}

// ../../node_modules/json-schema-library/dist/module/lib/eachSchema.js
function eachProperty(property, schema, callback, pointer) {
  const target = schema[property];
  if (!isObject(target)) {
    return;
  }
  Object.keys(target).forEach((key) => {
    if (Array.isArray(target[key])) {
      return;
    }
    if (key === "$defs") {
      eachProperty("$defs", target[key], callback, `${pointer}/${property}/$defs`);
    } else {
      eachSchema(target[key], callback, `${pointer}/${property}/${key}`);
    }
  });
}
function eachItem(property, schema, callback, pointer) {
  const target = schema[property];
  if (!Array.isArray(target)) {
    return;
  }
  target.forEach((s, key) => eachSchema(s, callback, `${pointer}/${property}/${key}`));
}
function eachSchema(schema, callback, pointer = "") {
  if (schema === void 0) {
    return;
  }
  if (callback(schema, pointer) === true) {
    return;
  }
  if (!isObject(schema)) {
    return;
  }
  eachProperty("properties", schema, callback, pointer);
  eachProperty("patternProperties", schema, callback, pointer);
  eachSchema(schema.not, callback, `${pointer}/not`);
  eachSchema(schema.additionalProperties, callback, `${pointer}/additionalProperties`);
  eachProperty("dependencies", schema, callback, pointer);
  isObject(schema.items) && eachSchema(schema.items, callback, `${pointer}/items`);
  eachItem("items", schema, callback, pointer);
  eachSchema(schema.additionalItems, callback, `${pointer}/additionalItems`);
  eachItem("allOf", schema, callback, pointer);
  eachItem("anyOf", schema, callback, pointer);
  eachItem("oneOf", schema, callback, pointer);
  eachSchema(schema.if, callback, `${pointer}/if`);
  eachSchema(schema.then, callback, `${pointer}/then`);
  eachSchema(schema.else, callback, `${pointer}/else`);
  eachProperty("definitions", schema, callback, pointer);
  eachProperty("$defs", schema, callback, pointer);
}

// ../../node_modules/json-schema-library/dist/module/lib/compile/joinScope.js
var suffixes = /(#)+$/;
var trailingHash = /#$/;
var startingHashAndSlash = /^[#/]+/;
var isDomain = /^[^:]+:\/\/[^/]+\//;
var trailingFragments = /\/[^/]*$/;
var idAndPointer = /#.*$/;
var isURN = /^urn:uuid:[0-9A-Fa-f]/;
function joinScope(previous, id) {
  if (previous == null && id == null) {
    return "#";
  }
  if (id == null) {
    return previous.replace(trailingHash, "");
  }
  if (isURN.test(id)) {
    return id;
  }
  if (previous == null || previous === "" || previous === "#") {
    return id.replace(trailingHash, "");
  }
  if (id[0] === "#") {
    return `${previous.replace(idAndPointer, "")}${id.replace(suffixes, "")}`;
  }
  if (isDomain.test(id)) {
    return id.replace(trailingHash, "");
  }
  if (isDomain.test(previous) && id.startsWith("/")) {
    return `${previous.replace(/(^[^:]+:\/\/[^/]+)(.*)/, "$1")}/${id.replace(startingHashAndSlash, "")}`;
  }
  return `${previous.replace(trailingFragments, "")}/${id.replace(startingHashAndSlash, "")}`;
}

// ../../node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var import_json_pointer = __toESM(require_jsonPointer());

// ../../node_modules/json-schema-library/dist/module/lib/compile/splitRef.js
var suffixes2 = /(#)+$/g;
var emptyValues = ["", null, "#"];
function splitRef($ref) {
  if (emptyValues.includes($ref)) {
    return [];
  }
  $ref = $ref.replace(suffixes2, "");
  if ($ref.indexOf("#") === -1) {
    return [$ref.replace(/(#|\/)+$/g, "")];
  }
  if ($ref.indexOf("#") === 0) {
    return [$ref.replace(suffixes2, "")];
  }
  const result = $ref.split("#");
  result[0] = result[0].replace(/(#|\/)+$/g, "");
  result[1] = `#${result[1].replace(suffixes2, "")}`;
  return result;
}

// ../../node_modules/json-schema-library/dist/module/lib/compile/getRef.js
var suffixes3 = /(#)+$/g;
var isObject2 = (val) => getTypeOf(val) === "object";
function getRef(context, rootSchema, $search) {
  var _a2, _b, _c, _d, _e;
  let $ref;
  if (isObject2($search)) {
    $ref = $search.__ref || $search.$ref;
  } else {
    $ref = $search;
  }
  if ($ref == null) {
    return rootSchema;
  }
  let schema;
  const $remote = $ref.replace(suffixes3, "");
  if (context.remotes[$remote] != null) {
    schema = context.remotes[$remote];
    if (schema && schema.$ref) {
      return getRef(context, schema, schema);
    }
    return schema;
  }
  const $anchor = (_a2 = context.anchors) === null || _a2 === void 0 ? void 0 : _a2[$ref];
  if ($anchor) {
    return (0, import_json_pointer.get)(rootSchema, $anchor);
  }
  if (context.ids[$ref] != null) {
    schema = (0, import_json_pointer.get)(rootSchema, context.ids[$ref]);
    if (schema && schema.$ref) {
      return getRef(context, rootSchema, schema);
    }
    return schema;
  }
  const $inputRef = $ref;
  const fragments = splitRef($ref);
  if (fragments.length === 0) {
    return rootSchema;
  }
  if (fragments.length === 1) {
    $ref = fragments[0];
    if (context.remotes[$ref]) {
      schema = context.remotes[$ref];
      if (schema && schema.$ref) {
        return getRef(context, rootSchema, schema);
      }
    }
    if (context.ids[$ref]) {
      schema = (0, import_json_pointer.get)(rootSchema, context.ids[$ref]);
      if (schema && schema.$ref) {
        return getRef(context, rootSchema, schema);
      }
      return schema;
    }
    const rootContextRef = (_b = rootSchema.getContext) === null || _b === void 0 ? void 0 : _b.call(rootSchema).ids[$ref];
    if (rootContextRef) {
      return getRef(context, rootSchema, rootContextRef);
    }
  }
  if (fragments.length === 2) {
    const base = fragments[0];
    $ref = fragments[1];
    const fromRemote = (_c = context.remotes[base]) !== null && _c !== void 0 ? _c : context.remotes[`${base}/`];
    if (fromRemote) {
      if (fromRemote.getContext && fromRemote.getContext().anchors[$inputRef] != null) {
        return fromRemote.getRef($inputRef);
      }
      if (fromRemote.getRef) {
        return fromRemote.getRef($ref);
      }
      return getRef(context, fromRemote, $ref);
    }
    const fromId = (_d = context.ids[base]) !== null && _d !== void 0 ? _d : context.ids[`${base}/`];
    if (fromId) {
      return getRef(context, (0, import_json_pointer.get)(rootSchema, fromId), $ref);
    }
  }
  schema = (0, import_json_pointer.get)(rootSchema, (_e = context.ids[$ref]) !== null && _e !== void 0 ? _e : $ref);
  if (schema && schema.$ref) {
    return getRef(context, rootSchema, schema);
  }
  return schema;
}

// ../../node_modules/json-schema-library/dist/module/lib/compile/index.js
var import_json_pointer2 = __toESM(require_jsonPointer());
var COMPILED = "__compiled";
var COMPILED_REF = "__ref";
var GET_REF = "getRef";
var GET_ROOT = "getRoot";
var suffixes4 = /(#|\/)+$/g;
function compileSchema(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (!schemaToCompile || schemaToCompile[COMPILED] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperties(compiledSchema, {
    // flag this schema as compiled
    [COMPILED]: { enumerable: false, value: true },
    // add getRef-helper to this object
    [GET_REF]: {
      enumerable: false,
      value: getRef.bind(null, context, compiledSchema)
    }
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (schemaToCompile !== rootSchema) {
    Object.defineProperty(compiledSchema, "definitions", {
      enumerable: false,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, schemaToCompile.definitions, schemaToCompile.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.id) {
      if (schema.id.startsWith("http") && /(allOf|anyOf|oneOf)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer2.get)(compiledSchema, parentPointer2);
        schema.id = (_a2 = parentSchema.id) !== null && _a2 !== void 0 ? _a2 : schema.id;
      }
      context.ids[schema.id.replace(suffixes4, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF]) {
      Object.defineProperty(schema, COMPILED_REF, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// ../../node_modules/json-schema-library/dist/module/lib/createSchemaOf.js
function createSchemaOf(data) {
  if (data === void 0) {
    return void 0;
  }
  const schema = {
    type: getTypeOf(data)
  };
  if (schema.type === "object" && isObject(data)) {
    schema.properties = {};
    Object.keys(data).forEach((key) => schema.properties[key] = createSchemaOf(data[key]));
  }
  if (schema.type === "array" && Array.isArray(data)) {
    if (data.length === 1) {
      schema.items = createSchemaOf(data[0]);
    } else {
      schema.items = data.map(createSchemaOf);
    }
  }
  return schema;
}

// ../../node_modules/json-schema-library/dist/module/lib/validation/errors.js
var errors = {
  additionalItemsError: createCustomError("AdditionalItemsError"),
  additionalPropertiesError: createCustomError("AdditionalPropertiesError"),
  allOfError: createCustomError("AllOfError"),
  anyOfError: createCustomError("AnyOfError"),
  constError: createCustomError("ConstError"),
  containsAnyError: createCustomError("ContainsAnyError"),
  containsArrayError: createCustomError("ContainsArrayError"),
  containsError: createCustomError("ContainsError"),
  containsMaxError: createCustomError("ContainsMaxError"),
  containsMinError: createCustomError("ContainsMinError"),
  enumError: createCustomError("EnumError"),
  forbiddenPropertyError: createCustomError("ForbiddenPropertyError"),
  formatDateError: createCustomError("FormatDateError"),
  formatDateTimeError: createCustomError("FormatDateTimeError"),
  formatDurationError: createCustomError("FormatDurationError"),
  formatEmailError: createCustomError("FormatEmailError"),
  formatHostnameError: createCustomError("FormatHostnameError"),
  formatIPV4Error: createCustomError("FormatIPV4Error"),
  formatIPV4LeadingZeroError: createCustomError("FormatIPV4LeadingZeroError"),
  formatIPV6Error: createCustomError("FormatIPV6Error"),
  formatIPV6LeadingZeroError: createCustomError("FormatIPV6LeadingZeroError"),
  formatJsonPointerError: createCustomError("FormatJsonPointerError"),
  formatRegExError: createCustomError("FormatRegExError"),
  formatTimeError: createCustomError("FormatTimeError"),
  formatURIError: createCustomError("FormatURIError"),
  formatURIReferenceError: createCustomError("FormatURIReferenceError"),
  formatURITemplateError: createCustomError("FormatURITemplateError"),
  formatURLError: createCustomError("FormatURLError"),
  formatUUIDError: createCustomError("FormatUUIDError"),
  invalidDataError: createCustomError("InvalidDataError"),
  invalidPropertyNameError: createCustomError("InvalidPropertyNameError"),
  invalidSchemaError: createCustomError("InvalidSchemaError"),
  invalidTypeError: createCustomError("InvalidTypeError"),
  maximumError: createCustomError("MaximumError"),
  maxItemsError: createCustomError("MaxItemsError"),
  maxLengthError: createCustomError("MaxLengthError"),
  maxPropertiesError: createCustomError("MaxPropertiesError"),
  minimumError: createCustomError("MinimumError"),
  minItemsError: createCustomError("MinItemsError"),
  minItemsOneError: createCustomError("MinItemsOneError"),
  minLengthError: createCustomError("MinLengthError"),
  minLengthOneError: createCustomError("MinLengthOneError"),
  minPropertiesError: createCustomError("MinPropertiesError"),
  missingDependencyError: createCustomError("MissingDependencyError"),
  missingOneOfPropertyError: createCustomError("MissingOneOfPropertyError"),
  multipleOfError: createCustomError("MultipleOfError"),
  multipleOneOfError: createCustomError("MultipleOneOfError"),
  noAdditionalPropertiesError: createCustomError("NoAdditionalPropertiesError"),
  notError: createCustomError("NotError"),
  oneOfError: createCustomError("OneOfError"),
  oneOfPropertyError: createCustomError("OneOfPropertyError"),
  patternError: createCustomError("PatternError"),
  patternPropertiesError: createCustomError("PatternPropertiesError"),
  requiredPropertyError: createCustomError("RequiredPropertyError"),
  schemaWarning: createCustomError("SchemaWarning"),
  typeError: createCustomError("TypeError"),
  undefinedValueError: createCustomError("UndefinedValueError"),
  unevaluatedItemsError: createCustomError("UnevaluatedItemsError"),
  unevaluatedPropertyError: createCustomError("UnevaluatedPropertyError"),
  uniqueItemsError: createCustomError("UniqueItemsError"),
  unknownPropertyError: createCustomError("UnknownPropertyError"),
  valueNotEmptyError: createCustomError("ValueNotEmptyError")
};
var errors_default = errors;

// ../../node_modules/json-schema-library/dist/module/lib/validation/format.js
var import_valid_url = __toESM(require_valid_url());
var import_smtp_address_parser = __toESM(require_lib());
var isValidIPV4 = /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/;
var isValidIPV6 = /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i;
var isValidHostname = /^(?=.{1,255}$)[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?(?:\.[0-9A-Za-z](?:(?:[0-9A-Za-z]|-){0,61}[0-9A-Za-z])?)*\.?$/;
var matchDate = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var matchTime = /^(?<time>(?:([0-1]\d|2[0-3]):[0-5]\d:(?<second>[0-5]\d|60)))(?:\.\d+)?(?<offset>(?:z|[+-]([0-1]\d|2[0-3])(?::?[0-5]\d)?))$/i;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var isValidJsonPointer = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var isValidRelativeJsonPointer = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
var isValidURIRef = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var isValidURITemplate = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
var isValidDurationString = /^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/;
var formatValidators = {
  date: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchDate);
    if (!matches) {
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    const isLeapYear = year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    if (month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear ? 29 : DAYS[month])) {
      return void 0;
    }
    return draft.errors.formatDateError({ value, pointer, schema });
  },
  "date-time": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const dateAndTime = value.split(/t/i);
    if (dateAndTime.length === 2) {
      const dateIsValid = formatValidators.date(node, dateAndTime[0]) === void 0;
      const timeIsValid = formatValidators.time(node, dateAndTime[1]) === void 0;
      if (dateIsValid && timeIsValid) {
        return void 0;
      }
    }
    return draft.errors.formatDateTimeError({ value, pointer, schema });
  },
  duration: (node, value) => {
    const type = getTypeOf(value);
    if (type !== "string") {
      return void 0;
    }
    const isInvalidDurationString = /(\d+M)(\d+W)|(\d+Y)(\d+W)/;
    if (!isValidDurationString.test(value) || isInvalidDurationString.test(value)) {
      return node.draft.errors.formatDurationError({
        value,
        pointer: node.pointer,
        schema: node.schema
      });
    }
  },
  email: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value[0] === '"') {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    const [name, host, ...rest] = value.split("@");
    if (!name || !host || rest.length !== 0 || name.length > 64 || host.length > 253) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (name[0] === "." || name.endsWith(".") || name.includes("..")) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!/^[a-z0-9.-]+$/i.test(host) || !/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+$/i.test(name)) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    if (!host.split(".").every((part) => /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?$/i.test(part))) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
    return void 0;
  },
  /**
   * @draft 7
   * [RFC6531] https://json-schema.org/draft-07/json-schema-validation.html#RFC6531
   */
  "idn-email": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    try {
      (0, import_smtp_address_parser.parse)(value);
      return void 0;
    } catch (e) {
      return draft.errors.formatEmailError({ value, pointer, schema });
    }
  },
  hostname: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string") {
      return void 0;
    }
    if (value === "" || isValidHostname.test(value)) {
      return void 0;
    }
    return draft.errors.formatHostnameError({ value, pointer, schema });
  },
  ipv4: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV4LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 15 && isValidIPV4.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV4Error({ value, pointer, schema });
  },
  ipv6: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (value && value[0] === "0") {
      return draft.errors.formatIPV6LeadingZeroError({ value, pointer, schema });
    }
    if (value.length <= 45 && isValidIPV6.test(value)) {
      return void 0;
    }
    return draft.errors.formatIPV6Error({ value, pointer, schema });
  },
  "json-pointer": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  "relative-json-pointer": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string") {
      return void 0;
    }
    if (isValidRelativeJsonPointer.test(value)) {
      return void 0;
    }
    return draft.errors.formatJsonPointerError({ value, pointer, schema });
  },
  regex: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value === "string" && /\\Z$/.test(value) === false) {
      try {
        new RegExp(value);
        return void 0;
      } catch (e) {
      }
      return draft.errors.formatRegExError({ value, pointer, schema });
    }
    if (typeof value === "object" || typeof value === "number" || Array.isArray(value)) {
      return void 0;
    }
    return draft.errors.formatRegExError({ value, pointer, schema });
  },
  // hh:mm:ss.sTZD
  // RFC 3339 https://datatracker.ietf.org/doc/html/rfc3339#section-4
  time: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    const matches = value.match(matchTime);
    if (!matches) {
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    if (matches.groups.second === "60") {
      if (/23:59:60(z|\+00:00)/i.test(value)) {
        return void 0;
      }
      const minutes = matches.groups.time.match(/(\d+):(\d+):/);
      const offsetMinutes = matches.groups.offset.match(/(\d+):(\d+)/);
      if (offsetMinutes) {
        const hour = parseInt(minutes[1]);
        const offsetHour = parseInt(offsetMinutes[1]);
        const min = parseInt(minutes[2]);
        const offsetMin = parseInt(offsetMinutes[2]);
        let deltaTime;
        if (/^-/.test(matches.groups.offset)) {
          deltaTime = (hour + offsetHour) * 60 + (min + offsetMin);
        } else {
          deltaTime = (24 + hour - offsetHour) * 60 + (min - offsetMin);
        }
        const hours = Math.floor(deltaTime / 60);
        const actualHour = hours % 24;
        const actualMinutes = deltaTime - hours * 60;
        if (actualHour === 23 && actualMinutes === 59) {
          return void 0;
        }
      }
      return draft.errors.formatDateTimeError({ value, pointer, schema });
    }
    return void 0;
  },
  uri: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (import_valid_url.default.isUri(value)) {
      return void 0;
    }
    return draft.errors.formatURIError({ value, pointer, schema });
  },
  "uri-reference": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURIRef.test(value)) {
      return void 0;
    }
    return draft.errors.formatURIReferenceError({ value, pointer, schema });
  },
  "uri-template": (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (isValidURITemplate.test(value)) {
      return void 0;
    }
    return draft.errors.formatURITemplateError({ value, pointer, schema });
  },
  url: (node, value) => {
    const { draft, schema, pointer } = node;
    if (value === "" || import_valid_url.default.isWebUri(value)) {
      return void 0;
    }
    return draft.errors.formatURLError({ value, pointer, schema });
  },
  uuid: (node, value) => {
    const { draft, schema, pointer } = node;
    if (typeof value !== "string" || value === "") {
      return void 0;
    }
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
      return void 0;
    }
    return draft.errors.formatUUIDError({ value, pointer, schema });
  }
};
var format_default = formatValidators;

// ../../node_modules/json-schema-library/dist/module/lib/getChildSchemaSelection.js
function getChildSchemaSelection(draft, property, schema = draft.rootSchema) {
  var _a2;
  if (schema.oneOf) {
    return schema.oneOf.map((item) => draft.createNode(item).resolveRef().schema);
  }
  if ((_a2 = schema.items) === null || _a2 === void 0 ? void 0 : _a2.oneOf) {
    return schema.items.oneOf.map((item) => draft.createNode(item).resolveRef().schema);
  }
  const node = draft.step(draft.createNode(schema), property, {});
  if (isJsonError(node)) {
    return node;
  }
  return [node.schema];
}

// ../../node_modules/json-schema-library/dist/module/lib/getSchema.js
var import_json_pointer3 = __toESM(require_jsonPointer());
var emptyObject = {};
function getSchema(draft, options = emptyObject) {
  const { pointer = "#", data, schema = draft.rootSchema, withSchemaWarning = false } = options;
  const path = import_json_pointer3.default.split(pointer);
  const node = draft.createNode(schema).resolveRef();
  const result = _getSchema(node, path, data);
  if (!withSchemaWarning && isJsonError(result) && result.code === "schema-warning") {
    return draft.createNode(void 0);
  }
  return result;
}
function _getSchema(node, path, data = emptyObject) {
  if (path.length === 0) {
    return node.resolveRef();
  }
  const key = path.shift();
  const nextNode = node.draft.step(node, key, data);
  if (isJsonError(nextNode)) {
    return nextNode;
  }
  data = data[key];
  return _getSchema(nextNode, path, data);
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/merge.js
var import_deepmerge = __toESM(require_cjs());
var overwriteMerge = (destinationArray, sourceArray) => sourceArray;
var merge_default = (a, b) => (0, import_deepmerge.default)(a, b, { arrayMerge: overwriteMerge });

// ../../node_modules/json-schema-library/dist/module/lib/utils/isEmpty.js
function isEmpty(v) {
  const type = getTypeOf(v);
  switch (type) {
    case "string":
    case "array":
      return (v === null || v === void 0 ? void 0 : v.length) === 0;
    case "null":
    case "undefined":
      return true;
    case "object":
      return Object.keys(v).length === 0;
    default:
      return false;
  }
}

// ../../node_modules/json-schema-library/dist/module/lib/getTemplate.js
var defaultOptions = settings_default.templateDefaultOptions;
var cache;
function shouldResolveRef(schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return true;
  }
  const value = cache[pointer] == null || cache[pointer][$ref] == null ? 0 : cache[pointer][$ref];
  return value < settings_default.GET_TEMPLATE_RECURSION_LIMIT;
}
function resolveRef4(draft, schema, pointer) {
  const { $ref } = schema;
  if ($ref == null) {
    return schema;
  }
  cache[pointer] = cache[pointer] || {};
  cache[pointer][$ref] = cache[pointer][$ref] || 0;
  cache[pointer][$ref] += 1;
  return draft.createNode(schema, pointer).resolveRef().schema;
}
function convertValue(type, value) {
  if (type === "string") {
    return JSON.stringify(value);
  } else if (typeof value !== "string") {
    return null;
  }
  try {
    value = JSON.parse(value);
    if (typeof value === type) {
      return value;
    }
  } catch (e) {
  }
  return null;
}
function createTemplateSchema(draft, schema, data, pointer, opts) {
  if (getTypeOf(schema) !== "object") {
    return Object.assign({ pointer }, schema);
  }
  if (shouldResolveRef(schema, pointer) === false && data == null) {
    return false;
  }
  let templateSchema = copy_default(resolveRef4(draft, schema, pointer));
  if (Array.isArray(schema.anyOf) && schema.anyOf.length > 0) {
    if (shouldResolveRef(schema.anyOf[0], `${pointer}/anyOf/0`)) {
      const resolvedAnyOf = resolveRef4(draft, schema.anyOf[0], `${pointer}/anyOf/0`);
      templateSchema = merge_default(templateSchema, resolvedAnyOf);
      templateSchema.pointer = schema.anyOf[0].$ref || templateSchema.pointer;
    }
    delete templateSchema.anyOf;
  }
  if (Array.isArray(schema.allOf)) {
    const mayResolve = schema.allOf.map((allOf, index2) => shouldResolveRef(allOf, `${pointer}/allOf/${index2}`)).reduceRight((next2, before) => next2 && before, true);
    if (mayResolve) {
      const allOf = [];
      let extendedData = copy_default(data);
      for (let i = 0; i < schema.allOf.length; i += 1) {
        const allNode = draft.createNode(schema.allOf[i], pointer);
        allOf.push(resolveSchema(allNode, extendedData).schema);
        extendedData = getTemplate(draft, extendedData, { type: schema.type, ...allOf[i] }, `${pointer}/allOf/${i}`, opts);
      }
      const resolvedSchema = mergeAllOfSchema(draft, { allOf });
      if (resolvedSchema) {
        templateSchema = mergeSchema(templateSchema, resolvedSchema);
      }
    }
  }
  templateSchema.pointer = templateSchema.pointer || schema.$ref || pointer;
  return templateSchema;
}
var isJsonSchema = (template) => template && typeof template === "object";
function getTemplate(draft, data, _schema, pointer, opts) {
  var _a2;
  if (_schema == null) {
    throw new Error(`getTemplate: missing schema for data: ${JSON.stringify(data)}`);
  }
  if (pointer == null) {
    throw new Error("Missing pointer");
  }
  let schema = createTemplateSchema(draft, _schema, data, pointer, opts);
  if (!isJsonSchema(schema)) {
    return void 0;
  }
  pointer = schema.pointer;
  if (schema === null || schema === void 0 ? void 0 : schema.const) {
    return schema.const;
  }
  if (Array.isArray(schema.oneOf)) {
    if (isEmpty(data)) {
      const type2 = schema.oneOf[0].type || schema.type || schema.const && typeof schema.const || getTypeOf(data);
      schema = { ...schema.oneOf[0], type: type2 };
    } else {
      const oneNode = draft.createNode(schema, pointer);
      const resolvedNode = resolveOneOfFuzzy(oneNode, data);
      if (isJsonError(resolvedNode)) {
        if (data != null && opts.removeInvalidData !== true) {
          return data;
        }
        schema = schema.oneOf[0];
        data = void 0;
      } else {
        const resolvedSchema = resolvedNode.schema;
        resolvedSchema.type = (_a2 = resolvedSchema.type) !== null && _a2 !== void 0 ? _a2 : schema.type;
        schema = resolvedSchema;
      }
    }
  }
  if (!isJsonSchema(schema) || schema.type == null) {
    return void 0;
  }
  if (data instanceof File) {
    return data;
  }
  const type = Array.isArray(schema.type) ? selectType(schema.type, data, schema.default) : schema.type;
  const javascriptTypeOfData = getTypeOf(data);
  if (data != null && javascriptTypeOfData !== type && !(javascriptTypeOfData === "number" && type === "integer")) {
    data = convertValue(type, data);
  }
  if (TYPE[type] == null) {
    if (opts.removeInvalidData) {
      return void 0;
    }
    return data;
  }
  const templateData = TYPE[type](draft, schema, data, pointer, opts);
  return templateData;
}
function selectType(types, data, defaultValue) {
  if (data == void 0) {
    if (defaultValue != null) {
      const defaultType = getTypeOf(defaultValue);
      if (types.includes(defaultType)) {
        return defaultType;
      }
    }
    return types[0];
  }
  const dataType = getTypeOf(data);
  if (types.includes(dataType)) {
    return dataType;
  }
  return types[0];
}
var TYPE = {
  null: (draft, schema, data) => getDefault(schema, data, null),
  string: (draft, schema, data) => getDefault(schema, data, ""),
  number: (draft, schema, data) => getDefault(schema, data, 0),
  integer: (draft, schema, data) => getDefault(schema, data, 0),
  boolean: (draft, schema, data) => getDefault(schema, data, false),
  object: (draft, schema, data, pointer, opts) => {
    var _a2;
    const template = schema.default === void 0 ? {} : schema.default;
    const d = {};
    const required = opts.extendDefaults === false && schema.default !== void 0 ? [] : (_a2 = schema.required) !== null && _a2 !== void 0 ? _a2 : [];
    if (schema.properties) {
      Object.keys(schema.properties).forEach((key) => {
        const value = data == null || data[key] == null ? template[key] : data[key];
        const isRequired = required.includes(key);
        if (value != null || isRequired || opts.addOptionalProps) {
          d[key] = getTemplate(draft, value, schema.properties[key], `${pointer}/properties/${key}`, opts);
        }
      });
    }
    const dNode = draft.createNode(schema, pointer);
    let dependenciesSchema = resolveDependencies(dNode, d);
    if (dependenciesSchema) {
      dependenciesSchema = mergeSchema(schema, dependenciesSchema);
      delete dependenciesSchema.dependencies;
      const dependencyData = getTemplate(draft, data, dependenciesSchema, `${pointer}/dependencies`, opts);
      Object.assign(d, dependencyData);
    }
    if (data) {
      if (opts.removeInvalidData === true && (schema.additionalProperties === false || getTypeOf(schema.additionalProperties) === "object")) {
        if (getTypeOf(schema.additionalProperties) === "object") {
          Object.keys(data).forEach((key) => {
            if (d[key] == null) {
              if (draft.isValid(data[key], schema.additionalProperties)) {
                d[key] = data[key];
              }
            }
          });
        }
      } else {
        Object.keys(data).forEach((key) => d[key] == null && (d[key] = data[key]));
      }
    }
    const node = draft.createNode(schema, pointer);
    const ifSchema = resolveIfSchema(node, d);
    if (isSchemaNode(ifSchema)) {
      const additionalData = getTemplate(draft, d, { type: "object", ...ifSchema.schema }, pointer, opts);
      Object.assign(d, additionalData);
    }
    return d;
  },
  // build array type of items, ignores additionalItems
  array: (draft, schema, data, pointer, opts) => {
    var _a2, _b;
    if (schema.items == null) {
      return data || [];
    }
    const template = schema.default === void 0 ? [] : schema.default;
    const d = data || template;
    const minItems = opts.extendDefaults === false && schema.default !== void 0 ? 0 : schema.minItems || 0;
    if (Array.isArray(schema.items)) {
      for (let i = 0, l = Math.max(minItems !== null && minItems !== void 0 ? minItems : 0, (_b = (_a2 = schema.items) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0); i < l; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], schema.items[i], `${pointer}/items/${i}`, opts);
      }
      return d;
    }
    if (getTypeOf(schema.items) !== "object") {
      return d;
    }
    const templateSchema = createTemplateSchema(draft, schema.items, data, pointer, opts);
    if (templateSchema === false) {
      return d;
    }
    pointer = templateSchema.pointer || pointer;
    if (templateSchema.oneOf && d.length === 0) {
      const oneOfSchema = templateSchema.oneOf[0];
      for (let i = 0; i < minItems; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], oneOfSchema, `${pointer}/oneOf/0`, opts);
      }
      return d;
    }
    if (templateSchema.oneOf && d.length > 0) {
      const itemCount = Math.max(minItems, d.length);
      for (let i = 0; i < itemCount; i += 1) {
        let value = d[i] == null ? template[i] : d[i];
        const oneNode = draft.createNode(templateSchema, pointer);
        let one = resolveOneOfFuzzy(oneNode, value);
        if (one == null || isJsonError(one)) {
          if (value != null && opts.removeInvalidData !== true) {
            d[i] = value;
          } else {
            value = void 0;
            one = templateSchema.oneOf[0];
            d[i] = getTemplate(draft, value, one, `${pointer}/oneOf/${i}`, opts);
          }
        } else {
          d[i] = getTemplate(draft, value, one.schema, `${pointer}/oneOf/${i}`, opts);
        }
      }
      return d;
    }
    if (templateSchema.type) {
      for (let i = 0, l = Math.max(minItems, d.length); i < l; i += 1) {
        d[i] = getTemplate(draft, d[i] == null ? template[i] : d[i], templateSchema, `${pointer}/items`, opts);
      }
      return d;
    }
    return d;
  }
};
function getDefault(schema, templateValue, initValue) {
  if (templateValue != null) {
    return templateValue;
  } else if (schema.const) {
    return schema.const;
  } else if (schema.default === void 0 && Array.isArray(schema.enum)) {
    return schema.enum[0];
  } else if (schema.default === void 0) {
    return initValue;
  }
  return schema.default;
}
var getTemplate_default = (draft, data, schema = draft.rootSchema, opts) => {
  cache = {};
  if (opts) {
    return getTemplate(draft, data, schema, "#", { ...defaultOptions, ...opts });
  }
  return getTemplate(draft, data, schema, "#", defaultOptions);
};

// ../../node_modules/json-schema-library/dist/module/lib/isValid.js
function isValid(draft, value, schema = draft.rootSchema, pointer = "#") {
  const node = draft.createNode(schema, pointer);
  return draft.validate(node, value).length === 0;
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/punycode.ucs2decode.js
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}

// ../../node_modules/json-schema-library/dist/module/lib/utils/getPrecision.js
function getPrecision(value) {
  const string = `${value}`;
  if (string.includes("e-")) {
    return parseInt(string.replace(/.*e-/, ""));
  }
  const index2 = string.indexOf(".");
  return index2 === -1 ? 0 : string.length - (index2 + 1);
}

// ../../node_modules/json-schema-library/dist/module/lib/validation/keyword.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var hasProperty = (value, property) => !(value[property] === void 0 || !hasOwnProperty2.call(value, property));
var KeywordValidation = {
  additionalProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.additionalProperties === true || schema.additionalProperties == null) {
      return void 0;
    }
    if (getTypeOf(schema.patternProperties) === "object" && schema.additionalProperties === false) {
      return void 0;
    }
    const errors2 = [];
    let receivedProperties = Object.keys(value).filter((prop) => settings_default.propertyBlacklist.includes(prop) === false);
    const expectedProperties = Object.keys(schema.properties || {});
    if (getTypeOf(schema.patternProperties) === "object") {
      const patterns = Object.keys(schema.patternProperties).map((pattern) => new RegExp(pattern));
      receivedProperties = receivedProperties.filter((prop) => {
        for (let i = 0; i < patterns.length; i += 1) {
          if (patterns[i].test(prop)) {
            return false;
          }
        }
        return true;
      });
    }
    for (let i = 0, l = receivedProperties.length; i < l; i += 1) {
      const property = receivedProperties[i];
      if (expectedProperties.indexOf(property) === -1) {
        const additionalIsObject = isObject(schema.additionalProperties);
        if (additionalIsObject && Array.isArray(schema.additionalProperties.oneOf)) {
          const result = draft.resolveOneOf(node.next(schema.additionalProperties), value[property]);
          if (isJsonError(result)) {
            errors2.push(draft.errors.additionalPropertiesError({
              pointer,
              schema: schema.additionalProperties,
              value,
              property: receivedProperties[i],
              properties: expectedProperties,
              // pass all validation errors
              errors: result.data.errors
            }));
          } else {
            errors2.push(...draft.validate(node.next(result, property), value[property]));
          }
        } else if (additionalIsObject) {
          const res = draft.validate(node.next(schema.additionalProperties, property), value[property]);
          errors2.push(...res);
        } else {
          errors2.push(draft.errors.noAdditionalPropertiesError({
            pointer,
            schema,
            value,
            property: receivedProperties[i],
            properties: expectedProperties
          }));
        }
      }
    }
    return errors2;
  },
  allOf: validateAllOf,
  anyOf: validateAnyOf,
  dependencies: validateDependencies,
  enum: (node, value) => {
    const { draft, schema, pointer } = node;
    const type = getTypeOf(value);
    if (type === "object" || type === "array") {
      const valueStr = JSON.stringify(value);
      for (let i = 0; i < schema.enum.length; i += 1) {
        if (JSON.stringify(schema.enum[i]) === valueStr) {
          return void 0;
        }
      }
    } else if (schema.enum.includes(value)) {
      return void 0;
    }
    return draft.errors.enumError({ pointer, schema, value, values: schema.enum });
  },
  format: (node, value) => {
    const { draft, schema } = node;
    if (draft.validateFormat[schema.format]) {
      const errors2 = draft.validateFormat[schema.format](node, value);
      return errors2;
    }
    return void 0;
  },
  items: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.items === false) {
      if (Array.isArray(value) && value.length === 0) {
        return void 0;
      }
      return draft.errors.invalidDataError({ pointer, value, schema });
    }
    const errors2 = [];
    for (let i = 0; i < value.length; i += 1) {
      const itemData = value[i];
      const itemNode = draft.step(node.next(schema), i, value);
      if (isJsonError(itemNode)) {
        return [itemNode];
      }
      const itemErrors = draft.validate(itemNode, itemData);
      errors2.push(...itemErrors);
    }
    return errors2;
  },
  maximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        value,
        pointer,
        schema
      });
    }
    if (schema.maximum && schema.exclusiveMaximum === true && schema.maximum === value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maxItems)) {
      return void 0;
    }
    if (schema.maxItems < value.length) {
      return draft.errors.maxItemsError({
        maximum: schema.maxItems,
        length: value.length,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  maxLength: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maxLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.maxLength < lengthOfString) {
      return draft.errors.maxLengthError({
        maxLength: schema.maxLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  maxProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const propertyCount = Object.keys(value).length;
    if (isNaN(schema.maxProperties) === false && schema.maxProperties < propertyCount) {
      return draft.errors.maxPropertiesError({
        maxProperties: schema.maxProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minLength: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minLength)) {
      return void 0;
    }
    const lengthOfString = ucs2decode(value).length;
    if (schema.minLength > lengthOfString) {
      if (schema.minLength === 1) {
        return draft.errors.minLengthOneError({
          minLength: schema.minLength,
          length: lengthOfString,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minLengthError({
        minLength: schema.minLength,
        length: lengthOfString,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    if (schema.exclusiveMinimum === true && schema.minimum === value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minItems)) {
      return void 0;
    }
    if (schema.minItems > value.length) {
      if (schema.minItems === 1) {
        return draft.errors.minItemsOneError({
          minItems: schema.minItems,
          length: value.length,
          pointer,
          schema,
          value
        });
      }
      return draft.errors.minItemsError({
        minItems: schema.minItems,
        length: value.length,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minProperties)) {
      return void 0;
    }
    const propertyCount = Object.keys(value).length;
    if (schema.minProperties > propertyCount) {
      return draft.errors.minPropertiesError({
        minProperties: schema.minProperties,
        length: propertyCount,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  multipleOf: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.multipleOf) || typeof value !== "number") {
      return void 0;
    }
    const valuePrecision = getPrecision(value);
    const multiplePrecision = getPrecision(schema.multipleOf);
    if (valuePrecision > multiplePrecision) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    const precision = Math.pow(10, multiplePrecision);
    const val = Math.round(value * precision);
    const multiple = Math.round(schema.multipleOf * precision);
    if (val % multiple / precision !== 0) {
      return draft.errors.multipleOfError({
        multipleOf: schema.multipleOf,
        value,
        pointer,
        schema
      });
    }
    return void 0;
  },
  not: (node, value) => {
    const { draft, schema, pointer } = node;
    const errors2 = [];
    if (draft.validate(node.next(schema.not), value).length === 0) {
      errors2.push(draft.errors.notError({ value, not: schema.not, pointer, schema }));
    }
    return errors2;
  },
  oneOf: validateOneOf,
  pattern: (node, value) => {
    const { draft, schema, pointer } = node;
    const pattern = new RegExp(schema.pattern, "u");
    if (pattern.test(value) === false) {
      return draft.errors.patternError({
        pattern: schema.pattern,
        description: schema.patternExample || schema.pattern,
        received: value,
        schema,
        value,
        pointer
      });
    }
    return void 0;
  },
  patternProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          schema,
          value,
          patterns: Object.keys(pp).join(",")
        }));
      }
    });
    return errors2;
  },
  properties: (node, value) => {
    const { draft, schema } = node;
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (hasProperty(value, key)) {
        const itemNode = draft.step(node, key, value);
        if (isJsonError(itemNode)) {
          errors2.push(itemNode);
        } else {
          const keyErrors = draft.validate(itemNode, value[key]);
          errors2.push(...keyErrors);
        }
      }
    }
    return errors2;
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.properties keyword
  propertiesRequired: (node, value) => {
    const { draft, schema, pointer } = node;
    const errors2 = [];
    const keys = Object.keys(schema.properties || {});
    for (let i = 0; i < keys.length; i += 1) {
      const key = keys[i];
      if (value[key] === void 0) {
        errors2.push(draft.errors.requiredPropertyError({ key, pointer, schema, value }));
      } else {
        const itemNode = draft.step(node, key, value);
        const keyErrors = draft.validate(itemNode, value[key]);
        errors2.push(...keyErrors);
      }
    }
    return errors2;
  },
  required: (node, value) => {
    const { draft, schema, pointer } = node;
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      if (!hasProperty(value, property)) {
        return draft.errors.requiredPropertyError({
          key: property,
          pointer,
          schema,
          value
        });
      }
      return void 0;
    });
  },
  // @todo move to separate file: this is custom keyword validation for JsonEditor.required keyword
  requiredNotEmpty: (node, value) => {
    const { schema } = node;
    if (Array.isArray(schema.required) === false) {
      return void 0;
    }
    return schema.required.map((property) => {
      const { draft, schema: schema2, pointer } = node;
      if (value[property] == null || value[property] === "") {
        return draft.errors.valueNotEmptyError({
          property,
          pointer: `${pointer}/${property}`,
          schema: schema2,
          value
        });
      }
      return void 0;
    });
  },
  uniqueItems: (node, value) => {
    const { draft, schema, pointer } = node;
    if ((Array.isArray(value) && schema.uniqueItems) === false) {
      return void 0;
    }
    const duplicates = [];
    const errors2 = [];
    value.forEach((item, index2) => {
      for (let i = index2 + 1; i < value.length; i += 1) {
        if ((0, import_fast_deep_equal.default)(item, value[i]) && !duplicates.includes(i)) {
          errors2.push(draft.errors.uniqueItemsError({
            pointer: `${pointer}/${i}`,
            duplicatePointer: `${pointer}/${index2}`,
            arrayPointer: pointer,
            value: JSON.stringify(item),
            schema
          }));
          duplicates.push(i);
        }
      }
    });
    return errors2;
  }
};
var keyword_default = KeywordValidation;

// ../../node_modules/json-schema-library/dist/module/lib/step.js
var stepType = {
  array: (node, key, data) => {
    const { draft, schema, pointer } = node;
    const itemValue = data === null || data === void 0 ? void 0 : data[key];
    const itemsType = getTypeOf(schema.items);
    if (itemsType === "object") {
      return reduceSchema(node.next(schema.items, key), itemValue);
    }
    if (itemsType === "array") {
      if (schema.items[key] === true) {
        return node.next(createSchemaOf(itemValue), key);
      }
      if (schema.items[key] === false) {
        return draft.errors.invalidDataError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.items[key]) {
        return draft.resolveRef(node.next(schema.items[key], key));
      }
      if (schema.additionalItems === false) {
        return draft.errors.additionalItemsError({
          key,
          value: itemValue,
          pointer,
          schema
        });
      }
      if (schema.additionalItems === true || schema.additionalItems === void 0) {
        return node.next(createSchemaOf(itemValue), key);
      }
      if (getTypeOf(schema.additionalItems) === "object") {
        return node.next(schema.additionalItems, key);
      }
      throw new Error(`Invalid schema ${JSON.stringify(schema, null, 2)} for ${JSON.stringify(data, null, 2)}`);
    }
    if (schema.additionalItems !== false && itemValue) {
      return node.next(createSchemaOf(itemValue), key);
    }
    return new Error(`Invalid array schema for ${key} at ${pointer}`);
  },
  object: (node, key, data) => {
    var _a2, _b;
    const { draft, pointer } = node;
    const reduction = reduceSchema(node, data);
    const schema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    const property = (_b = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _b === void 0 ? void 0 : _b[key];
    if (property !== void 0) {
      if (property === false) {
        return draft.errors.forbiddenPropertyError({
          property: key,
          value: data,
          pointer,
          schema
        });
      } else if (property === true) {
        return node.next(createSchemaOf(data === null || data === void 0 ? void 0 : data[key]), key);
      }
      const nextPropertyNode = draft.resolveRef(node.next(property, key));
      if (isJsonError(nextPropertyNode)) {
        return nextPropertyNode;
      }
      if (nextPropertyNode && Array.isArray(nextPropertyNode.schema.oneOf)) {
        const nextNode = node.next(nextPropertyNode.schema, key);
        const result = draft.resolveOneOf(nextNode, data[key]);
        if (isJsonError(result)) {
          return result;
        }
        return nextNode.merge(result.schema, "oneOf");
      }
      if (nextPropertyNode) {
        return nextPropertyNode;
      }
    }
    const { patternProperties } = schema;
    if (getTypeOf(patternProperties) === "object") {
      let regex;
      const patterns = Object.keys(patternProperties);
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        regex = new RegExp(patterns[i]);
        if (regex.test(key)) {
          return node.next(patternProperties[patterns[i]], key);
        }
      }
    }
    const { additionalProperties } = schema;
    if (getTypeOf(additionalProperties) === "object") {
      return node.next(schema.additionalProperties, key);
    }
    if (data && (additionalProperties === void 0 || additionalProperties === true)) {
      const generatedSchema = createSchemaOf(data[key]);
      return generatedSchema ? node.next(generatedSchema, key) : void 0;
    }
    return draft.errors.unknownPropertyError({
      property: key,
      value: data,
      pointer: `${pointer}`,
      schema
    });
  }
};
function step(node, key, data) {
  var _a2;
  const { draft, schema, pointer } = node;
  const typeOfData = getTypeOf(data);
  let schemaType = (_a2 = schema.type) !== null && _a2 !== void 0 ? _a2 : typeOfData;
  if (Array.isArray(schemaType)) {
    if (!schemaType.includes(typeOfData)) {
      return draft.errors.typeError({
        value: data,
        pointer,
        expected: schema.type,
        received: typeOfData,
        schema
      });
    }
    schemaType = typeOfData;
  }
  const stepFunction = stepType[schemaType];
  if (stepFunction) {
    const childNode = stepFunction(node, `${key}`, data);
    if (childNode === void 0) {
      return draft.errors.schemaWarning({ pointer, value: data, schema, key });
    }
    return childNode;
  }
  return new Error(`Unsupported schema type ${schema.type} for key ${key}`);
}

// ../../node_modules/json-schema-library/dist/module/lib/validation/type.js
var typeValidators = {
  array: (node, value) => node.draft.typeKeywords.array.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  object: (node, value) => node.draft.typeKeywords.object.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  string: (node, value) => node.draft.typeKeywords.string.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  integer: (node, value) => node.draft.typeKeywords.number.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  number: (node, value) => node.draft.typeKeywords.number.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  boolean: (node, value) => node.draft.typeKeywords.boolean.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value)),
  null: (node, value) => node.draft.typeKeywords.null.filter((key) => node.schema && node.schema[key] != null).map((key) => node.draft.validateKeyword[key](node, value))
};
var type_default = typeValidators;

// ../../node_modules/json-schema-library/dist/module/lib/validate.js
var import_fast_deep_equal2 = __toESM(require_fast_deep_equal());
function getJsonSchemaType(value, expectedType) {
  const jsType = getTypeOf(value);
  if (jsType === "number" && (expectedType === "integer" || Array.isArray(expectedType) && expectedType.includes("integer"))) {
    return Number.isInteger(value) || isNaN(value) ? "integer" : "number";
  }
  return jsType;
}
function validate(node, value) {
  if (!isSchemaNode(node)) {
    throw new Error("node expected");
  }
  const { draft, pointer } = node;
  node = node.resolveRef();
  const schema = node.schema;
  if (schema == null) {
    throw new Error("missing schema");
  }
  if (getTypeOf(schema) === "boolean") {
    if (schema) {
      return [];
    }
    return [draft.errors.invalidDataError({ pointer, schema, value })];
  }
  if (isJsonError(schema)) {
    return [schema];
  }
  if (schema.const !== void 0) {
    if ((0, import_fast_deep_equal2.default)(schema.const, value)) {
      return [];
    }
    return [draft.errors.constError({ pointer, schema, value, expected: schema.const })];
  }
  const receivedType = getJsonSchemaType(value, schema.type);
  const expectedType = schema.type || receivedType;
  if (receivedType !== expectedType && (!Array.isArray(expectedType) || !expectedType.includes(receivedType))) {
    return [
      draft.errors.typeError({
        pointer,
        schema,
        value,
        received: receivedType,
        expected: expectedType
      })
    ];
  }
  if (draft.validateType[receivedType] == null) {
    return [draft.errors.invalidTypeError({ pointer, schema, value, receivedType })];
  }
  const errors2 = flattenArray(draft.validateType[receivedType](node, value));
  return errors2.filter(errorOrPromise);
}

// ../../node_modules/json-schema-library/dist/module/lib/each.js
function each(schemaNode, data, callback) {
  const node = schemaNode.resolveRef();
  const { draft, schema, pointer } = node;
  callback(schema, data, pointer);
  const dataType = getTypeOf(data);
  if (dataType === "object") {
    Object.keys(data).forEach((key) => {
      const nextNode = draft.step(node, key, data);
      if (isSchemaNode(nextNode)) {
        each(nextNode, data[key], callback);
      }
    });
  } else if (dataType === "array") {
    data.forEach((next2, key) => {
      const nextNode = draft.step(node, key, data);
      if (isSchemaNode(nextNode)) {
        each(nextNode, data[key], callback);
      }
    });
  }
}

// ../../node_modules/json-schema-library/dist/module/lib/draft04/index.js
var draft04Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "enum",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["enum", "not", "allOf", "anyOf", "oneOf"],
    object: [
      "additionalProperties",
      "dependencies",
      "enum",
      "format",
      "minProperties",
      "maxProperties",
      "patternProperties",
      "properties",
      "required",
      "not",
      "oneOf",
      "allOf",
      "anyOf"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  createNode,
  validateKeyword: keyword_default,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  addRemoteSchema,
  compileSchema,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft04 = class extends Draft {
  constructor(schema, config2 = {}) {
    super(merge_default(draft04Config, config2), schema);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/addRemoteSchema.js
function addRemoteSchema2(draft, url, schema) {
  schema.$id = schema.$id || url;
  draft.remotes[url] = draft.compileSchema(schema);
}

// ../../node_modules/json-schema-library/dist/module/lib/draft06/compile/index.js
var import_json_pointer4 = __toESM(require_jsonPointer());
var COMPILED2 = "__compiled";
var COMPILED_REF2 = "__ref";
var GET_REF2 = "getRef";
var GET_ROOT2 = "getRoot";
var GET_CONTEXT = "getContext";
var suffixes5 = /(#|\/)+$/g;
function compileSchema2(draft, schemaToCompile, rootSchema = schemaToCompile, force = false) {
  if (schemaToCompile === true || schemaToCompile === false || schemaToCompile === void 0) {
    return schemaToCompile;
  }
  if (schemaToCompile[COMPILED2] !== void 0) {
    return schemaToCompile;
  }
  const context = { ids: {}, anchors: {}, remotes: draft.remotes };
  const rootSchemaAsString = JSON.stringify(schemaToCompile);
  const compiledSchema = JSON.parse(rootSchemaAsString);
  Object.defineProperties(compiledSchema, {
    [COMPILED2]: { enumerable: false, value: true },
    [GET_CONTEXT]: { enumerable: false, value: () => context },
    [GET_REF2]: {
      enumerable: false,
      value: getRef.bind(null, context, compiledSchema)
    }
  });
  if (force === false && rootSchemaAsString.includes("$ref") === false) {
    return compiledSchema;
  }
  if (compiledSchema !== rootSchema) {
    Object.defineProperty(compiledSchema, "$defs", {
      enumerable: true,
      value: Object.assign({}, rootSchema.definitions, rootSchema.$defs, compiledSchema.definitions, compiledSchema.$defs)
    });
  }
  const scopes = {};
  const getRoot = () => compiledSchema;
  eachSchema(compiledSchema, (schema, pointer) => {
    var _a2;
    if (schema.$id) {
      if (schema.$id.startsWith("http") && /(allOf|anyOf|oneOf|if)\/\d+$/.test(pointer)) {
        const parentPointer2 = pointer.replace(/\/(allOf|anyOf|oneOf|if)\/\d+$/, "");
        const parentSchema = (0, import_json_pointer4.get)(compiledSchema, parentPointer2);
        schema.$id = (_a2 = parentSchema.$id) !== null && _a2 !== void 0 ? _a2 : schema.$id;
      }
      context.ids[schema.$id.replace(suffixes5, "")] = pointer;
    }
    pointer = `#${pointer}`.replace(/##+/, "#");
    const previousPointer = pointer.replace(/\/[^/]+$/, "");
    const parentPointer = pointer.replace(/\/[^/]+\/[^/]+$/, "");
    const previousScope = scopes[previousPointer] || scopes[parentPointer];
    const scope = joinScope(previousScope, schema.$id);
    scopes[pointer] = scope;
    if (context.ids[scope] == null) {
      context.ids[scope] = pointer;
    }
    if (schema.$anchor) {
      context.anchors[`${scope}#${schema.$anchor}`] = pointer;
    }
    if (schema.$ref && !schema[COMPILED_REF2]) {
      Object.defineProperty(schema, COMPILED_REF2, {
        enumerable: false,
        value: joinScope(scope, schema.$ref)
      });
      Object.defineProperty(schema, GET_ROOT2, { enumerable: false, value: getRoot });
    }
  });
  return compiledSchema;
}

// ../../node_modules/json-schema-library/dist/module/lib/draft06/validation/keyword.js
var KeywordValidation2 = {
  ...keyword_default,
  // @draft >= 6
  contains: (node, value) => {
    var _a2, _b;
    const { draft, schema, pointer } = node;
    if (schema.contains === false) {
      return draft.errors.containsArrayError({ pointer, value, schema });
    }
    if (schema.contains === true) {
      if (Array.isArray(value) && value.length === 0) {
        return draft.errors.containsAnyError({ pointer, value, schema });
      }
      return void 0;
    }
    if (getTypeOf(schema.contains) !== "object") {
      return void 0;
    }
    let count = 0;
    for (let i = 0; i < value.length; i += 1) {
      if (draft.validate(node.next(schema.contains, i), value[i]).length === 0) {
        count++;
      }
    }
    const max = (_a2 = schema.maxContains) !== null && _a2 !== void 0 ? _a2 : Infinity;
    const min = (_b = schema.minContains) !== null && _b !== void 0 ? _b : 1;
    if (max >= count && min <= count) {
      return void 0;
    }
    if (max < count) {
      return draft.errors.containsMaxError({ pointer, schema, delta: count - max, value });
    }
    if (min > count) {
      return draft.errors.containsMinError({ pointer, schema, delta: min - count, value });
    }
    return draft.errors.containsError({ pointer, schema, value });
  },
  exclusiveMaximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.exclusiveMaximum)) {
      return void 0;
    }
    if (schema.exclusiveMaximum <= value) {
      return draft.errors.maximumError({
        maximum: schema.exclusiveMaximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  exclusiveMinimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.exclusiveMinimum)) {
      return void 0;
    }
    if (schema.exclusiveMinimum >= value) {
      return draft.errors.minimumError({
        minimum: schema.exclusiveMinimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  // @feature if-then-else
  if: validateIf,
  maximum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.maximum)) {
      return void 0;
    }
    if (schema.maximum && schema.maximum < value) {
      return draft.errors.maximumError({
        maximum: schema.maximum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  minimum: (node, value) => {
    const { draft, schema, pointer } = node;
    if (isNaN(schema.minimum)) {
      return void 0;
    }
    if (schema.minimum > value) {
      return draft.errors.minimumError({
        minimum: schema.minimum,
        length: value,
        pointer,
        schema,
        value
      });
    }
    return void 0;
  },
  patternProperties: (node, value) => {
    const { draft, schema, pointer } = node;
    const properties = schema.properties || {};
    const pp = schema.patternProperties;
    if (getTypeOf(pp) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const keys = Object.keys(value);
    const patterns = Object.keys(pp).map((expr) => ({
      regex: new RegExp(expr),
      patternSchema: pp[expr]
    }));
    keys.forEach((key) => {
      let patternFound = false;
      for (let i = 0, l = patterns.length; i < l; i += 1) {
        if (patterns[i].regex.test(key)) {
          patternFound = true;
          if (patterns[i].patternSchema === false) {
            errors2.push(draft.errors.patternPropertiesError({
              key,
              pointer,
              patterns: Object.keys(pp).join(","),
              schema,
              value
            }));
            return;
          }
          const valErrors = draft.validate(node.next(patterns[i].patternSchema, key), value[key]);
          if (valErrors && valErrors.length > 0) {
            errors2.push(...valErrors);
          }
        }
      }
      if (properties[key]) {
        return;
      }
      if (patternFound === false && schema.additionalProperties === false) {
        errors2.push(draft.errors.patternPropertiesError({
          key,
          pointer,
          patterns: Object.keys(pp).join(","),
          schema,
          value
        }));
      }
    });
    return errors2;
  },
  // @draft >= 6
  propertyNames: (node, value) => {
    const { draft, schema, pointer } = node;
    if (schema.propertyNames === false) {
      if (Object.keys(value).length === 0) {
        return void 0;
      }
      return draft.errors.invalidPropertyNameError({
        property: Object.keys(value),
        pointer,
        value,
        schema
      });
    }
    if (schema.propertyNames === true) {
      return void 0;
    }
    if (getTypeOf(schema.propertyNames) !== "object") {
      return void 0;
    }
    const errors2 = [];
    const properties = Object.keys(value);
    const propertySchema = { ...schema.propertyNames, type: "string" };
    properties.forEach((prop) => {
      const nextNode = node.next(propertySchema, prop);
      const validationResult = draft.validate(nextNode, prop);
      if (validationResult.length > 0) {
        errors2.push(draft.errors.invalidPropertyNameError({
          property: prop,
          pointer,
          validationError: validationResult[0],
          value: value[prop],
          schema
        }));
      }
    });
    return errors2;
  }
};
var keyword_default2 = KeywordValidation2;

// ../../node_modules/json-schema-library/dist/module/lib/draft06/index.js
var draft06Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf",
      "allOf",
      "anyOf",
      "if"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft06 = class extends Draft {
  constructor(schema, config2 = {}) {
    super(merge_default(draft06Config, config2), schema);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/draft07/index.js
var draft07Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      "dependencies",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required"
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default2,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef2,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft07 = class extends Draft {
  constructor(schema, config2 = {}) {
    super(merge_default(draft07Config, config2), schema);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/draft2019/validation/keyword.js
var getPatternTests = (patternProperties) => isObject(patternProperties) ? Object.keys(patternProperties).map((pattern) => new RegExp(pattern)) : [];
function isPropertyEvaluated(schemaNode, propertyName, value) {
  var _a2, _b;
  const node = schemaNode.draft.resolveRef(schemaNode);
  const { schema } = node;
  if (schema.additionalProperties === true) {
    return true;
  }
  if ((_a2 = schema.properties) === null || _a2 === void 0 ? void 0 : _a2[propertyName]) {
    const nextSchema = (_b = schema.properties) === null || _b === void 0 ? void 0 : _b[propertyName];
    if (node.draft.isValid(value, nextSchema)) {
      return true;
    }
  }
  const patterns = getPatternTests(schema.patternProperties);
  if (patterns.find((pattern) => pattern.test(propertyName))) {
    return true;
  }
  if (isObject(schema.additionalProperties)) {
    const nextSchema = schema.additionalProperties;
    return node.draft.validate(node.next(nextSchema), value);
  }
  return false;
}
var KeywordValidation3 = {
  // ...omit(Keywords, "dependencies"),
  ...keyword_default2,
  dependencies: void 0,
  dependentSchemas: validateDependentSchemas,
  dependentRequired: validateDependentRequired,
  /**
   * @draft >= 2019-09
   * Similar to additionalProperties, but can "see" into subschemas and across references
   * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.2.4
   */
  unevaluatedProperties: (node, value) => {
    var _a2;
    const { draft, schema, pointer } = node;
    if (!isObject(value) || schema.unevaluatedProperties == null) {
      return void 0;
    }
    let unevaluated = Object.keys(value);
    if (unevaluated.length === 0) {
      return void 0;
    }
    const reduction = reduceSchema(node, value);
    const resolvedSchema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    if (resolvedSchema.unevaluatedProperties === true) {
      return void 0;
    }
    const testPatterns = getPatternTests(resolvedSchema.patternProperties);
    unevaluated = unevaluated.filter((key) => {
      var _a3;
      if ((_a3 = resolvedSchema.properties) === null || _a3 === void 0 ? void 0 : _a3[key]) {
        return false;
      }
      if (isObject(schema.if) && isPropertyEvaluated(node.next({ type: "object", ...schema.if }), key, value[key])) {
        return false;
      }
      if (testPatterns.find((pattern) => pattern.test(key))) {
        return false;
      }
      if (resolvedSchema.additionalProperties) {
        return false;
      }
      return true;
    });
    if (unevaluated.length === 0) {
      return void 0;
    }
    const errors2 = [];
    if (resolvedSchema.unevaluatedProperties === false) {
      unevaluated.forEach((key) => {
        errors2.push(draft.errors.unevaluatedPropertyError({
          pointer: `${pointer}/${key}`,
          value: JSON.stringify(value[key]),
          schema
        }));
      });
      return errors2;
    }
    unevaluated.forEach((key) => {
      if (isObject(resolvedSchema.unevaluatedProperties)) {
        const keyErrors = draft.validate(node.next(resolvedSchema.unevaluatedProperties, key), value[key]);
        errors2.push(...keyErrors);
      }
    });
    return errors2;
  },
  /**
   * @draft >= 2019-09
   * Similar to additionalItems, but can "see" into subschemas and across references
   * https://json-schema.org/draft/2019-09/json-schema-core#rfc.section.9.3.1.3
   */
  unevaluatedItems: (node, value) => {
    var _a2;
    const { draft, schema, pointer } = node;
    if (!Array.isArray(value) || value.length === 0 || schema.unevaluatedItems == null || schema.unevaluatedItems === true) {
      return void 0;
    }
    const reduction = reduceSchema(draft.resolveRef(node), value);
    const resolvedSchema = (_a2 = reduction.schema) !== null && _a2 !== void 0 ? _a2 : reduction;
    if (resolvedSchema.unevaluatedItems === true || resolvedSchema.additionalItems === true) {
      return void 0;
    }
    if (isObject(schema.if)) {
      const nextSchemaNode = { type: "array", ...schema.if };
      if (draft.isValid(value, nextSchemaNode)) {
        if (Array.isArray(nextSchemaNode.items) && nextSchemaNode.items.length === value.length) {
          return void 0;
        }
      }
    }
    if (isObject(resolvedSchema.items)) {
      const nextSchemaNode = { ...resolvedSchema, unevaluatedItems: void 0 };
      const errors3 = draft.validate(node.next(nextSchemaNode), value);
      return errors3.map((e) => draft.errors.unevaluatedItemsError({ ...e.data }));
    }
    if (Array.isArray(resolvedSchema.items)) {
      const items = [];
      for (let i = resolvedSchema.items.length; i < value.length; i += 1) {
        if (i < resolvedSchema.items.length) {
          if (draft.validate(node.next(resolvedSchema.items[i], i), value[i]).length > 0) {
            items.push({ index: i, value: value[i] });
          }
        } else {
          items.push({ index: i, value: value[i] });
        }
      }
      return items.map((item) => draft.errors.unevaluatedItemsError({
        pointer: `${pointer}/${item.index}`,
        value: JSON.stringify(item.value),
        schema: resolvedSchema.unevaluatedItems
      }));
    }
    if (isObject(resolvedSchema.unevaluatedItems)) {
      return value.map((item, index2) => {
        if (!draft.isValid(item, resolvedSchema.unevaluatedItems)) {
          return draft.errors.unevaluatedItemsError({
            pointer: `${pointer}/${index2}`,
            value: JSON.stringify(item),
            schema: resolvedSchema.unevaluatedItems
          });
        }
      });
    }
    const errors2 = [];
    value.forEach((item, index2) => {
      errors2.push(draft.errors.unevaluatedItemsError({
        pointer: `${pointer}/${index2}`,
        value: JSON.stringify(item),
        schema
      }));
    });
    return errors2;
  }
};
var keyword_default3 = KeywordValidation3;

// ../../node_modules/json-schema-library/dist/module/lib/draft2019/index.js
var draft2019Config = {
  typeKeywords: {
    array: [
      "allOf",
      "anyOf",
      "contains",
      "enum",
      "if",
      "items",
      "maxItems",
      "minItems",
      "not",
      "oneOf",
      "unevaluatedItems",
      "uniqueItems"
    ],
    boolean: ["allOf", "anyOf", "enum", "not", "oneOf"],
    object: [
      "additionalProperties",
      "allOf",
      "anyOf",
      // "dependencies",
      "dependentSchemas",
      "dependentRequired",
      "enum",
      "format",
      "if",
      "maxProperties",
      "minProperties",
      "not",
      "oneOf",
      "patternProperties",
      "properties",
      "propertyNames",
      "required",
      "unevaluatedProperties"
      // 2019-09
    ],
    string: [
      "allOf",
      "anyOf",
      "enum",
      "format",
      "if",
      "maxLength",
      "minLength",
      "not",
      "oneOf",
      "pattern"
    ],
    number: [
      "allOf",
      "anyOf",
      "enum",
      "exclusiveMaximum",
      "exclusiveMinimum",
      "format",
      "if",
      "maximum",
      "minimum",
      "multipleOf",
      "not",
      "oneOf"
    ],
    null: ["allOf", "anyOf", "enum", "format", "not", "oneOf"]
  },
  validateKeyword: keyword_default3,
  validateType: type_default,
  validateFormat: format_default,
  errors: errors_default,
  createNode,
  addRemoteSchema: addRemoteSchema2,
  compileSchema: compileSchema2,
  createSchemaOf,
  each,
  eachSchema,
  getChildSchemaSelection,
  getSchema,
  getTemplate: getTemplate_default,
  isValid,
  resolveAllOf,
  resolveAnyOf,
  resolveOneOf,
  resolveRef: resolveRef3,
  step,
  validate,
  templateDefaultOptions: settings_default.templateDefaultOptions
};
var Draft2019 = class extends Draft {
  constructor(schema, config2 = {}) {
    super(merge_default(draft2019Config, config2), schema);
  }
};

// ../../node_modules/json-schema-library/dist/module/lib/jsoneditor/index.js
var draftJsonEditorConfig = {
  ...draft07Config,
  resolveOneOf: resolveOneOfFuzzy,
  resolveRef: resolveRef3
};
var JsonEditor = class extends Draft {
  constructor(schema, config2 = {}) {
    super(merge_default(draftJsonEditorConfig, config2), schema);
  }
};

// ../../node_modules/json-schema-library/dist/module/index.js
var config = { strings: strings_default };
export {
  Draft,
  Draft04,
  Draft06,
  Draft07,
  Draft2019,
  JsonEditor,
  config,
  createCustomError,
  createError,
  createNode,
  draft04Config,
  draft06Config,
  draft07Config,
  draft2019Config,
  draftJsonEditorConfig,
  getTypeOf,
  isDynamicSchema,
  isJsonError,
  isSchemaNode,
  mergeSchema,
  reduceSchema,
  render,
  resolveAllOf,
  resolveDynamicSchema,
  resolveOneOf,
  resolveOneOfFuzzy,
  resolveRef3 as resolveRef,
  resolveRef2 as resolveRefStrict,
  settings_default as settings,
  validateAsync
};
//# sourceMappingURL=json-schema-library.js.map
